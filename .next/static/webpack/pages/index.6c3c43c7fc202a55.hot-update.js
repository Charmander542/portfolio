"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Hero/Hero.js":
/*!*********************************!*\
  !*** ./components/Hero/Hero.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass */ \"./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits */ \"./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn */ \"./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf */ \"./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var typed_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! typed.js */ \"./node_modules/typed.js/dist/typed.module.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/index.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../constants */ \"./constants.js\");\n/* harmony import */ var _Hero_module_scss__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Hero.module.scss */ \"./components/Hero/Hero.module.scss\");\n/* harmony import */ var _Hero_module_scss__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_Hero_module_scss__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _Button_Button__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Button/Button */ \"./components/Button/Button.js\");\n/* harmony import */ var _Profiles_Profiles__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Profiles/Profiles */ \"./components/Profiles/Profiles.js\");\n/* harmony import */ var react_use_downloader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-use-downloader */ \"./node_modules/react-use-downloader/dist/index.es.js\");\n/* harmony import */ var react_svg_morph__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-svg-morph */ \"./node_modules/react-svg-morph/lib/index.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar _s = $RefreshSig$();\nvar _jsxFileName = \"C:\\\\Code\\\\Portfolio3\\\\portfolio\\\\components\\\\Hero\\\\Hero.js\", _this = undefined;\nvar __jsx = (react__WEBPACK_IMPORTED_MODULE_5___default().createElement);\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = (0,C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = (0,C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return (0,C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this, result);\n    };\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar Blob11 = /*#__PURE__*/ function(_React$Component) {\n    (0,C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Blob1, _React$Component);\n    var _super = _createSuper(Blob1);\n    function Blob1() {\n        (0,C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Blob1);\n        return _super.apply(this, arguments);\n    }\n    (0,C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Blob1, [\n        {\n            key: \"render\",\n            value: function render() {\n                return __jsx(\"svg\", {\n                    width: \"24\",\n                    fill: \"#00ea00\",\n                    height: \"24\",\n                    viewBox: \"0 0 24 24\",\n                    __self: this,\n                    __source: {\n                        fileName: _jsxFileName,\n                        lineNumber: 16,\n                        columnNumber: 9\n                    }\n                }, __jsx(\"path\", {\n                    d: \"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41- 1.41z\",\n                    __self: this,\n                    __source: {\n                        fileName: _jsxFileName,\n                        lineNumber: 17,\n                        columnNumber: 12\n                    }\n                }));\n            }\n        }\n    ]);\n    return Blob1;\n}((react__WEBPACK_IMPORTED_MODULE_5___default().Component));\nvar Blob21 = /*#__PURE__*/ function(_React$Component2) {\n    (0,C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Blob2, _React$Component2);\n    var _super2 = _createSuper(Blob2);\n    function Blob2() {\n        (0,C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Blob2);\n        return _super2.apply(this, arguments);\n    }\n    (0,C_Code_Portfolio3_portfolio_node_modules_next_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Blob2, [\n        {\n            key: \"render\",\n            value: function render() {\n                return __jsx(\"svg\", {\n                    width: \"24\",\n                    height: \"24\",\n                    fill: \"#666666\",\n                    viewBox: \"0 0 24 24\",\n                    __self: this,\n                    __source: {\n                        fileName: _jsxFileName,\n                        lineNumber: 26,\n                        columnNumber: 9\n                    }\n                }, __jsx(\"path\", {\n                    d: \"M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z\",\n                    __self: this,\n                    __source: {\n                        fileName: _jsxFileName,\n                        lineNumber: 27,\n                        columnNumber: 12\n                    }\n                }));\n            }\n        }\n    ]);\n    return Blob2;\n}((react__WEBPACK_IMPORTED_MODULE_5___default().Component));\nvar Hero = function Hero() {\n    _s();\n    var typedEl = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(null);\n    var targetSection = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(null);\n    var options = {\n        strings: _constants__WEBPACK_IMPORTED_MODULE_8__.TYPED_STRINGS,\n        typeSpeed: 50,\n        startDelay: 1500,\n        backSpeed: 50,\n        backDelay: 1500,\n        loop: true\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)(function() {\n        var typed = new typed_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](typedEl.current, options);\n        var revealTl = gsap__WEBPACK_IMPORTED_MODULE_13__.gsap.timeline({\n            defaults: {\n                ease: gsap__WEBPACK_IMPORTED_MODULE_13__.Linear.easeNone\n            }\n        });\n        revealTl.to(targetSection.current, {\n            opacity: 1,\n            duration: 2\n        }).from(targetSection.current.querySelectorAll(\".seq\"), {\n            opacity: 0,\n            duration: 0.5,\n            stagger: 0.5\n        }, \"<\");\n        return function() {\n            return typed.destroy();\n        };\n    }, [\n        typedEl,\n        targetSection\n    ]);\n    var _useDownloader = (0,react_use_downloader__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(), size = _useDownloader.size, elapsed = _useDownloader.elapsed, percentage = _useDownloader.percentage, download = _useDownloader.download, cancel = _useDownloader.cancel, error = _useDownloader.error, isInProgress = _useDownloader.isInProgress;\n    var fileUrl = \"/resume.pdf\";\n    var filename = \"CharlesVanHookResume.pdf\";\n    return __jsx(\"section\", {\n        ref: targetSection,\n        className: \"w-full flex xs:items-center py-8 2xl:container mx-auto xl:px-20 md:px-12 px-4 min-h-screen relative mb-24\",\n        id: _constants__WEBPACK_IMPORTED_MODULE_8__.MENULINKS[0].ref,\n        style: {\n            opacity: 0\n        },\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 68,\n            columnNumber: 5\n        }\n    }, __jsx(\"style\", {\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 74,\n            columnNumber: 7\n        }\n    }, \"\\n          .typed-cursor {\\n            font-size: 2rem;\\n          }\\n        \"), __jsx(\"div\", {\n        className: \"flex flex-col pt-40 md:pt-0 select-none\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 81,\n            columnNumber: 7\n        }\n    }, __jsx(\"h1\", {\n        className: \"\".concat((_Hero_module_scss__WEBPACK_IMPORTED_MODULE_14___default().intro), \" font-mono font-bold text-5xl seq\"),\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 82,\n            columnNumber: 9\n        }\n    }, \"Hello, \", __jsx(\"br\", {\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 83,\n            columnNumber: 18\n        }\n    }), \" I'm\\xa0\", __jsx(\"span\", {\n        ref: typedEl,\n        className: \"seq text-5xl text-mush-light font-mono leading-relaxed\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 84,\n            columnNumber: 11\n        }\n    })), __jsx(\"p\", {\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 89,\n            columnNumber: 9\n        }\n    }), __jsx(\"div\", {\n        className: \"seq\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 90,\n            columnNumber: 9\n        }\n    }, __jsx(_Profiles_Profiles__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 91,\n            columnNumber: 11\n        }\n    })), __jsx(\"div\", {\n        className: \"seq flex pt-4\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 93,\n            columnNumber: 9\n        }\n    }, __jsx(_Button_Button__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n        href: \"#\".concat(_constants__WEBPACK_IMPORTED_MODULE_8__.MENULINKS[3].ref),\n        classes: \"link\",\n        type: \"primary\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 94,\n            columnNumber: 11\n        }\n    }, \"Let's Talk\"), __jsx(_Button_Button__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n        onClick: function onClick() {\n            return download(fileUrl, filename);\n        },\n        classes: \"link ml-5\",\n        type: \"primary\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 97,\n            columnNumber: 11\n        }\n    }, \"Resume\"))), __jsx(\"svg\", {\n        id: \"visual\",\n        viewBox: \"0 0 900 600\",\n        width: \"900\",\n        height: \"600\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        className: \"seq absolute pic -z-1 w-1/2 h-full\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 106,\n            columnNumber: 7\n        }\n    }, __jsx(\"g\", {\n        transform: \"translate(456.26875899576186 325.41510219584285)\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 115,\n            columnNumber: 9\n        }\n    }, __jsx(\"path\", {\n        d: \"M98 -113.2C125.4 -70.7 144.7 -35.4 159.9 15.2C175.1 65.8 186.2 131.5 158.9 159.9C131.5 188.2 65.8 179.1 4.8 174.3C-56.1 169.4 -112.2 168.9 -141 140.5C-169.9 112.2 -171.4 56.1 -178.7 -7.3C-186 -70.7 -199.1 -141.4 -170.3 -183.9C-141.4 -226.4 -70.7 -240.7 -17.7 -223C35.4 -205.4 70.7 -155.7 98 -113.2\",\n        fill: \"#ff0\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 116,\n            columnNumber: 11\n        }\n    })), __jsx(\"g\", {\n        transform: \"translate(438.92187323657697 294.4913537537576)\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 122,\n            columnNumber: 9\n        }\n    }, __jsx(\"path\", {\n        d: \"M146.4 -140.4C183.9 -108.9 204.4 -54.4 199.5 -4.9C194.5 44.5 164.1 89.1 126.6 117.6C89.1 146.1 44.5 158.5 -13.1 171.6C-70.7 184.7 -141.4 198.4 -166.4 169.9C-191.4 141.4 -170.7 70.7 -155.4 15.3C-140.1 -40.1 -130.1 -80.1 -105.1 -111.6C-80.1 -143.1 -40.1 -166.1 7.2 -173.3C54.4 -180.4 108.9 -171.9 146.4 -140.4\",\n        fill: \"#ff0\",\n        __self: _this,\n        __source: {\n            fileName: _jsxFileName,\n            lineNumber: 123,\n            columnNumber: 11\n        }\n    }))));\n};\n_s(Hero, \"uoUSsWjrHaTGbXzl3EnSvSbrdOU=\", false, function() {\n    return [\n        react_use_downloader__WEBPACK_IMPORTED_MODULE_11__[\"default\"]\n    ];\n});\n_c = Hero;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Hero);\n__jsx(\"div\", {\n    className: \"seq absolute pic -z-1 w-1/2 h-full\",\n    __self: undefined,\n    __source: {\n        fileName: _jsxFileName,\n        lineNumber: 135,\n        columnNumber: 1\n    }\n}, __jsx((next_image__WEBPACK_IMPORTED_MODULE_6___default()), {\n    src: \"/person.png\",\n    layout: \"fill\",\n    __self: undefined,\n    __source: {\n        fileName: _jsxFileName,\n        lineNumber: 136,\n        columnNumber: 3\n    }\n}));\nvar _c;\n$RefreshReg$(_c, \"Hero\");\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0hlcm8vSGVyby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtSTtBQUNOO0FBQ047QUFDa0M7QUFDdEI7QUFHMUc7QUFOSztBQUNGO0FBQ1A7QUFDWTtBQUNNO0FBQ0Y7QUFDaEI7QUFDSztBQUNvQjtBQUduQzs7QUFQWCxHQUFHLENBQUNvQixZQUFZLEdBQUcsQ0FBNEQsNkRBQzdFQyxLQUFLLEdBQUcsU0FBSTtBQUVkLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHakIsNERBQW1CO1NBQ3RCbUIsWUFBWSxDQUFDQyxPQUFPLEVBQUUsQ0FBQztJQUFDLEdBQUcsQ0FBQ0MseUJBQXlCLEdBQUdDLHlCQUF5QjtJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUNDLG9CQUFvQixHQUFHLENBQUM7UUFBQyxHQUFHLENBQUNDLEtBQUssR0FBR3pCLCtJQUFlLENBQUNxQixPQUFPLEdBQUdLLE1BQU07UUFBRSxFQUFFLEVBQUVKLHlCQUF5QixFQUFFLENBQUM7WUFBQyxHQUFHLENBQUNLLFNBQVMsR0FBRzNCLCtJQUFlLENBQUMsSUFBSSxFQUFFNEIsV0FBVztZQUFFRixNQUFNLEdBQUdHLE9BQU8sQ0FBQ0MsU0FBUyxDQUFDTCxLQUFLLEVBQUVNLFNBQVMsRUFBRUosU0FBUztRQUFHLENBQUMsTUFBTSxDQUFDO1lBQUNELE1BQU0sR0FBR0QsS0FBSyxDQUFDTyxLQUFLLENBQUMsSUFBSSxFQUFFRCxTQUFTO1FBQUcsQ0FBQztRQUFDLE1BQU0sQ0FBQ2hDLDBKQUEwQixDQUFDLElBQUksRUFBRTJCLE1BQU07SUFBRyxDQUFDO0FBQUUsQ0FBQztTQVRoYUgseUJBQXFCLEdBQU07SUFBQSxVQUFRLENBQUFNLE9BQU8scUJBQUFBLE9BQUEsQ0FBQUMsU0FBQTtJQUFBLElBQUFELE9BQUEsQ0FBQUMsU0FBQSxDQUFBRyxJQUFBO0lBQUEsV0FBQUMsS0FBQTtJQUFBO1FBQUFDLE9BQUEsQ0FBQUMsU0FBQSxDQUFBQyxPQUFBLENBQUFDLElBQUEsQ0FBQVQsT0FBQSxDQUFBQyxTQUFBLENBQUFLLE9BQUE7UUFBQTtRQUFBO0lBQUEsU0FBQUksQ0FBQTtRQUFBO0lBQUE7QUFBQTtBQVl4QyxJQUFBQyxNQUFBLDBCQUFBQyxnQkFBQTtJQUFBM0MseUlBQUEsQ0FBQTBDLEtBQUEsRUFBQUMsZ0JBQUE7SUFBQSxJQUFBQyxNQUFBLEdBQUF0QixZQUFBLENBQUFvQixLQUFBO2FBQUFBLEtBQUE7UUFBQTVDLCtJQUFBLE9BQUE0QyxLQUFBO1FBQUEsT0FBQUUsTUFBQSxDQUFBVixLQUFBLE9BQUFELFNBQUE7SUFBQTtJQUFBbEMsNElBQUEsQ0FBQTJDLEtBQUE7UUFBQTtZQUFBRyxHQUFBLEdBQ1Q7WUFBU0MsS0FDTixVQUNHLENBQUFDLE1BQUE7Z0JBQUEsTUFBSyxDQUFLM0IsS0FBQyxDQUFJO29CQUFDNEIsS0FBSSxFQUFDO29CQUFVQyxJQUFBLEVBQU0sQ0FBSztvQkFBQ0MsTUFBQSxFQUFPLENBQUM7b0JBQVdDLE9BQUE7b0JBQUFDLE1BQUE7b0JBQUFDLFFBQUE7d0JBQUFDLFFBQUEsRUFBQXBDLFlBQUE7d0JBQUFxQyxVQUFBO3dCQUFBQyxZQUFBO29CQUFBLENBQzNEO2dCQUFBLEdBQU9wQyxLQUFDO29CQUFvRHFDLENBQUE7b0JBQUFMLE1BQUE7b0JBQUFDLFFBQUE7d0JBQUFDLFFBQUEsRUFBQXBDLFlBQUE7d0JBQUFxQyxVQUFBO3dCQUFBQyxZQUFBO29CQUMxRCxDQUFDO2dCQUVaO1lBQUM7UUFBQTtJQUFBO0lBUGlCLE1BQU0sQ0FBQWQsS0FBQTtBQUFTLEVBQUF2Qyx3REFVeEI7QUFBQSxJQUFBd0QsTUFBQSwwQkFBQUMsaUJBQUE7SUFBQTVELHlJQUFBLENBQUEyRCxLQUFBLEVBQUFDLGlCQUFBO0lBQUEsSUFBQUMsT0FBQSxHQUFBdkMsWUFBQSxDQUFBcUMsS0FBQTthQUFBQSxLQUFBO1FBQUE3RCwrSUFBQSxPQUFBNkQsS0FBQTtRQUFBLE9BQUFFLE9BQUEsQ0FBQTNCLEtBQUEsT0FBQUQsU0FBQTtJQUFBO0lBQUFsQyw0SUFBQSxDQUFBNEQsS0FBQTtRQUFBO1lBQUFkLEdBQUEsR0FDVDtZQUFTQyxLQUNOLFVBQ0csQ0FBQUMsTUFBQTtnQkFBQSxNQUFLLENBQUszQixLQUFDLENBQUk7b0JBQUM0QixLQUFBLEVBQU0sQ0FBQztvQkFBS0UsTUFBSztvQkFBVUQsSUFBQSxHQUFRO29CQUFXRSxPQUFBO29CQUFBQyxNQUFBO29CQUFBQyxRQUFBO3dCQUFBQyxRQUFBLEVBQUFwQyxZQUFBO3dCQUFBcUMsVUFBQTt3QkFBQUMsWUFBQTtvQkFBQSxDQUMzRDtnQkFBQSxHQUFPcEMsS0FBQztvQkFBNEZxQyxDQUFBO29CQUFBTCxNQUFBO29CQUFBQyxRQUFBO3dCQUFBQyxRQUFBLEVBQUFwQyxZQUFBO3dCQUFBcUMsVUFBQTt3QkFBQUMsWUFBQTtvQkFDbEcsQ0FBQztnQkFFWjtZQUFDO1FBQUE7SUFBQTtJQVBpQixNQUFNLENBQUFHLEtBQUE7QUFVMUIsRUFBQXhELHdEQUFhO0FBQU0sR0FDakIsQ0FBQTJELElBQU0sV0FBVSxDQUFBQSxJQUFPLEdBQUksQ0FBQzs7SUFDNUIsSUFBTUMsT0FBQSxHQUFBekQsNkNBQWdCO0lBRXRCLElBQU0wRCxhQUFVLEdBQUExRCw2Q0FBQTtJQUFBLEdBQ2QsQ0FBQTJELE9BQVM7UUFDVEMsT0FBQSxFQUFTdEQscURBQUk7UUFDYnVELFNBQUEsRUFBVSxFQUFFO1FBQ1pDLFVBQVMsRUFBRSxJQUFFO1FBQ2JDLFNBQVMsRUFBRTtRQUNYQyxTQUFNO1FBQ1BDLElBQUE7SUFFRDtJQUFnQmxFLGdEQUNSLFNBQVksSUFBSztRQUV2QixJQUFNbUUsS0FBQSxHQUFRLEdBQUcsQ0FBQWhFLGdEQUFLLENBQUF1RCxPQUFTLENBQUFVLE9BQUEsRUFBQVIsT0FBQTtRQUFBLEdBQUUsQ0FBQVMsUUFBVSxHQUFBakUsZ0RBQUE7WUFBQW1FLFFBQVE7Z0JBQWdCQyxJQUFBLEVBQUFuRSxrREFBQTtZQUFJO1FBQ3ZFO1FBQzZCZ0UsUUFBRSxDQUFPSyxFQUFFLENBQUNmLGFBQUEsQ0FBQVMsT0FBQTtZQUFFTyxPQUFBLEVBQVEsQ0FBRTtZQUFJQyxRQUVyRDtRQUNBLEdBQUVDLElBQUEsQ0FBQWxCLGFBQVUsQ0FBQVMsT0FBQSxDQUFBVSxnQkFBQTtZQUFFSCxPQUFBLEVBQVEsQ0FBRTtZQUFLQyxRQUFPLEVBQUU7WUFBS0csT0FFNUM7UUFFSDtRQUFPLGVBQVk7WUFBUyxPQUFBWixLQUFBLENBQUFhLE9BQUE7UUFDN0IsQ0FBRTtJQUVILElBQUF0QjtRQUFBQSxPQUFBO1FBQUFDLGFBQ0U7SUFBQTtJQUFlLEdBRFQsQ0FBQXNCLGNBQUksR0FBQXRFLGlFQUFBLElBQUV1RSxJQUFBLEdBQU9ELGNBQUEsQ0FBQUMsSUFBUCxFQUFTQyxPQUFBLEdBQVVGLGNBQUEsQ0FBQUUsT0FBVixFQUFZQyxVQUFRLEdBQUFILGNBQVIsQ0FBQUcsVUFBUSxFQUFFQyxRQUFNLEdBQUFKLGNBQU4sQ0FBQUksUUFBTSxFQUFFQyxNQUFLLEdBQUFMLGNBQUwsQ0FBQUssTUFBSyxFQUFFQyxLQUFBLEdBQUFOLGNBQVksQ0FBQU0sS0FBQSxFQUd4RUMsWUFBZ0IsR0FBQVAsY0FBYSxDQUFBTyxZQUFBO0lBQzdCLElBQU1DLE9BQUEsR0FBUSxDQUFHO0lBRWpCLElBQUFDLFFBQ0U7SUFBQSxNQUNLLENBQUUzRSxLQUFBLEVBQWM7UUFDbkI0RSxHQUFBLEVBQUFoQyxhQUFVO1FBQ1ZpQyxTQUFJLEdBQWlCO1FBQ3JCQyxFQUFBLEVBQUF2Rix3REFBTztRQUFBd0YsS0FBRTtZQUFhbkIsT0FBQTtRQUFBO1FBQUE1QixNQUFBLEVBQUFqQyxLQUFBO1FBQUFrQyxRQUFBO1lBQUFDLFFBQUEsRUFBQXBDLFlBQUE7WUFBQXFDLFVBQUE7WUFBQUMsWUFBQTtRQUFBLENBRXRCO0lBQUEsR0FBQXBDLEtBQUE7UUFBQWdDLE1BQUEsRUFBQWpDLEtBQUE7UUFBQWtDLFFBQUE7WUFBQUMsUUFBQSxFQUFBcEMsWUFBQTtZQUFBcUMsVUFBQTtZQUFBQyxZQUFBO1FBQUE7SUFPQSxHQUFLLENBQW1ELG9GQUFBcEMsS0FBQTtRQUFBNkUsU0FBQTtRQUFBN0MsTUFBQSxFQUFBakMsS0FBQTtRQUFBa0MsUUFBQTtZQUFBQyxRQUFBLEVBQUFwQyxZQUFBO1lBQUFxQyxVQUFBO1lBQUFDLFlBQUE7UUFBQSxDQUN0RDtJQUFBLEdBQUlwQyxLQUFBLEVBQVM7UUFBcUQ2RSxTQUFBLEtBQUFHLE1BQUEsQ0FBQXZGLGlFQUFBO1FBQUF1QyxNQUFBLEVBQUFqQyxLQUFBO1FBQUFrQyxRQUFBO1lBQUFDLFFBQUEsRUFBQXBDLFlBQUE7WUFBQXFDLFVBQUE7WUFBQUMsWUFBQTtRQUFBO0lBQ3pELGNBQUFwQyxLQUFBO1FBQUFnQyxNQUFBLEVBQUFqQyxLQUFBO1FBQUFrQyxRQUFBO1lBQUFDLFFBQUEsRUFBQXBDLFlBQUE7WUFBQXFDLFVBQUE7WUFBQUMsWUFBQTtRQUFNO0lBQ2IsSUFDRSxDQUFhLFdBQUFwQyxLQUFBO1FBQ2I0RSxHQUFBLEVBQUFqQyxPQUFVO1FBQXdEa0MsU0FBQTtRQUFBN0MsTUFBQSxFQUFBakMsS0FBQTtRQUFBa0MsUUFBQTtZQUFBQyxRQUFBLEVBQUFwQyxZQUFBO1lBQUFxQyxVQUFBO1lBQUFDLFlBQUE7UUFFbEUsQ0FBQztJQUNMLEtBQUFwQyxLQUFBO1FBQUFnQyxNQUFBLEVBQUFqQyxLQUFBO1FBQUFrQyxRQUFBO1lBQUFDLFFBQUEsRUFBQXBDLFlBQUE7WUFBQXFDLFVBQUE7WUFBQUMsWUFBQTtRQUFPO0lBQ1AsSUFBS3BDLEtBQUEsRUFBVSxPQUFLO1FBQUE2RSxTQUFBO1FBQUE3QyxNQUFBLEVBQUFqQyxLQUFBO1FBQUFrQyxRQUFBO1lBQUFDLFFBQUEsRUFBQXBDLFlBQUE7WUFBQXFDLFVBQUE7WUFBQUMsWUFBQTtRQUFBLENBQ2xCO0lBQVMsR0FBQXBDLEtBQUEsQ0FBQUwsMkRBQUE7UUFBQXFDLE1BQUEsRUFBQWpDLEtBQUE7UUFBQWtDLFFBQUE7WUFBQUMsUUFBQSxFQUFBcEMsWUFBQTtZQUFBcUMsVUFBQTtZQUFBQyxZQUFBO1FBQ04sQ0FBQztJQUNOLEtBQUtwQyxLQUFBLENBQVMsQ0FBQztRQUFlNkUsU0FBQTtRQUFBN0MsTUFBQSxFQUFBakMsS0FBQTtRQUFBa0MsUUFBQTtZQUFBQyxRQUFBLEVBQUFwQyxZQUFBO1lBQUFxQyxVQUFBO1lBQUFDLFlBQUE7UUFBQSxDQUM1QjtJQUFPLEdBQUNwQyxLQUFJLENBQUFOLHNEQUFBO1FBQTBCd0YsSUFBQSxHQUFRLEdBQUFGLE1BQU0sQ0FBQXpGLHdEQUFBO1FBQUM0RixPQUFLLEdBQVM7UUFBQUMsSUFBQTtRQUFBcEQsTUFBQSxFQUFBakMsS0FBQTtRQUFBa0MsUUFBQTtZQUFBQyxRQUFBLEVBQUFwQyxZQUFBO1lBQUFxQyxVQUFBO1lBQUFDLFlBQUE7UUFBQTtJQUc1RCxHQUNMLENBQVMsY0FBQXBDLEtBQUEsQ0FBQU4sc0RBQUE7UUFBQTJGLE9BQUEsRUFBTSxRQUFRLENBQUNBLE9BQU8sR0FBRTtZQUFVLE9BQUFmLFFBQUEsQ0FBQUksT0FBQSxFQUFBQyxRQUFBO1FBQzNDO1FBQ0FRLE9BQUssR0FBUztRQUFBQyxJQUFBO1FBQUFwRCxNQUFBLEVBQUFqQyxLQUFBO1FBQUFrQyxRQUFBO1lBQUFDLFFBQUEsRUFBQXBDLFlBQUE7WUFBQXFDLFVBQUE7WUFBQUMsWUFBQTtRQUFBO0lBTXBCLEdBQ0UsQ0FBRyxZQUFRcEMsS0FBQTtRQUNYOEUsRUFBQSxHQUFRO1FBQ1IvQyxPQUFNLEdBQUs7UUFDWEgsS0FBQSxFQUFNLENBQUM7UUFDUEUsTUFBSyxFQUFDO1FBQ053RCxLQUFBLEVBQU8sQ0FBTTtRQUNiQyxPQUFBLEVBQVMsQ0FBQztRQUFvQ1YsU0FBQTtRQUFBN0MsTUFBQSxFQUFBakMsS0FBQTtRQUFBa0MsUUFBQTtZQUFBQyxRQUFBLEVBQUFwQyxZQUFBO1lBQUFxQyxVQUFBO1lBQUFDLFlBQUE7UUFBQSxDQUU5QztJQUFBLEdBQUdwQyxLQUFBLEVBQVMsSUFBQztRQUFrRHdGLFNBQUE7UUFBQXhELE1BQUEsRUFBQWpDLEtBQUE7UUFBQWtDLFFBQUE7WUFBQUMsUUFBQSxFQUFBcEMsWUFBQTtZQUFBcUMsVUFBQTtZQUFBQyxZQUFBO1FBQUEsQ0FDN0Q7SUFBQSxHQUNHcEMsS0FBQztRQUNGcUMsQ0FBQSxHQUFXO1FBQUFSLElBQUE7UUFBQUcsTUFBQSxFQUFBakMsS0FBQTtRQUFBa0MsUUFBQTtZQUFBQyxRQUFBLEVBQUFwQyxZQUFBO1lBQUFxQyxVQUFBO1lBQUFDLFlBQUE7UUFFWixDQUFDO0lBRUosS0FBR3BDLEtBQUEsQ0FBUyxDQUFDO1FBQWlEd0YsU0FBQTtRQUFBeEQsTUFBQSxFQUFBakMsS0FBQTtRQUFBa0MsUUFBQTtZQUFBQyxRQUFBLEVBQUFwQyxZQUFBO1lBQUFxQyxVQUFBO1lBQUFDLFlBQUE7UUFBQSxDQUM1RDtJQUFBLEdBQ0dwQyxLQUFDO1FBQ0ZxQyxDQUFBLEdBQVc7UUFBQVIsSUFBQTtRQUFBRyxNQUFBLEVBQUFqQyxLQUFBO1FBQUFrQyxRQUFBO1lBQUFDLFFBQUEsRUFBQXBDLFlBQUE7WUFBQXFDLFVBQUE7WUFBQUMsWUFBQTtRQUVaLENBQ0E7SUFHVjtBQUVEO0dBbkdFTSxJQUFNOztRQTJCTTlDLDZEQUFBOzs7S0EzQlo4QyxJQUFNO0FBcUdSLCtEQUFBQSxJQUFBO0FBQUExQyxLQUFLLEVBQVMsTUFBQztJQUFvQzZFLFNBQUE7SUFBQTdDLE1BQUE7SUFBQUMsUUFBQTtRQUFBQyxRQUFBLEVBQUFwQyxZQUFBO1FBQUFxQyxVQUFBO1FBQUFDLFlBQUE7SUFBQSxDQUNqRDtBQUFNLEdBQUNwQyxLQUFJLENBQUFiLG1EQUFBO0lBQWNzRyxHQUFBLEdBQWE7SUFBQUMsTUFBQTtJQUFBMUQsTUFBQTtJQUFBQyxRQUFBO1FBQUFDLFFBQUEsRUFBQXBDLFlBQUE7UUFBQXFDLFVBQUE7UUFBQUMsWUFBQTtJQUNuQyxDQUFDO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9IZXJvL0hlcm8uanM/NTJkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCI7XHJcbmltcG9ydCBUeXBlZCBmcm9tIFwidHlwZWQuanNcIjtcclxuaW1wb3J0IHsgZ3NhcCwgTGluZWFyIH0gZnJvbSBcImdzYXBcIjtcclxuaW1wb3J0IHsgTUVOVUxJTktTLCBUWVBFRF9TVFJJTkdTIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgc3R5bGVzIGZyb20gXCIuL0hlcm8ubW9kdWxlLnNjc3NcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vQnV0dG9uL0J1dHRvblwiO1xyXG5pbXBvcnQgUHJvZmlsZXMgZnJvbSBcIi4uL1Byb2ZpbGVzL1Byb2ZpbGVzXCI7XHJcbmltcG9ydCB1c2VEb3dubG9hZGVyIGZyb20gXCJyZWFjdC11c2UtZG93bmxvYWRlclwiO1xyXG5pbXBvcnQgeyBNb3JwaFJlcGxhY2UgfSBmcm9tIFwicmVhY3Qtc3ZnLW1vcnBoXCI7XHJcblxyXG5cclxuY2xhc3MgQmxvYjEgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIHJlbmRlcigpIHtcclxuICAgICByZXR1cm4gKFxyXG4gICAgICAgIDxzdmcgd2lkdGg9XCIyNFwiIGZpbGw9XCIjMDBlYTAwXCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgPHBhdGggZD1cIk05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtIDEuNDF6XCIgLz5cclxuICAgICAgICA8L3N2Zz5cclxuICAgICApO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgQmxvYjIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gIHJlbmRlcigpIHtcclxuICAgICByZXR1cm4gKFxyXG4gICAgICAgIDxzdmcgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIiM2NjY2NjZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgPHBhdGggZD1cIk0xOSA1djE0SDVWNWgxNG0wLTJINWMtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yelwiIC8+XHJcbiAgICAgICAgPC9zdmc+XHJcbiAgICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IEhlcm8gPSAoKSA9PiB7XHJcbiAgY29uc3QgdHlwZWRFbCA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCB0YXJnZXRTZWN0aW9uID0gdXNlUmVmKG51bGwpO1xyXG5cclxuICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgc3RyaW5nczogVFlQRURfU1RSSU5HUyxcclxuICAgIHR5cGVTcGVlZDogNTAsXHJcbiAgICBzdGFydERlbGF5OiAxNTAwLFxyXG4gICAgYmFja1NwZWVkOiA1MCxcclxuICAgIGJhY2tEZWxheTogMTUwMCxcclxuICAgIGxvb3A6IHRydWUsXHJcbiAgfTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IHR5cGVkID0gbmV3IFR5cGVkKHR5cGVkRWwuY3VycmVudCwgb3B0aW9ucyk7XHJcblxyXG4gICAgY29uc3QgcmV2ZWFsVGwgPSBnc2FwLnRpbWVsaW5lKHsgZGVmYXVsdHM6IHsgZWFzZTogTGluZWFyLmVhc2VOb25lIH0gfSk7XHJcbiAgICByZXZlYWxUbFxyXG4gICAgICAudG8odGFyZ2V0U2VjdGlvbi5jdXJyZW50LCB7IG9wYWNpdHk6IDEsIGR1cmF0aW9uOiAyIH0pXHJcbiAgICAgIC5mcm9tKFxyXG4gICAgICAgIHRhcmdldFNlY3Rpb24uY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlcVwiKSxcclxuICAgICAgICB7IG9wYWNpdHk6IDAsIGR1cmF0aW9uOiAwLjUsIHN0YWdnZXI6IDAuNSB9LFxyXG4gICAgICAgIFwiPFwiXHJcbiAgICAgICk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHR5cGVkLmRlc3Ryb3koKTtcclxuICB9LCBbdHlwZWRFbCwgdGFyZ2V0U2VjdGlvbl0pO1xyXG5cclxuICBjb25zdCB7IHNpemUsIGVsYXBzZWQsIHBlcmNlbnRhZ2UsIGRvd25sb2FkLCBjYW5jZWwsIGVycm9yLCBpc0luUHJvZ3Jlc3MgfSA9XHJcbiAgICB1c2VEb3dubG9hZGVyKCk7XHJcblxyXG4gIGNvbnN0IGZpbGVVcmwgPSBcIi9yZXN1bWUucGRmXCI7XHJcbiAgY29uc3QgZmlsZW5hbWUgPSBcIkNoYXJsZXNWYW5Ib29rUmVzdW1lLnBkZlwiO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPHNlY3Rpb25cclxuICAgICAgcmVmPXt0YXJnZXRTZWN0aW9ufVxyXG4gICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgZmxleCB4czppdGVtcy1jZW50ZXIgcHktOCAyeGw6Y29udGFpbmVyIG14LWF1dG8geGw6cHgtMjAgbWQ6cHgtMTIgcHgtNCBtaW4taC1zY3JlZW4gcmVsYXRpdmUgbWItMjRcIlxyXG4gICAgICBpZD17TUVOVUxJTktTWzBdLnJlZn1cclxuICAgICAgc3R5bGU9e3sgb3BhY2l0eTogMCB9fVxyXG4gICAgPlxyXG4gICAgICA8c3R5bGU+XHJcbiAgICAgICAge2BcclxuICAgICAgICAgIC50eXBlZC1jdXJzb3Ige1xyXG4gICAgICAgICAgICBmb250LXNpemU6IDJyZW07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgYH1cclxuICAgICAgPC9zdHlsZT5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHB0LTQwIG1kOnB0LTAgc2VsZWN0LW5vbmVcIj5cclxuICAgICAgICA8aDEgY2xhc3NOYW1lPXtgJHtzdHlsZXMuaW50cm99IGZvbnQtbW9ubyBmb250LWJvbGQgdGV4dC01eGwgc2VxYH0+XHJcbiAgICAgICAgICBIZWxsbywgPGJyIC8+IEkmYXBvczttJm5ic3A7XHJcbiAgICAgICAgICA8c3BhblxyXG4gICAgICAgICAgICByZWY9e3R5cGVkRWx9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInNlcSB0ZXh0LTV4bCB0ZXh0LW11c2gtbGlnaHQgZm9udC1tb25vIGxlYWRpbmctcmVsYXhlZFwiXHJcbiAgICAgICAgICA+PC9zcGFuPlxyXG4gICAgICAgIDwvaDE+XHJcbiAgICAgICAgPHA+PC9wPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2VxXCI+XHJcbiAgICAgICAgICA8UHJvZmlsZXMgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNlcSBmbGV4IHB0LTRcIj5cclxuICAgICAgICAgIDxCdXR0b24gaHJlZj17YCMke01FTlVMSU5LU1szXS5yZWZ9YH0gY2xhc3Nlcz1cImxpbmtcIiB0eXBlPVwicHJpbWFyeVwiPlxyXG4gICAgICAgICAgICBMZXQmYXBvcztzIFRhbGtcclxuICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBkb3dubG9hZChmaWxlVXJsLCBmaWxlbmFtZSl9XHJcbiAgICAgICAgICAgIGNsYXNzZXM9XCJsaW5rIG1sLTVcIlxyXG4gICAgICAgICAgICB0eXBlPVwicHJpbWFyeVwiXHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIFJlc3VtZVxyXG4gICAgICAgICAgPC9CdXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8c3ZnXHJcbiAgICAgICAgaWQ9XCJ2aXN1YWxcIlxyXG4gICAgICAgIHZpZXdCb3g9XCIwIDAgOTAwIDYwMFwiXHJcbiAgICAgICAgd2lkdGg9XCI5MDBcIlxyXG4gICAgICAgIGhlaWdodD1cIjYwMFwiXHJcbiAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXHJcbiAgICAgICAgdmVyc2lvbj1cIjEuMVwiXHJcbiAgICAgICAgY2xhc3NOYW1lPVwic2VxIGFic29sdXRlIHBpYyAtei0xIHctMS8yIGgtZnVsbFwiXHJcbiAgICAgID5cclxuICAgICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNDU2LjI2ODc1ODk5NTc2MTg2IDMyNS40MTUxMDIxOTU4NDI4NSlcIj5cclxuICAgICAgICAgIDxwYXRoXHJcbiAgICAgICAgICAgIGQ9XCJNOTggLTExMy4yQzEyNS40IC03MC43IDE0NC43IC0zNS40IDE1OS45IDE1LjJDMTc1LjEgNjUuOCAxODYuMiAxMzEuNSAxNTguOSAxNTkuOUMxMzEuNSAxODguMiA2NS44IDE3OS4xIDQuOCAxNzQuM0MtNTYuMSAxNjkuNCAtMTEyLjIgMTY4LjkgLTE0MSAxNDAuNUMtMTY5LjkgMTEyLjIgLTE3MS40IDU2LjEgLTE3OC43IC03LjNDLTE4NiAtNzAuNyAtMTk5LjEgLTE0MS40IC0xNzAuMyAtMTgzLjlDLTE0MS40IC0yMjYuNCAtNzAuNyAtMjQwLjcgLTE3LjcgLTIyM0MzNS40IC0yMDUuNCA3MC43IC0xNTUuNyA5OCAtMTEzLjJcIlxyXG4gICAgICAgICAgICBmaWxsPVwiI2ZmMFwiXHJcbiAgICAgICAgICA+PC9wYXRoPlxyXG4gICAgICAgIDwvZz5cclxuXHJcbiAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDQzOC45MjE4NzMyMzY1NzY5NyAyOTQuNDkxMzUzNzUzNzU3NilcIj5cclxuICAgICAgICAgIDxwYXRoXHJcbiAgICAgICAgICAgIGQ9XCJNMTQ2LjQgLTE0MC40QzE4My45IC0xMDguOSAyMDQuNCAtNTQuNCAxOTkuNSAtNC45QzE5NC41IDQ0LjUgMTY0LjEgODkuMSAxMjYuNiAxMTcuNkM4OS4xIDE0Ni4xIDQ0LjUgMTU4LjUgLTEzLjEgMTcxLjZDLTcwLjcgMTg0LjcgLTE0MS40IDE5OC40IC0xNjYuNCAxNjkuOUMtMTkxLjQgMTQxLjQgLTE3MC43IDcwLjcgLTE1NS40IDE1LjNDLTE0MC4xIC00MC4xIC0xMzAuMSAtODAuMSAtMTA1LjEgLTExMS42Qy04MC4xIC0xNDMuMSAtNDAuMSAtMTY2LjEgNy4yIC0xNzMuM0M1NC40IC0xODAuNCAxMDguOSAtMTcxLjkgMTQ2LjQgLTE0MC40XCJcclxuICAgICAgICAgICAgZmlsbD1cIiNmZjBcIlxyXG4gICAgICAgICAgPjwvcGF0aD5cclxuICAgICAgICA8L2c+XHJcbiAgICAgIDwvc3ZnPlxyXG4gICAgPC9zZWN0aW9uPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZXJvO1xyXG5cclxuPGRpdiBjbGFzc05hbWU9XCJzZXEgYWJzb2x1dGUgcGljIC16LTEgdy0xLzIgaC1mdWxsXCI+XHJcbiAgPEltYWdlIHNyYz1cIi9wZXJzb24ucG5nXCIgbGF5b3V0PVwiZmlsbFwiIC8+XHJcbjwvZGl2PjtcclxuIl0sIm5hbWVzIjpbIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsIl9pbmhlcml0cyIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2dldFByb3RvdHlwZU9mIiwiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsIkltYWdlIiwiVHlwZWQiLCJnc2FwIiwiTGluZWFyIiwiTUVOVUxJTktTIiwiVFlQRURfU1RSSU5HUyIsInN0eWxlcyIsIkJ1dHRvbiIsIlByb2ZpbGVzIiwidXNlRG93bmxvYWRlciIsIk1vcnBoUmVwbGFjZSIsIl9qc3hGaWxlTmFtZSIsIl90aGlzIiwiX19qc3giLCJjcmVhdGVFbGVtZW50IiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsInJlc3VsdCIsIk5ld1RhcmdldCIsImNvbnN0cnVjdG9yIiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFyZ3VtZW50cyIsImFwcGx5Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInByb3RvdHlwZSIsInZhbHVlT2YiLCJjYWxsIiwiZSIsIkJsb2IxIiwiX1JlYWN0JENvbXBvbmVudCIsIl9zdXBlciIsImtleSIsInZhbHVlIiwicmVuZGVyIiwid2lkdGgiLCJmaWxsIiwiaGVpZ2h0Iiwidmlld0JveCIsIl9fc2VsZiIsIl9fc291cmNlIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiY29sdW1uTnVtYmVyIiwiZCIsIkNvbXBvbmVudCIsIkJsb2IyIiwiX1JlYWN0JENvbXBvbmVudDIiLCJfc3VwZXIyIiwiSGVybyIsInR5cGVkRWwiLCJ0YXJnZXRTZWN0aW9uIiwib3B0aW9ucyIsInN0cmluZ3MiLCJ0eXBlU3BlZWQiLCJzdGFydERlbGF5IiwiYmFja1NwZWVkIiwiYmFja0RlbGF5IiwibG9vcCIsInR5cGVkIiwiY3VycmVudCIsInJldmVhbFRsIiwidGltZWxpbmUiLCJkZWZhdWx0cyIsImVhc2UiLCJlYXNlTm9uZSIsInRvIiwib3BhY2l0eSIsImR1cmF0aW9uIiwiZnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzdGFnZ2VyIiwiZGVzdHJveSIsIl91c2VEb3dubG9hZGVyIiwic2l6ZSIsImVsYXBzZWQiLCJwZXJjZW50YWdlIiwiZG93bmxvYWQiLCJjYW5jZWwiLCJlcnJvciIsImlzSW5Qcm9ncmVzcyIsImZpbGVVcmwiLCJmaWxlbmFtZSIsInJlZiIsImNsYXNzTmFtZSIsImlkIiwic3R5bGUiLCJjb25jYXQiLCJpbnRybyIsImhyZWYiLCJjbGFzc2VzIiwidHlwZSIsIm9uQ2xpY2siLCJ4bWxucyIsInZlcnNpb24iLCJ0cmFuc2Zvcm0iLCJzcmMiLCJsYXlvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Hero/Hero.js\n");

/***/ }),

/***/ "./node_modules/react-render-to-json/lib/renderToJson.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-render-to-json/lib/renderToJson.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports[\"default\"] = renderToJson;\n/* eslint new-cap:0 */\nfunction renderToJson(element) {\n    var res = {};\n    if (!element || !element.type) {\n        return element;\n    }\n    var Component = element.type;\n    res.name = element.type;\n    res.attributes = _extends({}, element.props);\n    var children = element.props ? element.props.children : null;\n    delete res.attributes.children;\n    if (typeof Component !== \"string\") {\n        res.name = Component.name;\n        var context = element.context || {};\n        if (Component.prototype && typeof Component.prototype.render === \"function\") {\n            // ReactComponent\n            children = new Component(element.props, context).render();\n        } else {\n            // function component\n            children = Component(element.props, context);\n        }\n    }\n    if (Array.isArray(children)) {\n        res.children = children.map(function (child) {\n            return renderToJson(child);\n        });\n        return res;\n    }\n    res.children = children ? [renderToJson(children)] : [];\n    return res;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVuZGVyLXRvLWpzb24vbGliL3JlbmRlclRvSnNvbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYsb0RBQW9ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUM7O0FBRWhQLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbmRlci10by1qc29uL2xpYi9yZW5kZXJUb0pzb24uanM/MDU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSByZW5kZXJUb0pzb247XG4vKiBlc2xpbnQgbmV3LWNhcDowICovXG5mdW5jdGlvbiByZW5kZXJUb0pzb24oZWxlbWVudCkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQudHlwZSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgdmFyIENvbXBvbmVudCA9IGVsZW1lbnQudHlwZTtcbiAgICByZXMubmFtZSA9IGVsZW1lbnQudHlwZTtcbiAgICByZXMuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBlbGVtZW50LnByb3BzKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbGVtZW50LnByb3BzID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgZGVsZXRlIHJlcy5hdHRyaWJ1dGVzLmNoaWxkcmVuO1xuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJlcy5uYW1lID0gQ29tcG9uZW50Lm5hbWU7XG4gICAgICAgIHZhciBjb250ZXh0ID0gZWxlbWVudC5jb250ZXh0IHx8IHt9O1xuICAgICAgICBpZiAoQ29tcG9uZW50LnByb3RvdHlwZSAmJiB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8gUmVhY3RDb21wb25lbnRcbiAgICAgICAgICAgIGNoaWxkcmVuID0gbmV3IENvbXBvbmVudChlbGVtZW50LnByb3BzLCBjb250ZXh0KS5yZW5kZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBDb21wb25lbnQoZWxlbWVudC5wcm9wcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIHJlcy5jaGlsZHJlbiA9IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJUb0pzb24oY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmVzLmNoaWxkcmVuID0gY2hpbGRyZW4gPyBbcmVuZGVyVG9Kc29uKGNoaWxkcmVuKV0gOiBbXTtcbiAgICByZXR1cm4gcmVzO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-render-to-json/lib/renderToJson.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/MorphReplace.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/MorphReplace.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// request animation frame\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _MorphTransition = __webpack_require__(/*! ./MorphTransition */ \"./node_modules/react-svg-morph/lib/MorphTransition.js\");\n\nvar _MorphTransition2 = _interopRequireDefault(_MorphTransition);\n\nvar MorphReplace = (function (_React$Component) {\n    _inherits(MorphReplace, _React$Component);\n\n    function MorphReplace(props) {\n        _classCallCheck(this, MorphReplace);\n\n        _get(Object.getPrototypeOf(MorphReplace.prototype), 'constructor', this).call(this, props);\n\n        this.progress = 0;\n        this.state = {\n            current: [],\n            viewBox: props.viewBox || [0, 0, props.width, props.height].join(' ')\n        };\n        this.transitionElement = _MorphTransition2['default'];\n    }\n\n    _createClass(MorphReplace, [{\n        key: 'componentWillMount',\n        value: function componentWillMount() {\n            this.setState({ from: this.props.children, to: this.props.children });\n        }\n    }, {\n        key: 'componentWillReceiveProps',\n        value: function componentWillReceiveProps(nextProps) {\n            this.setState({ from: this.props.children, to: nextProps.children, progress: 0 });\n            this.progress = 0;\n            cancelAnimationFrame(this.raf);\n            this.startTime = undefined;\n            this.animate();\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            cancelAnimationFrame(this.raf);\n            // TODO\n            // not sure should we call componentWillUnomunt on childrens\n        }\n    }, {\n        key: 'animate',\n        value: function animate() {\n            var _this = this;\n\n            this.raf = requestAnimationFrame(function (timePassed) {\n                if (!_this.startTime) {\n                    _this.startTime = timePassed;\n                }\n                var progress = Math.min((timePassed - _this.startTime) / _this.props.duration, 1);\n                progress = Math.round(progress * 100);\n                _this.setState({ progress: progress });\n                if (progress >= 100) {\n                    return false;\n                }\n                _this.animate();\n            });\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            return _react2['default'].createElement(this.transitionElement, _extends({}, this.props, {\n                progress: this.state.progress\n            }), {\n                from: _react2['default'].cloneElement(this.state.from),\n                to: _react2['default'].cloneElement(this.state.to)\n            });\n        }\n    }]);\n\n    return MorphReplace;\n})(_react2['default'].Component);\n\nexports[\"default\"] = MorphReplace;\n\nMorphReplace.propTypes = {\n    rotation: _propTypes2['default'].oneOf(['clockwise', 'counterclock', 'none']),\n    width: _propTypes2['default'].number,\n    height: _propTypes2['default'].number,\n    duration: _propTypes2['default'].number,\n    children: _propTypes2['default'].element,\n    viewBox: _propTypes2['default'].string,\n    preserveAspectRatio: function preserveAspectRatio(props, propName, componentName) {\n        var regexp = /^(\\s+)?(none|xMinYMin|xMidYMin|xMaxYMin|xMinYMid|xMidYMid|xMaxYMid|xMinYMax|xMidYMax|xMaxYMax)(\\s+)?(meet|slice)?(\\s+)?$/;\n        if (!regexp.test(props[propName])) {\n            return new Error('Validation failed. Invalid prop \\'' + propName + '\\' supplied to \\'' + componentName + '\\'.');\n        }\n    }\n};\n\nMorphReplace.defaultProps = {\n    width: 40,\n    height: 40,\n    duration: 350,\n    rotation: 'clockwise',\n    preserveAspectRatio: 'xMidYMid meet'\n};\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi9Nb3JwaFJlcGxhY2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLG9EQUFvRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsaUNBQWlDOztBQUVoUCxrQ0FBa0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFbGpCLHdDQUF3QyxtQkFBbUIsNEJBQTRCLGlEQUFpRCxnQkFBZ0Isa0RBQWtELDhEQUE4RCwwQkFBMEIsNENBQTRDLHVCQUF1QixvQkFBb0IsT0FBTyxhQUFhLGdCQUFnQixnQkFBZ0IsZUFBZSwyQkFBMkIsd0JBQXdCLDRCQUE0QixxQkFBcUIsT0FBTyx1QkFBdUIsNEJBQTRCLG9CQUFvQjs7QUFFOW1CLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDJDQUEyQywrREFBK0QsdUdBQXVHLHlFQUF5RSxlQUFlLDBFQUEwRSxHQUFHOztBQUV0WCxhQUFhLG1CQUFPLENBQUMsNENBQU87O0FBRTVCOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHNEQUFZOztBQUVyQzs7QUFFQSx1QkFBdUIsbUJBQU8sQ0FBQyxnRkFBbUI7O0FBRWxEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQW9EO0FBQ2hGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQWdFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVELGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zdmctbW9ycGgvbGliL01vcnBoUmVwbGFjZS5qcz9iNjliIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX01vcnBoVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vTW9ycGhUcmFuc2l0aW9uJyk7XG5cbnZhciBfTW9ycGhUcmFuc2l0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vcnBoVHJhbnNpdGlvbik7XG5cbnZhciBNb3JwaFJlcGxhY2UgPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoTW9ycGhSZXBsYWNlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIE1vcnBoUmVwbGFjZShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9ycGhSZXBsYWNlKTtcblxuICAgICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihNb3JwaFJlcGxhY2UucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjdXJyZW50OiBbXSxcbiAgICAgICAgICAgIHZpZXdCb3g6IHByb3BzLnZpZXdCb3ggfHwgWzAsIDAsIHByb3BzLndpZHRoLCBwcm9wcy5oZWlnaHRdLmpvaW4oJyAnKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25FbGVtZW50ID0gX01vcnBoVHJhbnNpdGlvbjJbJ2RlZmF1bHQnXTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTW9ycGhSZXBsYWNlLCBbe1xuICAgICAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZyb206IHRoaXMucHJvcHMuY2hpbGRyZW4sIHRvOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZnJvbTogdGhpcy5wcm9wcy5jaGlsZHJlbiwgdG86IG5leHRQcm9wcy5jaGlsZHJlbiwgcHJvZ3Jlc3M6IDAgfSk7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWYpO1xuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8gbm90IHN1cmUgc2hvdWxkIHdlIGNhbGwgY29tcG9uZW50V2lsbFVub211bnQgb24gY2hpbGRyZW5zXG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FuaW1hdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMucmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0aW1lUGFzc2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5zdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRUaW1lID0gdGltZVBhc3NlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4oKHRpbWVQYXNzZWQgLSBfdGhpcy5zdGFydFRpbWUpIC8gX3RoaXMucHJvcHMuZHVyYXRpb24sIDEpO1xuICAgICAgICAgICAgICAgIHByb2dyZXNzID0gTWF0aC5yb3VuZChwcm9ncmVzcyAqIDEwMCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwcm9ncmVzczogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzID49IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KHRoaXMudHJhbnNpdGlvbkVsZW1lbnQsIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHRoaXMuc3RhdGUucHJvZ3Jlc3NcbiAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgZnJvbTogX3JlYWN0MlsnZGVmYXVsdCddLmNsb25lRWxlbWVudCh0aGlzLnN0YXRlLmZyb20pLFxuICAgICAgICAgICAgICAgIHRvOiBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KHRoaXMuc3RhdGUudG8pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNb3JwaFJlcGxhY2U7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTW9ycGhSZXBsYWNlO1xuXG5Nb3JwaFJlcGxhY2UucHJvcFR5cGVzID0ge1xuICAgIHJvdGF0aW9uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mKFsnY2xvY2t3aXNlJywgJ2NvdW50ZXJjbG9jaycsICdub25lJ10pLFxuICAgIHdpZHRoOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcbiAgICBoZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuICAgIGR1cmF0aW9uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcbiAgICBjaGlsZHJlbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5lbGVtZW50LFxuICAgIHZpZXdCb3g6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGZ1bmN0aW9uIHByZXNlcnZlQXNwZWN0UmF0aW8ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIHZhciByZWdleHAgPSAvXihcXHMrKT8obm9uZXx4TWluWU1pbnx4TWlkWU1pbnx4TWF4WU1pbnx4TWluWU1pZHx4TWlkWU1pZHx4TWF4WU1pZHx4TWluWU1heHx4TWlkWU1heHx4TWF4WU1heCkoXFxzKyk/KG1lZXR8c2xpY2UpPyhcXHMrKT8kLztcbiAgICAgICAgaWYgKCFyZWdleHAudGVzdChwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdWYWxpZGF0aW9uIGZhaWxlZC4gSW52YWxpZCBwcm9wIFxcJycgKyBwcm9wTmFtZSArICdcXCcgc3VwcGxpZWQgdG8gXFwnJyArIGNvbXBvbmVudE5hbWUgKyAnXFwnLicpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTW9ycGhSZXBsYWNlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICB3aWR0aDogNDAsXG4gICAgaGVpZ2h0OiA0MCxcbiAgICBkdXJhdGlvbjogMzUwLFxuICAgIHJvdGF0aW9uOiAnY2xvY2t3aXNlJyxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pZFlNaWQgbWVldCdcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/MorphReplace.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/MorphReplaceResize.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/MorphReplaceResize.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _MorphReplace2 = __webpack_require__(/*! ./MorphReplace */ \"./node_modules/react-svg-morph/lib/MorphReplace.js\");\n\nvar _MorphReplace3 = _interopRequireDefault(_MorphReplace2);\n\nvar _MorphTransitionResize = __webpack_require__(/*! ./MorphTransitionResize */ \"./node_modules/react-svg-morph/lib/MorphTransitionResize.js\");\n\nvar _MorphTransitionResize2 = _interopRequireDefault(_MorphTransitionResize);\n\nvar MorphReplaceResize = (function (_MorphReplace) {\n    _inherits(MorphReplaceResize, _MorphReplace);\n\n    function MorphReplaceResize(props) {\n        _classCallCheck(this, MorphReplaceResize);\n\n        _get(Object.getPrototypeOf(MorphReplaceResize.prototype), 'constructor', this).call(this, props);\n        this.transitionElement = _MorphTransitionResize2['default'];\n    }\n\n    return MorphReplaceResize;\n})(_MorphReplace3['default']);\n\nexports[\"default\"] = MorphReplaceResize;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi9Nb3JwaFJlcGxhY2VSZXNpemUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLHdDQUF3QyxtQkFBbUIsNEJBQTRCLGlEQUFpRCxnQkFBZ0Isa0RBQWtELDhEQUE4RCwwQkFBMEIsNENBQTRDLHVCQUF1QixvQkFBb0IsT0FBTyxhQUFhLGdCQUFnQixnQkFBZ0IsZUFBZSwyQkFBMkIsd0JBQXdCLDRCQUE0QixxQkFBcUIsT0FBTyx1QkFBdUIsNEJBQTRCLG9CQUFvQjs7QUFFOW1CLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDJDQUEyQywrREFBK0QsdUdBQXVHLHlFQUF5RSxlQUFlLDBFQUEwRSxHQUFHOztBQUV0WCxxQkFBcUIsbUJBQU8sQ0FBQywwRUFBZ0I7O0FBRTdDOztBQUVBLDZCQUE2QixtQkFBTyxDQUFDLDRGQUF5Qjs7QUFFOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zdmctbW9ycGgvbGliL01vcnBoUmVwbGFjZVJlc2l6ZS5qcz9iZTI3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX01vcnBoUmVwbGFjZTIgPSByZXF1aXJlKCcuL01vcnBoUmVwbGFjZScpO1xuXG52YXIgX01vcnBoUmVwbGFjZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb3JwaFJlcGxhY2UyKTtcblxudmFyIF9Nb3JwaFRyYW5zaXRpb25SZXNpemUgPSByZXF1aXJlKCcuL01vcnBoVHJhbnNpdGlvblJlc2l6ZScpO1xuXG52YXIgX01vcnBoVHJhbnNpdGlvblJlc2l6ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Nb3JwaFRyYW5zaXRpb25SZXNpemUpO1xuXG52YXIgTW9ycGhSZXBsYWNlUmVzaXplID0gKGZ1bmN0aW9uIChfTW9ycGhSZXBsYWNlKSB7XG4gICAgX2luaGVyaXRzKE1vcnBoUmVwbGFjZVJlc2l6ZSwgX01vcnBoUmVwbGFjZSk7XG5cbiAgICBmdW5jdGlvbiBNb3JwaFJlcGxhY2VSZXNpemUocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vcnBoUmVwbGFjZVJlc2l6ZSk7XG5cbiAgICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTW9ycGhSZXBsYWNlUmVzaXplLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25FbGVtZW50ID0gX01vcnBoVHJhbnNpdGlvblJlc2l6ZTJbJ2RlZmF1bHQnXTtcbiAgICB9XG5cbiAgICByZXR1cm4gTW9ycGhSZXBsYWNlUmVzaXplO1xufSkoX01vcnBoUmVwbGFjZTNbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE1vcnBoUmVwbGFjZVJlc2l6ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/MorphReplaceResize.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/MorphTransition.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/MorphTransition.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _utilsNormalizeSvg = __webpack_require__(/*! ./utils/normalizeSvg */ \"./node_modules/react-svg-morph/lib/utils/normalizeSvg.js\");\n\nvar _utilsNormalizeSvg2 = _interopRequireDefault(_utilsNormalizeSvg);\n\nvar _utilsMorph = __webpack_require__(/*! ./utils/morph */ \"./node_modules/react-svg-morph/lib/utils/morph.js\");\n\nvar _reactRenderToJson = __webpack_require__(/*! react-render-to-json */ \"./node_modules/react-render-to-json/lib/renderToJson.js\");\n\nvar _reactRenderToJson2 = _interopRequireDefault(_reactRenderToJson);\n\nvar MorphTransition = (function (_React$Component) {\n    _inherits(MorphTransition, _React$Component);\n\n    function MorphTransition(props) {\n        _classCallCheck(this, MorphTransition);\n\n        _get(Object.getPrototypeOf(MorphTransition.prototype), 'constructor', this).call(this, props);\n\n        this.progress = 0;\n        this.state = {\n            current: [],\n            viewBox: props.viewBox || [0, 0, props.width, props.height].join(' ')\n        };\n        this.svgCache = {};\n        this.reset = true;\n    }\n\n    _createClass(MorphTransition, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            this.update(1);\n        }\n    }, {\n        key: 'componentWillReceiveProps',\n        value: function componentWillReceiveProps(nextProps) {\n            this.update(nextProps.progress / 100);\n        }\n    }, {\n        key: 'update',\n        value: function update(progress) {\n            this.setChildren();\n            this.normalize();\n            var current = (0, _utilsMorph.getProgress)(this.from, this.to, progress);\n            this.setState({ current: current });\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var _props = this.props;\n            var rotation = _props.rotation;\n            var duration = _props.duration;\n            var progress = _props.progress;\n            var easing = _props.easing;\n            var viewBox = _props.viewBox;\n\n            var otherProps = _objectWithoutProperties(_props, ['rotation', 'duration', 'progress', 'easing', 'viewBox']);\n\n            return _react2['default'].createElement(\n                'svg',\n                _extends({ viewBox: this.viewBox }, otherProps),\n                this.state.current.map(function (item, index) {\n                    return _react2['default'].createElement('path', _extends({ d: item.path, key: index }, item.attrs, { style: item.style, transform: item.transStr }));\n                })\n            );\n        }\n    }, {\n        key: 'normalize',\n        value: function normalize() {\n            if (!this.reset) {\n                return;\n            }\n            this.reset = false;\n            var paths = (0, _utilsMorph.normalizePaths)(this.fromSvg.paths, this.toSvg.paths, { rotation: this.props.rotation });\n            this.from = paths.from;\n            this.to = paths.to;\n        }\n    }, {\n        key: 'setChild',\n        value: function setChild(type, child) {\n            var key = child.key;\n            // it's not changed\n            if (this[type + 'Child'] && key === this[type + 'Child'].key) {\n                return false;\n            }\n            this.reset = true;\n            this[type + 'Child'] = child;\n            this[type + 'Svg'] = this.getSvgInfo(child);\n        }\n    }, {\n        key: 'setChildren',\n        value: function setChildren() {\n            if (!this.props.children.from || !this.props.children.to) {\n                throw new Error(\"Please provide `from` and `to` React elements\");\n            }\n\n            this.setChild('from', this.props.children.from);\n            this.setChild('to', this.props.children.to);\n        }\n    }, {\n        key: 'getSvgInfo',\n        value: function getSvgInfo(child) {\n            var key = child.key;\n            if (this.svgCache[key]) {\n                return this.svgCache[key];\n            }\n            var json = (0, _reactRenderToJson2['default'])(child);\n            var svg = (0, _utilsNormalizeSvg2['default'])(json);\n            if (svg.viewBox) {\n                this.viewBox = svg.viewBox;\n            }\n            this.svgCache[key] = svg;\n            return svg;\n        }\n    }]);\n\n    return MorphTransition;\n})(_react2['default'].Component);\n\nexports[\"default\"] = MorphTransition;\n\nMorphTransition.propTypes = {\n    rotation: _propTypes2['default'].oneOf(['clockwise', 'counterclock', 'none']),\n    width: _propTypes2['default'].number,\n    height: _propTypes2['default'].number,\n    duration: _propTypes2['default'].number,\n    progress: _propTypes2['default'].number,\n    children: _propTypes2['default'].object,\n    viewBox: _propTypes2['default'].string,\n    preserveAspectRatio: function preserveAspectRatio(props, propName, componentName) {\n        var regexp = /^(\\s+)?(none|xMinYMin|xMidYMin|xMaxYMin|xMinYMid|xMidYMid|xMaxYMid|xMinYMax|xMidYMax|xMaxYMax)(\\s+)?(meet|slice)?(\\s+)?$/;\n        if (!regexp.test(props[propName])) {\n            return new Error('Validation failed. Invalid prop \\'' + propName + '\\' supplied to \\'' + componentName + '\\'.');\n        }\n    }\n};\n\nMorphTransition.defaultProps = {\n    width: 40,\n    height: 40,\n    duration: 350,\n    rotation: 'clockwise',\n    progress: 0,\n    preserveAspectRatio: 'xMidYMid meet',\n    easing: function easing(t) {\n        return t;\n    }\n};\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi9Nb3JwaFRyYW5zaXRpb24uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLG9EQUFvRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsaUNBQWlDOztBQUVoUCxrQ0FBa0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFbGpCLHdDQUF3QyxtQkFBbUIsNEJBQTRCLGlEQUFpRCxnQkFBZ0Isa0RBQWtELDhEQUE4RCwwQkFBMEIsNENBQTRDLHVCQUF1QixvQkFBb0IsT0FBTyxhQUFhLGdCQUFnQixnQkFBZ0IsZUFBZSwyQkFBMkIsd0JBQXdCLDRCQUE0QixxQkFBcUIsT0FBTyx1QkFBdUIsNEJBQTRCLG9CQUFvQjs7QUFFOW1CLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLCtDQUErQyxpQkFBaUIscUJBQXFCLG9DQUFvQyw2REFBNkQsc0JBQXNCOztBQUU1TSxrREFBa0QsMENBQTBDOztBQUU1RiwyQ0FBMkMsK0RBQStELHVHQUF1Ryx5RUFBeUUsZUFBZSwwRUFBMEUsR0FBRzs7QUFFdFgsYUFBYSxtQkFBTyxDQUFDLDRDQUFPOztBQUU1Qjs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxzREFBWTs7QUFFckM7O0FBRUEseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXNCOztBQUV2RDs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBZTs7QUFFekMseUJBQXlCLG1CQUFPLENBQUMscUZBQXNCOztBQUV2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQSwrRUFBK0UsMEJBQTBCLGdCQUFnQiw2Q0FBNkM7QUFDdEssaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLCtCQUErQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zdmctbW9ycGgvbGliL01vcnBoVHJhbnNpdGlvbi5qcz9kOTdjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBfdXRpbHNOb3JtYWxpemVTdmcgPSByZXF1aXJlKCcuL3V0aWxzL25vcm1hbGl6ZVN2ZycpO1xuXG52YXIgX3V0aWxzTm9ybWFsaXplU3ZnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTm9ybWFsaXplU3ZnKTtcblxudmFyIF91dGlsc01vcnBoID0gcmVxdWlyZSgnLi91dGlscy9tb3JwaCcpO1xuXG52YXIgX3JlYWN0UmVuZGVyVG9Kc29uID0gcmVxdWlyZSgncmVhY3QtcmVuZGVyLXRvLWpzb24nKTtcblxudmFyIF9yZWFjdFJlbmRlclRvSnNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdFJlbmRlclRvSnNvbik7XG5cbnZhciBNb3JwaFRyYW5zaXRpb24gPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoTW9ycGhUcmFuc2l0aW9uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIE1vcnBoVHJhbnNpdGlvbihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9ycGhUcmFuc2l0aW9uKTtcblxuICAgICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihNb3JwaFRyYW5zaXRpb24ucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjdXJyZW50OiBbXSxcbiAgICAgICAgICAgIHZpZXdCb3g6IHByb3BzLnZpZXdCb3ggfHwgWzAsIDAsIHByb3BzLndpZHRoLCBwcm9wcy5oZWlnaHRdLmpvaW4oJyAnKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN2Z0NhY2hlID0ge307XG4gICAgICAgIHRoaXMucmVzZXQgPSB0cnVlO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhNb3JwaFRyYW5zaXRpb24sIFt7XG4gICAgICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoMSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKG5leHRQcm9wcy5wcm9ncmVzcyAvIDEwMCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3VwZGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9ICgwLCBfdXRpbHNNb3JwaC5nZXRQcm9ncmVzcykodGhpcy5mcm9tLCB0aGlzLnRvLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgY3VycmVudDogY3VycmVudCB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gX3Byb3BzLnJvdGF0aW9uO1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gX3Byb3BzLmR1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gX3Byb3BzLnByb2dyZXNzO1xuICAgICAgICAgICAgdmFyIGVhc2luZyA9IF9wcm9wcy5lYXNpbmc7XG4gICAgICAgICAgICB2YXIgdmlld0JveCA9IF9wcm9wcy52aWV3Qm94O1xuXG4gICAgICAgICAgICB2YXIgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsncm90YXRpb24nLCAnZHVyYXRpb24nLCAncHJvZ3Jlc3MnLCAnZWFzaW5nJywgJ3ZpZXdCb3gnXSk7XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnc3ZnJyxcbiAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7IHZpZXdCb3g6IHRoaXMudmlld0JveCB9LCBvdGhlclByb3BzKSxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnQubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7IGQ6IGl0ZW0ucGF0aCwga2V5OiBpbmRleCB9LCBpdGVtLmF0dHJzLCB7IHN0eWxlOiBpdGVtLnN0eWxlLCB0cmFuc2Zvcm06IGl0ZW0udHJhbnNTdHIgfSkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdub3JtYWxpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gKDAsIF91dGlsc01vcnBoLm5vcm1hbGl6ZVBhdGhzKSh0aGlzLmZyb21TdmcucGF0aHMsIHRoaXMudG9TdmcucGF0aHMsIHsgcm90YXRpb246IHRoaXMucHJvcHMucm90YXRpb24gfSk7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSBwYXRocy5mcm9tO1xuICAgICAgICAgICAgdGhpcy50byA9IHBhdGhzLnRvO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRDaGlsZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGlsZCh0eXBlLCBjaGlsZCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgIC8vIGl0J3Mgbm90IGNoYW5nZWRcbiAgICAgICAgICAgIGlmICh0aGlzW3R5cGUgKyAnQ2hpbGQnXSAmJiBrZXkgPT09IHRoaXNbdHlwZSArICdDaGlsZCddLmtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpc1t0eXBlICsgJ0NoaWxkJ10gPSBjaGlsZDtcbiAgICAgICAgICAgIHRoaXNbdHlwZSArICdTdmcnXSA9IHRoaXMuZ2V0U3ZnSW5mbyhjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldENoaWxkcmVuJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldENoaWxkcmVuKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BzLmNoaWxkcmVuLmZyb20gfHwgIXRoaXMucHJvcHMuY2hpbGRyZW4udG8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBgZnJvbWAgYW5kIGB0b2AgUmVhY3QgZWxlbWVudHNcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Q2hpbGQoJ2Zyb20nLCB0aGlzLnByb3BzLmNoaWxkcmVuLmZyb20pO1xuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZCgndG8nLCB0aGlzLnByb3BzLmNoaWxkcmVuLnRvKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0U3ZnSW5mbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdmdJbmZvKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ZnQ2FjaGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN2Z0NhY2hlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIganNvbiA9ICgwLCBfcmVhY3RSZW5kZXJUb0pzb24yWydkZWZhdWx0J10pKGNoaWxkKTtcbiAgICAgICAgICAgIHZhciBzdmcgPSAoMCwgX3V0aWxzTm9ybWFsaXplU3ZnMlsnZGVmYXVsdCddKShqc29uKTtcbiAgICAgICAgICAgIGlmIChzdmcudmlld0JveCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld0JveCA9IHN2Zy52aWV3Qm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdmdDYWNoZVtrZXldID0gc3ZnO1xuICAgICAgICAgICAgcmV0dXJuIHN2ZztcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNb3JwaFRyYW5zaXRpb247XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTW9ycGhUcmFuc2l0aW9uO1xuXG5Nb3JwaFRyYW5zaXRpb24ucHJvcFR5cGVzID0ge1xuICAgIHJvdGF0aW9uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mKFsnY2xvY2t3aXNlJywgJ2NvdW50ZXJjbG9jaycsICdub25lJ10pLFxuICAgIHdpZHRoOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcbiAgICBoZWlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuICAgIGR1cmF0aW9uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcbiAgICBwcm9ncmVzczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsXG4gICAgY2hpbGRyZW46IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LFxuICAgIHZpZXdCb3g6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGZ1bmN0aW9uIHByZXNlcnZlQXNwZWN0UmF0aW8ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIHZhciByZWdleHAgPSAvXihcXHMrKT8obm9uZXx4TWluWU1pbnx4TWlkWU1pbnx4TWF4WU1pbnx4TWluWU1pZHx4TWlkWU1pZHx4TWF4WU1pZHx4TWluWU1heHx4TWlkWU1heHx4TWF4WU1heCkoXFxzKyk/KG1lZXR8c2xpY2UpPyhcXHMrKT8kLztcbiAgICAgICAgaWYgKCFyZWdleHAudGVzdChwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdWYWxpZGF0aW9uIGZhaWxlZC4gSW52YWxpZCBwcm9wIFxcJycgKyBwcm9wTmFtZSArICdcXCcgc3VwcGxpZWQgdG8gXFwnJyArIGNvbXBvbmVudE5hbWUgKyAnXFwnLicpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTW9ycGhUcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgICB3aWR0aDogNDAsXG4gICAgaGVpZ2h0OiA0MCxcbiAgICBkdXJhdGlvbjogMzUwLFxuICAgIHJvdGF0aW9uOiAnY2xvY2t3aXNlJyxcbiAgICBwcm9ncmVzczogMCxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pZFlNaWQgbWVldCcsXG4gICAgZWFzaW5nOiBmdW5jdGlvbiBlYXNpbmcodCkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/MorphTransition.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/MorphTransitionResize.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/MorphTransitionResize.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _MorphTransition2 = __webpack_require__(/*! ./MorphTransition */ \"./node_modules/react-svg-morph/lib/MorphTransition.js\");\n\nvar _MorphTransition3 = _interopRequireDefault(_MorphTransition2);\n\nvar _utilsScalePath = __webpack_require__(/*! ./utils/scalePath */ \"./node_modules/react-svg-morph/lib/utils/scalePath.js\");\n\nvar _utilsScalePath2 = _interopRequireDefault(_utilsScalePath);\n\nvar MorphTransitionResize = (function (_MorphTransition) {\n    _inherits(MorphTransitionResize, _MorphTransition);\n\n    function MorphTransitionResize(props) {\n        _classCallCheck(this, MorphTransitionResize);\n\n        _get(Object.getPrototypeOf(MorphTransitionResize.prototype), 'constructor', this).call(this, props);\n    }\n\n    _createClass(MorphTransitionResize, [{\n        key: 'getSvgInfo',\n        value: function getSvgInfo(child) {\n            var key = child.key;\n            if (this.svgCache[key]) {\n                return this.svgCache[key];\n            }\n            var svg = _get(Object.getPrototypeOf(MorphTransitionResize.prototype), 'getSvgInfo', this).call(this, child);\n            // reset viewBox\n            this.viewBox = [0, 0, this.props.width, this.props.height].join(' ');\n            var width = undefined,\n                height = undefined;\n            var base = this.props.height > this.props.width ? this.props.height : this.props.width;\n\n            var viewBox = svg.viewBox;\n            if (!viewBox) {\n                width = svg.width;\n                height = svg.height;\n            } else {\n                viewBox = viewBox.split(' ');\n                height = viewBox[3];\n                width = viewBox[2];\n            }\n            svg.paths.map(function (item) {\n                item.path = (0, _utilsScalePath2['default'])(item.path, base, width, height);\n                return item;\n            });\n            this.svgCache[key] = svg;\n            return svg;\n        }\n    }]);\n\n    return MorphTransitionResize;\n})(_MorphTransition3['default']);\n\nexports[\"default\"] = MorphTransitionResize;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi9Nb3JwaFRyYW5zaXRpb25SZXNpemUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLGtDQUFrQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVsakIsd0NBQXdDLG1CQUFtQiw0QkFBNEIsaURBQWlELGdCQUFnQixrREFBa0QsOERBQThELDBCQUEwQiw0Q0FBNEMsdUJBQXVCLG9CQUFvQixPQUFPLGFBQWEsZ0JBQWdCLGdCQUFnQixlQUFlLDJCQUEyQix3QkFBd0IsNEJBQTRCLHFCQUFxQixPQUFPLHVCQUF1Qiw0QkFBNEIsb0JBQW9COztBQUU5bUIsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsa0RBQWtELDBDQUEwQzs7QUFFNUYsMkNBQTJDLCtEQUErRCx1R0FBdUcseUVBQXlFLGVBQWUsMEVBQTBFLEdBQUc7O0FBRXRYLHdCQUF3QixtQkFBTyxDQUFDLGdGQUFtQjs7QUFFbkQ7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsZ0ZBQW1COztBQUVqRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXN2Zy1tb3JwaC9saWIvTW9ycGhUcmFuc2l0aW9uUmVzaXplLmpzPzRlN2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfTW9ycGhUcmFuc2l0aW9uMiA9IHJlcXVpcmUoJy4vTW9ycGhUcmFuc2l0aW9uJyk7XG5cbnZhciBfTW9ycGhUcmFuc2l0aW9uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vcnBoVHJhbnNpdGlvbjIpO1xuXG52YXIgX3V0aWxzU2NhbGVQYXRoID0gcmVxdWlyZSgnLi91dGlscy9zY2FsZVBhdGgnKTtcblxudmFyIF91dGlsc1NjYWxlUGF0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc1NjYWxlUGF0aCk7XG5cbnZhciBNb3JwaFRyYW5zaXRpb25SZXNpemUgPSAoZnVuY3Rpb24gKF9Nb3JwaFRyYW5zaXRpb24pIHtcbiAgICBfaW5oZXJpdHMoTW9ycGhUcmFuc2l0aW9uUmVzaXplLCBfTW9ycGhUcmFuc2l0aW9uKTtcblxuICAgIGZ1bmN0aW9uIE1vcnBoVHJhbnNpdGlvblJlc2l6ZShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9ycGhUcmFuc2l0aW9uUmVzaXplKTtcblxuICAgICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihNb3JwaFRyYW5zaXRpb25SZXNpemUucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE1vcnBoVHJhbnNpdGlvblJlc2l6ZSwgW3tcbiAgICAgICAga2V5OiAnZ2V0U3ZnSW5mbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdmdJbmZvKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ZnQ2FjaGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN2Z0NhY2hlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3ZnID0gX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTW9ycGhUcmFuc2l0aW9uUmVzaXplLnByb3RvdHlwZSksICdnZXRTdmdJbmZvJywgdGhpcykuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgICAgICAgICAvLyByZXNldCB2aWV3Qm94XG4gICAgICAgICAgICB0aGlzLnZpZXdCb3ggPSBbMCwgMCwgdGhpcy5wcm9wcy53aWR0aCwgdGhpcy5wcm9wcy5oZWlnaHRdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IHRoaXMucHJvcHMuaGVpZ2h0ID4gdGhpcy5wcm9wcy53aWR0aCA/IHRoaXMucHJvcHMuaGVpZ2h0IDogdGhpcy5wcm9wcy53aWR0aDtcblxuICAgICAgICAgICAgdmFyIHZpZXdCb3ggPSBzdmcudmlld0JveDtcbiAgICAgICAgICAgIGlmICghdmlld0JveCkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gc3ZnLndpZHRoO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHN2Zy5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpZXdCb3ggPSB2aWV3Qm94LnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdmlld0JveFszXTtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHZpZXdCb3hbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdmcucGF0aHMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5wYXRoID0gKDAsIF91dGlsc1NjYWxlUGF0aDJbJ2RlZmF1bHQnXSkoaXRlbS5wYXRoLCBiYXNlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zdmdDYWNoZVtrZXldID0gc3ZnO1xuICAgICAgICAgICAgcmV0dXJuIHN2ZztcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNb3JwaFRyYW5zaXRpb25SZXNpemU7XG59KShfTW9ycGhUcmFuc2l0aW9uM1snZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTW9ycGhUcmFuc2l0aW9uUmVzaXplO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/MorphTransitionResize.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _MorphReplace2 = __webpack_require__(/*! ./MorphReplace */ \"./node_modules/react-svg-morph/lib/MorphReplace.js\");\n\nvar _MorphReplace3 = _interopRequireDefault(_MorphReplace2);\n\nexports.MorphReplace = _MorphReplace3['default'];\n\nvar _MorphReplaceResize2 = __webpack_require__(/*! ./MorphReplaceResize */ \"./node_modules/react-svg-morph/lib/MorphReplaceResize.js\");\n\nvar _MorphReplaceResize3 = _interopRequireDefault(_MorphReplaceResize2);\n\nexports.MorphReplaceResize = _MorphReplaceResize3['default'];\n\nvar _MorphTransition2 = __webpack_require__(/*! ./MorphTransition */ \"./node_modules/react-svg-morph/lib/MorphTransition.js\");\n\nvar _MorphTransition3 = _interopRequireDefault(_MorphTransition2);\n\nexports.MorphTransition = _MorphTransition3['default'];\n\nvar _MorphTransitionResize2 = __webpack_require__(/*! ./MorphTransitionResize */ \"./node_modules/react-svg-morph/lib/MorphTransitionResize.js\");\n\nvar _MorphTransitionResize3 = _interopRequireDefault(_MorphTransitionResize2);\n\nexports.MorphTransitionResize = _MorphTransitionResize3['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYsdUNBQXVDLHVDQUF1Qzs7QUFFOUUscUJBQXFCLG1CQUFPLENBQUMsMEVBQWdCOztBQUU3Qzs7QUFFQSxvQkFBb0I7O0FBRXBCLDJCQUEyQixtQkFBTyxDQUFDLHNGQUFzQjs7QUFFekQ7O0FBRUEsMEJBQTBCOztBQUUxQix3QkFBd0IsbUJBQU8sQ0FBQyxnRkFBbUI7O0FBRW5EOztBQUVBLHVCQUF1Qjs7QUFFdkIsOEJBQThCLG1CQUFPLENBQUMsNEZBQXlCOztBQUUvRDs7QUFFQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXN2Zy1tb3JwaC9saWIvaW5kZXguanM/ZmRlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfTW9ycGhSZXBsYWNlMiA9IHJlcXVpcmUoJy4vTW9ycGhSZXBsYWNlJyk7XG5cbnZhciBfTW9ycGhSZXBsYWNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vcnBoUmVwbGFjZTIpO1xuXG5leHBvcnRzLk1vcnBoUmVwbGFjZSA9IF9Nb3JwaFJlcGxhY2UzWydkZWZhdWx0J107XG5cbnZhciBfTW9ycGhSZXBsYWNlUmVzaXplMiA9IHJlcXVpcmUoJy4vTW9ycGhSZXBsYWNlUmVzaXplJyk7XG5cbnZhciBfTW9ycGhSZXBsYWNlUmVzaXplMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vcnBoUmVwbGFjZVJlc2l6ZTIpO1xuXG5leHBvcnRzLk1vcnBoUmVwbGFjZVJlc2l6ZSA9IF9Nb3JwaFJlcGxhY2VSZXNpemUzWydkZWZhdWx0J107XG5cbnZhciBfTW9ycGhUcmFuc2l0aW9uMiA9IHJlcXVpcmUoJy4vTW9ycGhUcmFuc2l0aW9uJyk7XG5cbnZhciBfTW9ycGhUcmFuc2l0aW9uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vcnBoVHJhbnNpdGlvbjIpO1xuXG5leHBvcnRzLk1vcnBoVHJhbnNpdGlvbiA9IF9Nb3JwaFRyYW5zaXRpb24zWydkZWZhdWx0J107XG5cbnZhciBfTW9ycGhUcmFuc2l0aW9uUmVzaXplMiA9IHJlcXVpcmUoJy4vTW9ycGhUcmFuc2l0aW9uUmVzaXplJyk7XG5cbnZhciBfTW9ycGhUcmFuc2l0aW9uUmVzaXplMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vcnBoVHJhbnNpdGlvblJlc2l6ZTIpO1xuXG5leHBvcnRzLk1vcnBoVHJhbnNpdGlvblJlc2l6ZSA9IF9Nb3JwaFRyYW5zaXRpb25SZXNpemUzWydkZWZhdWx0J107Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/index.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/utils/helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/utils/helpers.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.clone = clone;\nexports.styleNormCalc = styleNormCalc;\nexports.styleNormToString = styleNormToString;\nexports.styleToNorm = styleToNorm;\nexports.transCalc = transCalc;\nexports.trans2string = trans2string;\nexports.curveCalc = curveCalc;\n\nvar _svglite = __webpack_require__(/*! ./svglite */ \"./node_modules/react-svg-morph/lib/utils/svglite.js\");\n\nfunction clone(obj) {\n    var copy, i, attr, len;\n\n    // Handle Array\n    if (obj instanceof Array) {\n        copy = [];\n        for (i = 0, len = obj.length; i < len; i++) {\n            copy[i] = clone(obj[i]);\n        }\n        return copy;\n    }\n\n    // Handle Object\n    if (obj instanceof Object) {\n        copy = {};\n        for (attr in obj) {\n            if (obj.hasOwnProperty(attr)) {\n                copy[attr] = clone(obj[attr]);\n            }\n        }\n        return copy;\n    }\n\n    return obj;\n}\n\n// Calculate style\n\nfunction styleNormCalc(styleNormFrom, styleNormTo, progress) {\n    var i,\n        styleNorm = {};\n    for (i in styleNormFrom) {\n        switch (i) {\n            case 'fill':\n            case 'stroke':\n                styleNorm[i] = clone(styleNormFrom[i]);\n                styleNorm[i].r = styleNormFrom[i].r + (styleNormTo[i].r - styleNormFrom[i].r) * progress;\n                styleNorm[i].g = styleNormFrom[i].g + (styleNormTo[i].g - styleNormFrom[i].g) * progress;\n                styleNorm[i].b = styleNormFrom[i].b + (styleNormTo[i].b - styleNormFrom[i].b) * progress;\n                styleNorm[i].opacity = styleNormFrom[i].opacity + (styleNormTo[i].opacity - styleNormFrom[i].opacity) * progress;\n                break;\n            case 'opacity':\n            case 'fill-opacity':\n            case 'stroke-opacity':\n            case 'stroke-width':\n                styleNorm[i] = styleNormFrom[i] + (styleNormTo[i] - styleNormFrom[i]) * progress;\n                break;\n        }\n    }\n    return styleNorm;\n}\n\nfunction styleNormToString(styleNorm) {\n    var i;\n    var style = {};\n    for (i in styleNorm) {\n        switch (i) {\n            case 'fill':\n            case 'stroke':\n                style[i] = (0, _svglite.rgbToString)(styleNorm[i]);\n                break;\n            case 'opacity':\n            case 'fill-opacity':\n            case 'stroke-opacity':\n            case 'stroke-width':\n                style[i] = styleNorm[i];\n                break;\n        }\n    }\n    return style;\n}\n\nfunction styleToNorm(styleFrom, styleTo) {\n    var styleNorm = [{}, {}];\n    var i;\n    for (i in styleFrom) {\n        switch (i) {\n            case 'fill':\n            case 'stroke':\n                styleNorm[0][i] = (0, _svglite.getRGB)(styleFrom[i]);\n                if (styleTo[i] === undefined) {\n                    styleNorm[1][i] = (0, _svglite.getRGB)(styleFrom[i]);\n                    styleNorm[1][i].opacity = 0;\n                }\n                break;\n            case 'opacity':\n            case 'fill-opacity':\n            case 'stroke-opacity':\n            case 'stroke-width':\n                styleNorm[0][i] = styleFrom[i];\n                if (styleTo[i] === undefined) {\n                    styleNorm[1][i] = 1;\n                }\n                break;\n        }\n    }\n    for (i in styleTo) {\n        switch (i) {\n            case 'fill':\n            case 'stroke':\n                styleNorm[1][i] = (0, _svglite.getRGB)(styleTo[i]);\n                if (styleFrom[i] === undefined) {\n                    styleNorm[0][i] = (0, _svglite.getRGB)(styleTo[i]);\n                    styleNorm[0][i].opacity = 0;\n                }\n                break;\n            case 'opacity':\n            case 'fill-opacity':\n            case 'stroke-opacity':\n            case 'stroke-width':\n                styleNorm[1][i] = styleTo[i];\n                if (styleFrom[i] === undefined) {\n                    styleNorm[0][i] = 1;\n                }\n                break;\n        }\n    }\n    return styleNorm;\n}\n\n// Calculate transform progress\n\nfunction transCalc(transFrom, transTo, progress) {\n    var res = {};\n    var i, j;\n    for (i in transFrom) {\n        switch (i) {\n            case 'rotate':\n                res[i] = [0, 0, 0];\n                for (j = 0; j < 3; j++) {\n                    res[i][j] = transFrom[i][j] + (transTo[i][j] - transFrom[i][j]) * progress;\n                }\n                break;\n        }\n    }\n    return res;\n}\n\nfunction trans2string(trans) {\n    var res = '';\n    if (!!trans.rotate) {\n        res += 'rotate(' + trans.rotate.join(' ') + ')';\n    }\n    return res;\n}\n\n// Calculate curve progress\n\nfunction curveCalc(curveFrom, curveTo, progress) {\n    var curve = [];\n    var i = 0,\n        j;\n    var len1 = curveFrom.length,\n        len2;\n    for (; i < len1; i++) {\n        curve.push([curveFrom[i][0]]);\n        for (j = 1, len2 = curveFrom[i].length; j < len2; j++) {\n            curve[i].push(curveFrom[i][j] + (curveTo[i][j] - curveFrom[i][j]) * progress);\n        }\n    }\n    return curve;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi91dGlscy9oZWxwZXJzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGFBQWE7QUFDYixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLGlCQUFpQjs7QUFFakIsZUFBZSxtQkFBTyxDQUFDLHNFQUFXOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXN2Zy1tb3JwaC9saWIvdXRpbHMvaGVscGVycy5qcz9lMTY1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuc3R5bGVOb3JtQ2FsYyA9IHN0eWxlTm9ybUNhbGM7XG5leHBvcnRzLnN0eWxlTm9ybVRvU3RyaW5nID0gc3R5bGVOb3JtVG9TdHJpbmc7XG5leHBvcnRzLnN0eWxlVG9Ob3JtID0gc3R5bGVUb05vcm07XG5leHBvcnRzLnRyYW5zQ2FsYyA9IHRyYW5zQ2FsYztcbmV4cG9ydHMudHJhbnMyc3RyaW5nID0gdHJhbnMyc3RyaW5nO1xuZXhwb3J0cy5jdXJ2ZUNhbGMgPSBjdXJ2ZUNhbGM7XG5cbnZhciBfc3ZnbGl0ZSA9IHJlcXVpcmUoJy4vc3ZnbGl0ZScpO1xuXG5mdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICB2YXIgY29weSwgaSwgYXR0ciwgbGVuO1xuXG4gICAgLy8gSGFuZGxlIEFycmF5XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvcHkgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldID0gY2xvbmUob2JqW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgT2JqZWN0XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBjb3B5ID0ge307XG4gICAgICAgIGZvciAoYXR0ciBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgICAgICBjb3B5W2F0dHJdID0gY2xvbmUob2JqW2F0dHJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG4vLyBDYWxjdWxhdGUgc3R5bGVcblxuZnVuY3Rpb24gc3R5bGVOb3JtQ2FsYyhzdHlsZU5vcm1Gcm9tLCBzdHlsZU5vcm1UbywgcHJvZ3Jlc3MpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc3R5bGVOb3JtID0ge307XG4gICAgZm9yIChpIGluIHN0eWxlTm9ybUZyb20pIHtcbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlICdmaWxsJzpcbiAgICAgICAgICAgIGNhc2UgJ3N0cm9rZSc6XG4gICAgICAgICAgICAgICAgc3R5bGVOb3JtW2ldID0gY2xvbmUoc3R5bGVOb3JtRnJvbVtpXSk7XG4gICAgICAgICAgICAgICAgc3R5bGVOb3JtW2ldLnIgPSBzdHlsZU5vcm1Gcm9tW2ldLnIgKyAoc3R5bGVOb3JtVG9baV0uciAtIHN0eWxlTm9ybUZyb21baV0ucikgKiBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICBzdHlsZU5vcm1baV0uZyA9IHN0eWxlTm9ybUZyb21baV0uZyArIChzdHlsZU5vcm1Ub1tpXS5nIC0gc3R5bGVOb3JtRnJvbVtpXS5nKSAqIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHN0eWxlTm9ybVtpXS5iID0gc3R5bGVOb3JtRnJvbVtpXS5iICsgKHN0eWxlTm9ybVRvW2ldLmIgLSBzdHlsZU5vcm1Gcm9tW2ldLmIpICogcHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgc3R5bGVOb3JtW2ldLm9wYWNpdHkgPSBzdHlsZU5vcm1Gcm9tW2ldLm9wYWNpdHkgKyAoc3R5bGVOb3JtVG9baV0ub3BhY2l0eSAtIHN0eWxlTm9ybUZyb21baV0ub3BhY2l0eSkgKiBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29wYWNpdHknOlxuICAgICAgICAgICAgY2FzZSAnZmlsbC1vcGFjaXR5JzpcbiAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS1vcGFjaXR5JzpcbiAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS13aWR0aCc6XG4gICAgICAgICAgICAgICAgc3R5bGVOb3JtW2ldID0gc3R5bGVOb3JtRnJvbVtpXSArIChzdHlsZU5vcm1Ub1tpXSAtIHN0eWxlTm9ybUZyb21baV0pICogcHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlTm9ybTtcbn1cblxuZnVuY3Rpb24gc3R5bGVOb3JtVG9TdHJpbmcoc3R5bGVOb3JtKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHN0eWxlID0ge307XG4gICAgZm9yIChpIGluIHN0eWxlTm9ybSkge1xuICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZpbGwnOlxuICAgICAgICAgICAgY2FzZSAnc3Ryb2tlJzpcbiAgICAgICAgICAgICAgICBzdHlsZVtpXSA9ICgwLCBfc3ZnbGl0ZS5yZ2JUb1N0cmluZykoc3R5bGVOb3JtW2ldKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29wYWNpdHknOlxuICAgICAgICAgICAgY2FzZSAnZmlsbC1vcGFjaXR5JzpcbiAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS1vcGFjaXR5JzpcbiAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS13aWR0aCc6XG4gICAgICAgICAgICAgICAgc3R5bGVbaV0gPSBzdHlsZU5vcm1baV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBzdHlsZVRvTm9ybShzdHlsZUZyb20sIHN0eWxlVG8pIHtcbiAgICB2YXIgc3R5bGVOb3JtID0gW3t9LCB7fV07XG4gICAgdmFyIGk7XG4gICAgZm9yIChpIGluIHN0eWxlRnJvbSkge1xuICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZpbGwnOlxuICAgICAgICAgICAgY2FzZSAnc3Ryb2tlJzpcbiAgICAgICAgICAgICAgICBzdHlsZU5vcm1bMF1baV0gPSAoMCwgX3N2Z2xpdGUuZ2V0UkdCKShzdHlsZUZyb21baV0pO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZVRvW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVOb3JtWzFdW2ldID0gKDAsIF9zdmdsaXRlLmdldFJHQikoc3R5bGVGcm9tW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVOb3JtWzFdW2ldLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29wYWNpdHknOlxuICAgICAgICAgICAgY2FzZSAnZmlsbC1vcGFjaXR5JzpcbiAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS1vcGFjaXR5JzpcbiAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS13aWR0aCc6XG4gICAgICAgICAgICAgICAgc3R5bGVOb3JtWzBdW2ldID0gc3R5bGVGcm9tW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZVRvW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVOb3JtWzFdW2ldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpIGluIHN0eWxlVG8pIHtcbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlICdmaWxsJzpcbiAgICAgICAgICAgIGNhc2UgJ3N0cm9rZSc6XG4gICAgICAgICAgICAgICAgc3R5bGVOb3JtWzFdW2ldID0gKDAsIF9zdmdsaXRlLmdldFJHQikoc3R5bGVUb1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlRnJvbVtpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlTm9ybVswXVtpXSA9ICgwLCBfc3ZnbGl0ZS5nZXRSR0IpKHN0eWxlVG9baV0pO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZU5vcm1bMF1baV0ub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb3BhY2l0eSc6XG4gICAgICAgICAgICBjYXNlICdmaWxsLW9wYWNpdHknOlxuICAgICAgICAgICAgY2FzZSAnc3Ryb2tlLW9wYWNpdHknOlxuICAgICAgICAgICAgY2FzZSAnc3Ryb2tlLXdpZHRoJzpcbiAgICAgICAgICAgICAgICBzdHlsZU5vcm1bMV1baV0gPSBzdHlsZVRvW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZUZyb21baV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZU5vcm1bMF1baV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVOb3JtO1xufVxuXG4vLyBDYWxjdWxhdGUgdHJhbnNmb3JtIHByb2dyZXNzXG5cbmZ1bmN0aW9uIHRyYW5zQ2FsYyh0cmFuc0Zyb20sIHRyYW5zVG8sIHByb2dyZXNzKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBpLCBqO1xuICAgIGZvciAoaSBpbiB0cmFuc0Zyb20pIHtcbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgICAgIHJlc1tpXSA9IFswLCAwLCAwXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tpXVtqXSA9IHRyYW5zRnJvbVtpXVtqXSArICh0cmFuc1RvW2ldW2pdIC0gdHJhbnNGcm9tW2ldW2pdKSAqIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiB0cmFuczJzdHJpbmcodHJhbnMpIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgaWYgKCEhdHJhbnMucm90YXRlKSB7XG4gICAgICAgIHJlcyArPSAncm90YXRlKCcgKyB0cmFucy5yb3RhdGUuam9pbignICcpICsgJyknO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBDYWxjdWxhdGUgY3VydmUgcHJvZ3Jlc3NcblxuZnVuY3Rpb24gY3VydmVDYWxjKGN1cnZlRnJvbSwgY3VydmVUbywgcHJvZ3Jlc3MpIHtcbiAgICB2YXIgY3VydmUgPSBbXTtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGo7XG4gICAgdmFyIGxlbjEgPSBjdXJ2ZUZyb20ubGVuZ3RoLFxuICAgICAgICBsZW4yO1xuICAgIGZvciAoOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgICAgIGN1cnZlLnB1c2goW2N1cnZlRnJvbVtpXVswXV0pO1xuICAgICAgICBmb3IgKGogPSAxLCBsZW4yID0gY3VydmVGcm9tW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgY3VydmVbaV0ucHVzaChjdXJ2ZUZyb21baV1bal0gKyAoY3VydmVUb1tpXVtqXSAtIGN1cnZlRnJvbVtpXVtqXSkgKiBwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/utils/helpers.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/utils/morph.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/utils/morph.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalizePaths = normalizePaths;\nexports.getProgress = getProgress;\n\nvar _svglite = __webpack_require__(/*! ./svglite */ \"./node_modules/react-svg-morph/lib/utils/svglite.js\");\n\nvar _helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/react-svg-morph/lib/utils/helpers.js\");\n\nfunction normalizePaths(fromPaths, toPaths, _options) {\n    var options = _options || {};\n    var max = Math.max(fromPaths.length, toPaths.length);\n    var toBB, i;\n\n    for (i = 0; i < max; i++) {\n        if (!fromPaths[i]) {\n            if (!!toPaths[i]) {\n                toBB = (0, _svglite.curvePathBBox)((0, _svglite.path2curve)(toPaths[i].path));\n                fromPaths.push({\n                    path: 'M' + toBB.cx + ',' + toBB.cy + 'l0,0',\n                    attrs: {},\n                    style: {},\n                    trans: {\n                        rotate: [0, toBB.cx, toBB.cy]\n                    }\n                });\n            } else {\n                fromPaths.push({\n                    path: 'M0,0l0,0',\n                    attrs: {},\n                    style: {},\n                    trans: {\n                        rotate: [0, 0, 0]\n                    }\n                });\n            }\n        }\n\n        if (!toPaths[i]) {\n            if (!!fromPaths[i]) {\n                toBB = (0, _svglite.curvePathBBox)((0, _svglite.path2curve)(fromPaths[i].path));\n                toPaths.push({\n                    path: 'M' + toBB.cx + ',' + toBB.cy + 'l0,0',\n                    attrs: {},\n                    style: {},\n                    trans: {\n                        rotate: [0, toBB.cx, toBB.cy]\n                    }\n                });\n            } else {\n                toPaths.push({\n                    path: 'M0,0l0,0',\n                    attrs: {},\n                    style: {},\n                    trans: {\n                        rotate: [0, 0, 0]\n                    }\n                });\n            }\n        }\n    }\n\n    for (i = 0; i < max; i++) {\n        var fromIconItem = fromPaths[i];\n        var toIconItem = toPaths[i];\n\n        // Calculate from/to curve data and set to fromIcon/toIcon\n        var curves = (0, _svglite.path2curve)(fromPaths[i].path, toPaths[i].path);\n        fromIconItem.curve = curves[0];\n        toIconItem.curve = curves[1];\n        // Normalize from/to attrs\n        var attrsNorm = (0, _helpers.styleToNorm)(fromPaths[i].attrs, toPaths[i].attrs);\n        fromIconItem.attrsNorm = attrsNorm[0];\n        toIconItem.attrsNorm = attrsNorm[1];\n        fromIconItem.attrs = (0, _helpers.styleNormToString)(fromIconItem.attrsNorm);\n        toIconItem.attrs = (0, _helpers.styleNormToString)(toIconItem.attrsNorm);\n\n        // Normalize from/to style\n        var styleNorm = (0, _helpers.styleToNorm)(fromPaths[i].style, toPaths[i].style);\n        fromIconItem.styleNorm = styleNorm[0];\n        toIconItem.styleNorm = styleNorm[1];\n        fromIconItem.style = (0, _helpers.styleNormToString)(fromIconItem.styleNorm);\n        toIconItem.style = (0, _helpers.styleNormToString)(toIconItem.styleNorm);\n\n        // Calculate from/to transform\n        toBB = (0, _svglite.curvePathBBox)(toIconItem.curve);\n        toIconItem.trans = {\n            rotate: [0, toBB.cx, toBB.cy]\n        };\n        // TODO rotation accept\n        var rotation = options.rotation,\n            degAdd = undefined;\n        if (rotation === 'random') {\n            rotation = Math.random() < 0.5 ? 'counterclock' : 'clock';\n        }\n        switch (rotation) {\n            case 'none':\n                if (!!fromIconItem.trans.rotate) {\n                    toIconItem.trans.rotate[0] = fromIconItem.trans.rotate[0];\n                }\n                break;\n            case 'counterclock':\n                if (!!fromIconItem.trans.rotate) {\n                    toIconItem.trans.rotate[0] = fromIconItem.trans.rotate[0] - 360;\n                    degAdd = -fromIconItem.trans.rotate[0] % 360;\n                    toIconItem.trans.rotate[0] += degAdd < 180 ? degAdd : degAdd - 360;\n                } else {\n                    toIconItem.trans.rotate[0] = -360;\n                }\n                break;\n            default:\n                // Clockwise\n                if (!!fromIconItem.trans.rotate) {\n                    toIconItem.trans.rotate[0] = fromIconItem.trans.rotate[0] + 360;\n                    degAdd = fromIconItem.trans.rotate[0] % 360;\n                    toIconItem.trans.rotate[0] += degAdd < 180 ? -degAdd : 360 - degAdd;\n                } else {\n                    toIconItem.trans.rotate[0] = 360;\n                }\n                break;\n        }\n    }\n\n    return {\n        to: toPaths,\n        from: fromPaths\n    };\n}\n\nfunction getProgress(fromPaths, toPaths, progress) {\n    // TODO easing\n    // progress=easings[this._easing](progress);\n    var i = 0;\n    var newPaths = [];\n    var len = fromPaths.length;\n    // Update path/attrs/transform\n    for (; i < len; i++) {\n        newPaths[i] = {};\n        newPaths[i].curve = (0, _helpers.curveCalc)(fromPaths[i].curve, toPaths[i].curve, progress);\n        newPaths[i].path = (0, _svglite.path2string)(newPaths[i].curve);\n\n        newPaths[i].attrsNorm = (0, _helpers.styleNormCalc)(fromPaths[i].attrsNorm, toPaths[i].attrsNorm, progress);\n        newPaths[i].attrs = (0, _helpers.styleNormToString)(newPaths[i].attrsNorm);\n\n        newPaths[i].styleNorm = (0, _helpers.styleNormCalc)(fromPaths[i].styleNorm, toPaths[i].styleNorm, progress);\n        newPaths[i].style = (0, _helpers.styleNormToString)(newPaths[i].styleNorm);\n\n        newPaths[i].trans = (0, _helpers.transCalc)(fromPaths[i].trans, toPaths[i].trans, progress);\n        newPaths[i].transStr = (0, _helpers.trans2string)(newPaths[i].trans);\n    }\n\n    return newPaths;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi91dGlscy9tb3JwaC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixzQkFBc0I7QUFDdEIsbUJBQW1COztBQUVuQixlQUFlLG1CQUFPLENBQUMsc0VBQVc7O0FBRWxDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zdmctbW9ycGgvbGliL3V0aWxzL21vcnBoLmpzP2NkNTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ub3JtYWxpemVQYXRocyA9IG5vcm1hbGl6ZVBhdGhzO1xuZXhwb3J0cy5nZXRQcm9ncmVzcyA9IGdldFByb2dyZXNzO1xuXG52YXIgX3N2Z2xpdGUgPSByZXF1aXJlKCcuL3N2Z2xpdGUnKTtcblxudmFyIF9oZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGhzKGZyb21QYXRocywgdG9QYXRocywgX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9O1xuICAgIHZhciBtYXggPSBNYXRoLm1heChmcm9tUGF0aHMubGVuZ3RoLCB0b1BhdGhzLmxlbmd0aCk7XG4gICAgdmFyIHRvQkIsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgaWYgKCFmcm9tUGF0aHNbaV0pIHtcbiAgICAgICAgICAgIGlmICghIXRvUGF0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICB0b0JCID0gKDAsIF9zdmdsaXRlLmN1cnZlUGF0aEJCb3gpKCgwLCBfc3ZnbGl0ZS5wYXRoMmN1cnZlKSh0b1BhdGhzW2ldLnBhdGgpKTtcbiAgICAgICAgICAgICAgICBmcm9tUGF0aHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICdNJyArIHRvQkIuY3ggKyAnLCcgKyB0b0JCLmN5ICsgJ2wwLDAnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge30sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZTogWzAsIHRvQkIuY3gsIHRvQkIuY3ldXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbVBhdGhzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnTTAsMGwwLDAnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge30sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZTogWzAsIDAsIDBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9QYXRoc1tpXSkge1xuICAgICAgICAgICAgaWYgKCEhZnJvbVBhdGhzW2ldKSB7XG4gICAgICAgICAgICAgICAgdG9CQiA9ICgwLCBfc3ZnbGl0ZS5jdXJ2ZVBhdGhCQm94KSgoMCwgX3N2Z2xpdGUucGF0aDJjdXJ2ZSkoZnJvbVBhdGhzW2ldLnBhdGgpKTtcbiAgICAgICAgICAgICAgICB0b1BhdGhzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnTScgKyB0b0JCLmN4ICsgJywnICsgdG9CQi5jeSArICdsMCwwJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge30sXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGU6IFswLCB0b0JCLmN4LCB0b0JCLmN5XVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvUGF0aHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICdNMCwwbDAsMCcsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHt9LFxuICAgICAgICAgICAgICAgICAgICB0cmFuczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlOiBbMCwgMCwgMF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIHZhciBmcm9tSWNvbkl0ZW0gPSBmcm9tUGF0aHNbaV07XG4gICAgICAgIHZhciB0b0ljb25JdGVtID0gdG9QYXRoc1tpXTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgZnJvbS90byBjdXJ2ZSBkYXRhIGFuZCBzZXQgdG8gZnJvbUljb24vdG9JY29uXG4gICAgICAgIHZhciBjdXJ2ZXMgPSAoMCwgX3N2Z2xpdGUucGF0aDJjdXJ2ZSkoZnJvbVBhdGhzW2ldLnBhdGgsIHRvUGF0aHNbaV0ucGF0aCk7XG4gICAgICAgIGZyb21JY29uSXRlbS5jdXJ2ZSA9IGN1cnZlc1swXTtcbiAgICAgICAgdG9JY29uSXRlbS5jdXJ2ZSA9IGN1cnZlc1sxXTtcbiAgICAgICAgLy8gTm9ybWFsaXplIGZyb20vdG8gYXR0cnNcbiAgICAgICAgdmFyIGF0dHJzTm9ybSA9ICgwLCBfaGVscGVycy5zdHlsZVRvTm9ybSkoZnJvbVBhdGhzW2ldLmF0dHJzLCB0b1BhdGhzW2ldLmF0dHJzKTtcbiAgICAgICAgZnJvbUljb25JdGVtLmF0dHJzTm9ybSA9IGF0dHJzTm9ybVswXTtcbiAgICAgICAgdG9JY29uSXRlbS5hdHRyc05vcm0gPSBhdHRyc05vcm1bMV07XG4gICAgICAgIGZyb21JY29uSXRlbS5hdHRycyA9ICgwLCBfaGVscGVycy5zdHlsZU5vcm1Ub1N0cmluZykoZnJvbUljb25JdGVtLmF0dHJzTm9ybSk7XG4gICAgICAgIHRvSWNvbkl0ZW0uYXR0cnMgPSAoMCwgX2hlbHBlcnMuc3R5bGVOb3JtVG9TdHJpbmcpKHRvSWNvbkl0ZW0uYXR0cnNOb3JtKTtcblxuICAgICAgICAvLyBOb3JtYWxpemUgZnJvbS90byBzdHlsZVxuICAgICAgICB2YXIgc3R5bGVOb3JtID0gKDAsIF9oZWxwZXJzLnN0eWxlVG9Ob3JtKShmcm9tUGF0aHNbaV0uc3R5bGUsIHRvUGF0aHNbaV0uc3R5bGUpO1xuICAgICAgICBmcm9tSWNvbkl0ZW0uc3R5bGVOb3JtID0gc3R5bGVOb3JtWzBdO1xuICAgICAgICB0b0ljb25JdGVtLnN0eWxlTm9ybSA9IHN0eWxlTm9ybVsxXTtcbiAgICAgICAgZnJvbUljb25JdGVtLnN0eWxlID0gKDAsIF9oZWxwZXJzLnN0eWxlTm9ybVRvU3RyaW5nKShmcm9tSWNvbkl0ZW0uc3R5bGVOb3JtKTtcbiAgICAgICAgdG9JY29uSXRlbS5zdHlsZSA9ICgwLCBfaGVscGVycy5zdHlsZU5vcm1Ub1N0cmluZykodG9JY29uSXRlbS5zdHlsZU5vcm0pO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBmcm9tL3RvIHRyYW5zZm9ybVxuICAgICAgICB0b0JCID0gKDAsIF9zdmdsaXRlLmN1cnZlUGF0aEJCb3gpKHRvSWNvbkl0ZW0uY3VydmUpO1xuICAgICAgICB0b0ljb25JdGVtLnRyYW5zID0ge1xuICAgICAgICAgICAgcm90YXRlOiBbMCwgdG9CQi5jeCwgdG9CQi5jeV1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETyByb3RhdGlvbiBhY2NlcHRcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbixcbiAgICAgICAgICAgIGRlZ0FkZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJvdGF0aW9uID09PSAncmFuZG9tJykge1xuICAgICAgICAgICAgcm90YXRpb24gPSBNYXRoLnJhbmRvbSgpIDwgMC41ID8gJ2NvdW50ZXJjbG9jaycgOiAnY2xvY2snO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgIGlmICghIWZyb21JY29uSXRlbS50cmFucy5yb3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9JY29uSXRlbS50cmFucy5yb3RhdGVbMF0gPSBmcm9tSWNvbkl0ZW0udHJhbnMucm90YXRlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvdW50ZXJjbG9jayc6XG4gICAgICAgICAgICAgICAgaWYgKCEhZnJvbUljb25JdGVtLnRyYW5zLnJvdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0b0ljb25JdGVtLnRyYW5zLnJvdGF0ZVswXSA9IGZyb21JY29uSXRlbS50cmFucy5yb3RhdGVbMF0gLSAzNjA7XG4gICAgICAgICAgICAgICAgICAgIGRlZ0FkZCA9IC1mcm9tSWNvbkl0ZW0udHJhbnMucm90YXRlWzBdICUgMzYwO1xuICAgICAgICAgICAgICAgICAgICB0b0ljb25JdGVtLnRyYW5zLnJvdGF0ZVswXSArPSBkZWdBZGQgPCAxODAgPyBkZWdBZGQgOiBkZWdBZGQgLSAzNjA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9JY29uSXRlbS50cmFucy5yb3RhdGVbMF0gPSAtMzYwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gQ2xvY2t3aXNlXG4gICAgICAgICAgICAgICAgaWYgKCEhZnJvbUljb25JdGVtLnRyYW5zLnJvdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0b0ljb25JdGVtLnRyYW5zLnJvdGF0ZVswXSA9IGZyb21JY29uSXRlbS50cmFucy5yb3RhdGVbMF0gKyAzNjA7XG4gICAgICAgICAgICAgICAgICAgIGRlZ0FkZCA9IGZyb21JY29uSXRlbS50cmFucy5yb3RhdGVbMF0gJSAzNjA7XG4gICAgICAgICAgICAgICAgICAgIHRvSWNvbkl0ZW0udHJhbnMucm90YXRlWzBdICs9IGRlZ0FkZCA8IDE4MCA/IC1kZWdBZGQgOiAzNjAgLSBkZWdBZGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9JY29uSXRlbS50cmFucy5yb3RhdGVbMF0gPSAzNjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG86IHRvUGF0aHMsXG4gICAgICAgIGZyb206IGZyb21QYXRoc1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFByb2dyZXNzKGZyb21QYXRocywgdG9QYXRocywgcHJvZ3Jlc3MpIHtcbiAgICAvLyBUT0RPIGVhc2luZ1xuICAgIC8vIHByb2dyZXNzPWVhc2luZ3NbdGhpcy5fZWFzaW5nXShwcm9ncmVzcyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBuZXdQYXRocyA9IFtdO1xuICAgIHZhciBsZW4gPSBmcm9tUGF0aHMubGVuZ3RoO1xuICAgIC8vIFVwZGF0ZSBwYXRoL2F0dHJzL3RyYW5zZm9ybVxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbmV3UGF0aHNbaV0gPSB7fTtcbiAgICAgICAgbmV3UGF0aHNbaV0uY3VydmUgPSAoMCwgX2hlbHBlcnMuY3VydmVDYWxjKShmcm9tUGF0aHNbaV0uY3VydmUsIHRvUGF0aHNbaV0uY3VydmUsIHByb2dyZXNzKTtcbiAgICAgICAgbmV3UGF0aHNbaV0ucGF0aCA9ICgwLCBfc3ZnbGl0ZS5wYXRoMnN0cmluZykobmV3UGF0aHNbaV0uY3VydmUpO1xuXG4gICAgICAgIG5ld1BhdGhzW2ldLmF0dHJzTm9ybSA9ICgwLCBfaGVscGVycy5zdHlsZU5vcm1DYWxjKShmcm9tUGF0aHNbaV0uYXR0cnNOb3JtLCB0b1BhdGhzW2ldLmF0dHJzTm9ybSwgcHJvZ3Jlc3MpO1xuICAgICAgICBuZXdQYXRoc1tpXS5hdHRycyA9ICgwLCBfaGVscGVycy5zdHlsZU5vcm1Ub1N0cmluZykobmV3UGF0aHNbaV0uYXR0cnNOb3JtKTtcblxuICAgICAgICBuZXdQYXRoc1tpXS5zdHlsZU5vcm0gPSAoMCwgX2hlbHBlcnMuc3R5bGVOb3JtQ2FsYykoZnJvbVBhdGhzW2ldLnN0eWxlTm9ybSwgdG9QYXRoc1tpXS5zdHlsZU5vcm0sIHByb2dyZXNzKTtcbiAgICAgICAgbmV3UGF0aHNbaV0uc3R5bGUgPSAoMCwgX2hlbHBlcnMuc3R5bGVOb3JtVG9TdHJpbmcpKG5ld1BhdGhzW2ldLnN0eWxlTm9ybSk7XG5cbiAgICAgICAgbmV3UGF0aHNbaV0udHJhbnMgPSAoMCwgX2hlbHBlcnMudHJhbnNDYWxjKShmcm9tUGF0aHNbaV0udHJhbnMsIHRvUGF0aHNbaV0udHJhbnMsIHByb2dyZXNzKTtcbiAgICAgICAgbmV3UGF0aHNbaV0udHJhbnNTdHIgPSAoMCwgX2hlbHBlcnMudHJhbnMyc3RyaW5nKShuZXdQYXRoc1tpXS50cmFucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BhdGhzO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/utils/morph.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/utils/normalizeSvg.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/utils/normalizeSvg.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.readAttrs = readAttrs;\nexports.parseStyles = parseStyles;\nexports.readStyles = readStyles;\nexports.getAllChildren = getAllChildren;\nexports.getPathAttributes = getPathAttributes;\nexports[\"default\"] = findSvgRoot;\nexports[\"default\"] = extractSvgPaths;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _pathConverter = __webpack_require__(/*! ./pathConverter */ \"./node_modules/react-svg-morph/lib/utils/pathConverter.js\");\n\nvar PathConverter = _interopRequireWildcard(_pathConverter);\n\nfunction readAttrs(node) {\n    var attrs = {};\n    if (!node.attributes) {\n        return attrs;\n    }\n    Object.keys(node.attributes).forEach(function (_key) {\n        var val = node.attributes[_key];\n        var key = _key.toLowerCase();\n        switch (key) {\n            case 'fill':\n            case 'fill-opacity':\n            case 'opacity':\n            case 'stroke':\n            case 'stroke-opacity':\n            case 'stroke-width':\n                attrs[key] = val;\n        }\n    });\n    return attrs;\n}\n\nfunction parseStyles(styleString) {\n    if (!styleString) {\n        return [];\n    }\n    if (typeof styleString === \"object\") {\n        return Object.keys(styleString).map(function (key) {\n            return {\n                prop: key,\n                val: styleString[key]\n            };\n        });\n    }\n    return styleString.split(';').map(function (declaration) {\n        var _declaration$split$map = declaration.split(':').map(function (p) {\n            return p.replace(' ', '');\n        });\n\n        var _declaration$split$map2 = _slicedToArray(_declaration$split$map, 2);\n\n        var prop = _declaration$split$map2[0];\n        var val = _declaration$split$map2[1];\n\n        return {\n            prop: prop,\n            val: val\n        };\n    });\n}\n\nfunction readStyles(node) {\n    var style = {};\n    if (!node.attributes || !node.attributes.style) {\n        return {};\n    }\n    parseStyles(node.attributes.style).forEach(function (_ref) {\n        var val = _ref.val;\n        var key = _ref.key;\n\n        switch (key) {\n            case 'fill':\n            case 'fill-opacity':\n            case 'opacity':\n            case 'stroke':\n            case 'stroke-opacity':\n            case 'stroke-width':\n                style[key] = val;\n        }\n    });\n    return style;\n}\n\nfunction getAllChildren(node) {\n    var i = 0;\n    var els = [];\n    if (!node.children) {\n        return els;\n    }\n    var len = node.children.length;\n    for (; i < len; i++) {\n        var el = node.children[i];\n        els.push(el);\n        if (el.children && el.children.filter(Boolean).length > 0) {\n            els = els.concat(getAllChildren(el));\n        }\n    }\n\n    return els;\n}\n\nfunction getPathAttributes(node, defaultItem) {\n    var item = _extends({\n        trans: {\n            rotate: [360, 12, 12]\n        },\n        transStr: 'rotate(360 12 12)'\n    }, defaultItem);\n\n    if (!node || !node.name) {\n        return false;\n    }\n\n    var nodeName = node.name.toUpperCase();\n    switch (nodeName) {\n        case 'PATH':\n            item.path = node.attributes.d;\n            break;\n        case 'CIRCLE':\n            item.path = PathConverter.fromCircle(node.attributes);\n            break;\n        case 'ELLIPSE':\n            item.path = PathConverter.fromEllipse(node.attributes);\n            break;\n        case 'RECT':\n            item.path = PathConverter.fromRect(node.attributes);\n            break;\n        case 'POLYGON':\n            item.path = PathConverter.fromPolygon(node.attributes);\n            break;\n        case 'LINE':\n            item.path = PathConverter.fromLine(node.attributes);\n            break;\n        default:\n            return false;\n    }\n    var attrs = readAttrs(node);\n    var style = readStyles(node);\n    item.attrs = _extends({}, item.attrs, attrs);\n    item.style = _extends({}, item.style, style);\n    return item;\n}\n\nfunction findSvgRoot(node) {\n    if (!node || !node.name || node.name.toUpperCase() !== \"SVG\") {\n        return node.children.find(function (child) {\n            return findSvgRoot(child);\n        });\n    }\n\n    return node;\n}\n\nfunction extractSvgPaths(root) {\n    var svgRoot = findSvgRoot(root);\n    var children = getAllChildren(svgRoot);\n    var svg = _extends({}, svgRoot.attributes);\n    var rootAttr = readAttrs(svgRoot);\n    var rootStyles = readStyles(svgRoot);\n\n    svg.paths = [];\n    children.forEach(function (child) {\n\n        var item = getPathAttributes(child, {\n            attrs: _extends({}, rootAttr, readAttrs(child)),\n            styles: _extends({}, rootStyles, readStyles(child))\n        });\n        if (item) {\n            svg.paths.push(item);\n        }\n    });\n\n    return svg;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi91dGlscy9ub3JtYWxpemVTdmcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLG9DQUFvQyxpQ0FBaUMsZUFBZSxlQUFlLGdCQUFnQixvQkFBb0IsTUFBTSwwQ0FBMEMsK0JBQStCLGFBQWEscUJBQXFCLHVDQUF1QyxjQUFjLFdBQVcsWUFBWSxVQUFVLE1BQU0sMkNBQTJDLFVBQVUsc0JBQXNCLGVBQWUsMkJBQTJCLDBCQUEwQixjQUFjLDJDQUEyQyxnQ0FBZ0MsT0FBTyxtRkFBbUY7O0FBRXRwQixvREFBb0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQzs7QUFFaFAsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEIsa0JBQWtCOztBQUVsQix3Q0FBd0MsNkJBQTZCLGNBQWMsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1QixnRkFBZ0YseUJBQXlCOztBQUU5UCxxQkFBcUIsbUJBQU8sQ0FBQyxrRkFBaUI7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXN2Zy1tb3JwaC9saWIvdXRpbHMvbm9ybWFsaXplU3ZnLmpzPzM3MjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5yZWFkQXR0cnMgPSByZWFkQXR0cnM7XG5leHBvcnRzLnBhcnNlU3R5bGVzID0gcGFyc2VTdHlsZXM7XG5leHBvcnRzLnJlYWRTdHlsZXMgPSByZWFkU3R5bGVzO1xuZXhwb3J0cy5nZXRBbGxDaGlsZHJlbiA9IGdldEFsbENoaWxkcmVuO1xuZXhwb3J0cy5nZXRQYXRoQXR0cmlidXRlcyA9IGdldFBhdGhBdHRyaWJ1dGVzO1xuZXhwb3J0c1snZGVmYXVsdCddID0gZmluZFN2Z1Jvb3Q7XG5leHBvcnRzWydkZWZhdWx0J10gPSBleHRyYWN0U3ZnUGF0aHM7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbnZhciBfcGF0aENvbnZlcnRlciA9IHJlcXVpcmUoJy4vcGF0aENvbnZlcnRlcicpO1xuXG52YXIgUGF0aENvbnZlcnRlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9wYXRoQ29udmVydGVyKTtcblxuZnVuY3Rpb24gcmVhZEF0dHJzKG5vZGUpIHtcbiAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICBpZiAoIW5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKG5vZGUuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoX2tleSkge1xuICAgICAgICB2YXIgdmFsID0gbm9kZS5hdHRyaWJ1dGVzW19rZXldO1xuICAgICAgICB2YXIga2V5ID0gX2tleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnZmlsbCc6XG4gICAgICAgICAgICBjYXNlICdmaWxsLW9wYWNpdHknOlxuICAgICAgICAgICAgY2FzZSAnb3BhY2l0eSc6XG4gICAgICAgICAgICBjYXNlICdzdHJva2UnOlxuICAgICAgICAgICAgY2FzZSAnc3Ryb2tlLW9wYWNpdHknOlxuICAgICAgICAgICAgY2FzZSAnc3Ryb2tlLXdpZHRoJzpcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0eWxlcyhzdHlsZVN0cmluZykge1xuICAgIGlmICghc3R5bGVTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0eWxlU3RyaW5nID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZVN0cmluZykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJvcDoga2V5LFxuICAgICAgICAgICAgICAgIHZhbDogc3R5bGVTdHJpbmdba2V5XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZVN0cmluZy5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgdmFyIF9kZWNsYXJhdGlvbiRzcGxpdCRtYXAgPSBkZWNsYXJhdGlvbi5zcGxpdCgnOicpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgcmV0dXJuIHAucmVwbGFjZSgnICcsICcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIF9kZWNsYXJhdGlvbiRzcGxpdCRtYXAyID0gX3NsaWNlZFRvQXJyYXkoX2RlY2xhcmF0aW9uJHNwbGl0JG1hcCwgMik7XG5cbiAgICAgICAgdmFyIHByb3AgPSBfZGVjbGFyYXRpb24kc3BsaXQkbWFwMlswXTtcbiAgICAgICAgdmFyIHZhbCA9IF9kZWNsYXJhdGlvbiRzcGxpdCRtYXAyWzFdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9wOiBwcm9wLFxuICAgICAgICAgICAgdmFsOiB2YWxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZFN0eWxlcyhub2RlKSB7XG4gICAgdmFyIHN0eWxlID0ge307XG4gICAgaWYgKCFub2RlLmF0dHJpYnV0ZXMgfHwgIW5vZGUuYXR0cmlidXRlcy5zdHlsZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHBhcnNlU3R5bGVzKG5vZGUuYXR0cmlidXRlcy5zdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdmFsID0gX3JlZi52YWw7XG4gICAgICAgIHZhciBrZXkgPSBfcmVmLmtleTtcblxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnZmlsbCc6XG4gICAgICAgICAgICBjYXNlICdmaWxsLW9wYWNpdHknOlxuICAgICAgICAgICAgY2FzZSAnb3BhY2l0eSc6XG4gICAgICAgICAgICBjYXNlICdzdHJva2UnOlxuICAgICAgICAgICAgY2FzZSAnc3Ryb2tlLW9wYWNpdHknOlxuICAgICAgICAgICAgY2FzZSAnc3Ryb2tlLXdpZHRoJzpcbiAgICAgICAgICAgICAgICBzdHlsZVtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihub2RlKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBlbHMgPSBbXTtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuIGVscztcbiAgICB9XG4gICAgdmFyIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGVsID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZWxzLnB1c2goZWwpO1xuICAgICAgICBpZiAoZWwuY2hpbGRyZW4gJiYgZWwuY2hpbGRyZW4uZmlsdGVyKEJvb2xlYW4pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVscyA9IGVscy5jb25jYXQoZ2V0QWxsQ2hpbGRyZW4oZWwpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbHM7XG59XG5cbmZ1bmN0aW9uIGdldFBhdGhBdHRyaWJ1dGVzKG5vZGUsIGRlZmF1bHRJdGVtKSB7XG4gICAgdmFyIGl0ZW0gPSBfZXh0ZW5kcyh7XG4gICAgICAgIHRyYW5zOiB7XG4gICAgICAgICAgICByb3RhdGU6IFszNjAsIDEyLCAxMl1cbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNTdHI6ICdyb3RhdGUoMzYwIDEyIDEyKSdcbiAgICB9LCBkZWZhdWx0SXRlbSk7XG5cbiAgICBpZiAoIW5vZGUgfHwgIW5vZGUubmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVOYW1lID0gbm9kZS5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgc3dpdGNoIChub2RlTmFtZSkge1xuICAgICAgICBjYXNlICdQQVRIJzpcbiAgICAgICAgICAgIGl0ZW0ucGF0aCA9IG5vZGUuYXR0cmlidXRlcy5kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0NJUkNMRSc6XG4gICAgICAgICAgICBpdGVtLnBhdGggPSBQYXRoQ29udmVydGVyLmZyb21DaXJjbGUobm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFTExJUFNFJzpcbiAgICAgICAgICAgIGl0ZW0ucGF0aCA9IFBhdGhDb252ZXJ0ZXIuZnJvbUVsbGlwc2Uobm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSRUNUJzpcbiAgICAgICAgICAgIGl0ZW0ucGF0aCA9IFBhdGhDb252ZXJ0ZXIuZnJvbVJlY3Qobm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdQT0xZR09OJzpcbiAgICAgICAgICAgIGl0ZW0ucGF0aCA9IFBhdGhDb252ZXJ0ZXIuZnJvbVBvbHlnb24obm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdMSU5FJzpcbiAgICAgICAgICAgIGl0ZW0ucGF0aCA9IFBhdGhDb252ZXJ0ZXIuZnJvbUxpbmUobm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYXR0cnMgPSByZWFkQXR0cnMobm9kZSk7XG4gICAgdmFyIHN0eWxlID0gcmVhZFN0eWxlcyhub2RlKTtcbiAgICBpdGVtLmF0dHJzID0gX2V4dGVuZHMoe30sIGl0ZW0uYXR0cnMsIGF0dHJzKTtcbiAgICBpdGVtLnN0eWxlID0gX2V4dGVuZHMoe30sIGl0ZW0uc3R5bGUsIHN0eWxlKTtcbiAgICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gZmluZFN2Z1Jvb3Qobm9kZSkge1xuICAgIGlmICghbm9kZSB8fCAhbm9kZS5uYW1lIHx8IG5vZGUubmFtZS50b1VwcGVyQ2FzZSgpICE9PSBcIlNWR1wiKSB7XG4gICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluZFN2Z1Jvb3QoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFN2Z1BhdGhzKHJvb3QpIHtcbiAgICB2YXIgc3ZnUm9vdCA9IGZpbmRTdmdSb290KHJvb3QpO1xuICAgIHZhciBjaGlsZHJlbiA9IGdldEFsbENoaWxkcmVuKHN2Z1Jvb3QpO1xuICAgIHZhciBzdmcgPSBfZXh0ZW5kcyh7fSwgc3ZnUm9vdC5hdHRyaWJ1dGVzKTtcbiAgICB2YXIgcm9vdEF0dHIgPSByZWFkQXR0cnMoc3ZnUm9vdCk7XG4gICAgdmFyIHJvb3RTdHlsZXMgPSByZWFkU3R5bGVzKHN2Z1Jvb3QpO1xuXG4gICAgc3ZnLnBhdGhzID0gW107XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcblxuICAgICAgICB2YXIgaXRlbSA9IGdldFBhdGhBdHRyaWJ1dGVzKGNoaWxkLCB7XG4gICAgICAgICAgICBhdHRyczogX2V4dGVuZHMoe30sIHJvb3RBdHRyLCByZWFkQXR0cnMoY2hpbGQpKSxcbiAgICAgICAgICAgIHN0eWxlczogX2V4dGVuZHMoe30sIHJvb3RTdHlsZXMsIHJlYWRTdHlsZXMoY2hpbGQpKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHN2Zy5wYXRocy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3ZnO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/utils/normalizeSvg.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/utils/pathConverter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/utils/pathConverter.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fromPolygon = fromPolygon;\nexports.fromLine = fromLine;\nexports.fromRect = fromRect;\nexports.fromPath = fromPath;\nexports.fromCircle = fromCircle;\nexports.fromEllipse = fromEllipse;\n\nfunction fromPolygon(polygon) {\n    var points = polygon.points;\n    var p = points.split(/\\s+/);\n    var path = \"\";\n    var k = 0;\n    var len = p.length;\n    for (; k < len; k++) {\n        path += (k && \"L\" || \"M\") + p[k];\n    }\n    return path + 'z';\n}\n\nfunction fromLine(line) {\n    var x1 = line.x1;\n    var y1 = line.y1;\n    var x2 = line.x2;\n    var y2 = line.y2;\n\n    return 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2 + 'z';\n}\n\nfunction fromRect(rect) {\n    var x = rect.x;\n    var y = rect.y;\n    var rx = rect.rx;\n    var ry = rect.ry;\n\n    var h = rect.height;\n    var w = rect.width;\n\n    if (!rx && !ry) {\n        return 'M' + x + ',' + y + 'l' + w + ',0l0,' + h + 'l-' + w + ',0z';\n    }\n    return 'M' + (x + rx) + ',' + y + 'l' + (w - rx * 2) + ',0' + 'a' + rx + ',' + ry + ' 0 0,1 ' + rx + ',' + ry + 'l0,' + (h - ry * 2) + 'a' + rx + ',' + ry + ' 0 0,1 -' + rx + ',' + ry + 'l' + (rx * 2 - w) + ',0' + 'a' + rx + ',' + ry + ' 0 0,1 -' + rx + ',-' + ry + 'l0,' + (ry * 2 - h) + 'a' + rx + ',' + ry + ' 0 0,1 ' + rx + ',-' + ry + 'z';\n}\n\nfunction fromPath(path) {\n    return path.d;\n}\n\nfunction fromCircle(circle) {\n    var cx = circle.cx;\n    var cy = circle.cy;\n    var r = circle.r;\n\n    return 'M' + (cx - r) + ',' + cy + 'a' + r + ',' + r + ' 0 1,0 ' + r * 2 + ',0a' + r + ',' + r + ' 0 1,0 -' + r * 2 + ',0z';\n}\n\nfunction fromEllipse(ellipse) {\n    var cx = ellipse.cx;\n    var cy = ellipse.cy;\n    var rx = ellipse.rx;\n    var ry = ellipse.ry;\n\n    return 'M' + (cx - rx) + ',' + cy + 'a' + rx + ',' + ry + ' 0 1,0 ' + rx * 2 + ',0a' + rx + ',' + ry + ' 0 1,0 -' + rx * 2 + ',0z';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi91dGlscy9wYXRoQ29udmVydGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi91dGlscy9wYXRoQ29udmVydGVyLmpzP2MyNjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZnJvbVBvbHlnb24gPSBmcm9tUG9seWdvbjtcbmV4cG9ydHMuZnJvbUxpbmUgPSBmcm9tTGluZTtcbmV4cG9ydHMuZnJvbVJlY3QgPSBmcm9tUmVjdDtcbmV4cG9ydHMuZnJvbVBhdGggPSBmcm9tUGF0aDtcbmV4cG9ydHMuZnJvbUNpcmNsZSA9IGZyb21DaXJjbGU7XG5leHBvcnRzLmZyb21FbGxpcHNlID0gZnJvbUVsbGlwc2U7XG5cbmZ1bmN0aW9uIGZyb21Qb2x5Z29uKHBvbHlnb24pIHtcbiAgICB2YXIgcG9pbnRzID0gcG9seWdvbi5wb2ludHM7XG4gICAgdmFyIHAgPSBwb2ludHMuc3BsaXQoL1xccysvKTtcbiAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgdmFyIGsgPSAwO1xuICAgIHZhciBsZW4gPSBwLmxlbmd0aDtcbiAgICBmb3IgKDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgIHBhdGggKz0gKGsgJiYgXCJMXCIgfHwgXCJNXCIpICsgcFtrXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGggKyAneic7XG59XG5cbmZ1bmN0aW9uIGZyb21MaW5lKGxpbmUpIHtcbiAgICB2YXIgeDEgPSBsaW5lLngxO1xuICAgIHZhciB5MSA9IGxpbmUueTE7XG4gICAgdmFyIHgyID0gbGluZS54MjtcbiAgICB2YXIgeTIgPSBsaW5lLnkyO1xuXG4gICAgcmV0dXJuICdNJyArIHgxICsgJywnICsgeTEgKyAnTCcgKyB4MiArICcsJyArIHkyICsgJ3onO1xufVxuXG5mdW5jdGlvbiBmcm9tUmVjdChyZWN0KSB7XG4gICAgdmFyIHggPSByZWN0Lng7XG4gICAgdmFyIHkgPSByZWN0Lnk7XG4gICAgdmFyIHJ4ID0gcmVjdC5yeDtcbiAgICB2YXIgcnkgPSByZWN0LnJ5O1xuXG4gICAgdmFyIGggPSByZWN0LmhlaWdodDtcbiAgICB2YXIgdyA9IHJlY3Qud2lkdGg7XG5cbiAgICBpZiAoIXJ4ICYmICFyeSkge1xuICAgICAgICByZXR1cm4gJ00nICsgeCArICcsJyArIHkgKyAnbCcgKyB3ICsgJywwbDAsJyArIGggKyAnbC0nICsgdyArICcsMHonO1xuICAgIH1cbiAgICByZXR1cm4gJ00nICsgKHggKyByeCkgKyAnLCcgKyB5ICsgJ2wnICsgKHcgLSByeCAqIDIpICsgJywwJyArICdhJyArIHJ4ICsgJywnICsgcnkgKyAnIDAgMCwxICcgKyByeCArICcsJyArIHJ5ICsgJ2wwLCcgKyAoaCAtIHJ5ICogMikgKyAnYScgKyByeCArICcsJyArIHJ5ICsgJyAwIDAsMSAtJyArIHJ4ICsgJywnICsgcnkgKyAnbCcgKyAocnggKiAyIC0gdykgKyAnLDAnICsgJ2EnICsgcnggKyAnLCcgKyByeSArICcgMCAwLDEgLScgKyByeCArICcsLScgKyByeSArICdsMCwnICsgKHJ5ICogMiAtIGgpICsgJ2EnICsgcnggKyAnLCcgKyByeSArICcgMCAwLDEgJyArIHJ4ICsgJywtJyArIHJ5ICsgJ3onO1xufVxuXG5mdW5jdGlvbiBmcm9tUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGguZDtcbn1cblxuZnVuY3Rpb24gZnJvbUNpcmNsZShjaXJjbGUpIHtcbiAgICB2YXIgY3ggPSBjaXJjbGUuY3g7XG4gICAgdmFyIGN5ID0gY2lyY2xlLmN5O1xuICAgIHZhciByID0gY2lyY2xlLnI7XG5cbiAgICByZXR1cm4gJ00nICsgKGN4IC0gcikgKyAnLCcgKyBjeSArICdhJyArIHIgKyAnLCcgKyByICsgJyAwIDEsMCAnICsgciAqIDIgKyAnLDBhJyArIHIgKyAnLCcgKyByICsgJyAwIDEsMCAtJyArIHIgKiAyICsgJywweic7XG59XG5cbmZ1bmN0aW9uIGZyb21FbGxpcHNlKGVsbGlwc2UpIHtcbiAgICB2YXIgY3ggPSBlbGxpcHNlLmN4O1xuICAgIHZhciBjeSA9IGVsbGlwc2UuY3k7XG4gICAgdmFyIHJ4ID0gZWxsaXBzZS5yeDtcbiAgICB2YXIgcnkgPSBlbGxpcHNlLnJ5O1xuXG4gICAgcmV0dXJuICdNJyArIChjeCAtIHJ4KSArICcsJyArIGN5ICsgJ2EnICsgcnggKyAnLCcgKyByeSArICcgMCAxLDAgJyArIHJ4ICogMiArICcsMGEnICsgcnggKyAnLCcgKyByeSArICcgMCAxLDAgLScgKyByeCAqIDIgKyAnLDB6Jztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/utils/pathConverter.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/utils/scalePath.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/utils/scalePath.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = scalePath;\nvar svgpath = __webpack_require__(/*! svgpath */ \"./node_modules/svgpath/index.js\");\n\nfunction scalePath(path, base, _width, _height) {\n    var x = 0;\n    var y = 0;\n    var scale = 1;\n    var width = parseInt(_width, 10);\n    var height = parseInt(_height, 10);\n    if (width >= height) {\n        scale = base / width;\n        y = (width - height) / 2;\n    } else {\n        scale = base / height;\n        x = (height - width) / 2;\n    }\n    return svgpath(path).translate(x, y).scale(scale).abs().round(1) // Here the real rounding happens\n    .rel().round(1) // Fix js floating point error/garbage after rel()\n    .toString();\n}\n\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi91dGlscy9zY2FsZVBhdGguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCO0FBQ2xCLGNBQWMsbUJBQU8sQ0FBQyxnREFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zdmctbW9ycGgvbGliL3V0aWxzL3NjYWxlUGF0aC5qcz8yMzE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNjYWxlUGF0aDtcbnZhciBzdmdwYXRoID0gcmVxdWlyZShcInN2Z3BhdGhcIik7XG5cbmZ1bmN0aW9uIHNjYWxlUGF0aChwYXRoLCBiYXNlLCBfd2lkdGgsIF9oZWlnaHQpIHtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciBzY2FsZSA9IDE7XG4gICAgdmFyIHdpZHRoID0gcGFyc2VJbnQoX3dpZHRoLCAxMCk7XG4gICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KF9oZWlnaHQsIDEwKTtcbiAgICBpZiAod2lkdGggPj0gaGVpZ2h0KSB7XG4gICAgICAgIHNjYWxlID0gYmFzZSAvIHdpZHRoO1xuICAgICAgICB5ID0gKHdpZHRoIC0gaGVpZ2h0KSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGUgPSBiYXNlIC8gaGVpZ2h0O1xuICAgICAgICB4ID0gKGhlaWdodCAtIHdpZHRoKSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBzdmdwYXRoKHBhdGgpLnRyYW5zbGF0ZSh4LCB5KS5zY2FsZShzY2FsZSkuYWJzKCkucm91bmQoMSkgLy8gSGVyZSB0aGUgcmVhbCByb3VuZGluZyBoYXBwZW5zXG4gICAgLnJlbCgpLnJvdW5kKDEpIC8vIEZpeCBqcyBmbG9hdGluZyBwb2ludCBlcnJvci9nYXJiYWdlIGFmdGVyIHJlbCgpXG4gICAgLnRvU3RyaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/utils/scalePath.js\n");

/***/ }),

/***/ "./node_modules/react-svg-morph/lib/utils/svglite.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-svg-morph/lib/utils/svglite.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/*\n * Useful things from Adobe's Snap.svg adopted to the library needs\n */\n\n/*\n * Paths\n */\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parsePathString = parsePathString;\nexports.catmullRom2bezier = catmullRom2bezier;\nexports.ellipsePath = ellipsePath;\nexports.pathToAbsolute = pathToAbsolute;\nexports.l2c = l2c;\nexports.q2c = q2c;\nexports.a2c = a2c;\nexports.path2curve = path2curve;\nexports.box = box;\nexports.curveDim = curveDim;\nexports.curvePathBBox = curvePathBBox;\nexports.path2string = path2string;\nexports.rgbToString = rgbToString;\nexports.toHex = toHex;\nexports.packageRGB = packageRGB;\nexports.hsb2rgb = hsb2rgb;\nexports.hsl2rgb = hsl2rgb;\nexports.getRGB = getRGB;\nvar spaces = \"\\t\\n\\u000b\\f\\r   ᠎             　\\u2028\\u2029\";\nvar pathCommand = new RegExp(\"([a-z])[\" + spaces + \",]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[\" + spaces + \"]*,?[\" + spaces + \"]*)+)\", \"ig\");\nvar pathValues = new RegExp(\"(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[\" + spaces + \"]*,?[\" + spaces + \"]*\", \"ig\");\n\n// Parses given path string into an array of arrays of path segments\n\nfunction parsePathString(pathString) {\n    if (!pathString) {\n        return null;\n    }\n\n    if (typeof pathString === typeof []) {\n        return pathString;\n    }\n    var paramCounts = { a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0 };\n    var data = [];\n\n    String(pathString).replace(pathCommand, function replacePath(a, b, c) {\n        var params = [];\n        var name = b.toLowerCase();\n        var l = b;\n        c.replace(pathValues, function replaceC(a, b) {\n            if (b) {\n                params.push(+b);\n            }\n        });\n        if (name === \"m\" && params.length > 2) {\n            data.push([b].concat(params.splice(0, 2)));\n            name = \"l\";\n            l = b === \"m\" ? \"l\" : \"L\";\n        }\n        if (name === \"o\" && params.length === 1) {\n            data.push([l, params[0]]);\n        }\n        if (name === \"r\") {\n            data.push([l].concat(params));\n        } else {\n            while (params.length >= paramCounts[name]) {\n                data.push([l].concat(params.splice(0, paramCounts[name])));\n                if (!paramCounts[name]) {\n                    break;\n                }\n            }\n        }\n    });\n\n    return data;\n}\n\n// http://schepers.cc/getting-to-the-point\n\nfunction catmullRom2bezier(crp, z) {\n    var d = [];\n    var i = 0,\n        iLen = crp.length;\n    for (; iLen - 2 * !z > i; i += 2) {\n        var p = [{ x: +crp[i - 2], y: +crp[i - 1] }, { x: +crp[i], y: +crp[i + 1] }, { x: +crp[i + 2], y: +crp[i + 3] }, { x: +crp[i + 4], y: +crp[i + 5] }];\n        if (z) {\n            if (!i) {\n                p[0] = { x: +crp[iLen - 2], y: +crp[iLen - 1] };\n            } else if (iLen - 4 === i) {\n                p[3] = { x: +crp[0], y: +crp[1] };\n            } else if (iLen - 2 === i) {\n                p[2] = { x: +crp[0], y: +crp[1] };\n                p[3] = { x: +crp[2], y: +crp[3] };\n            }\n        } else {\n            if (iLen - 4 === i) {\n                p[3] = p[2];\n            } else if (!i) {\n                p[0] = { x: +crp[i], y: +crp[i + 1] };\n            }\n        }\n        d.push([\"C\", (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);\n    }\n\n    return d;\n}\n\nfunction ellipsePath(_x, _y, _rx, _ry, a) {\n    var rx = _rx;\n    var ry = _ry;\n    var x = _x;\n    var y = _y;\n    var res;\n    if (a === null && ry === null) {\n        ry = rx;\n    }\n    x = +x;\n    y = +y;\n    rx = +rx;\n    ry = +ry;\n    if (a !== null) {\n        var rad = Math.PI / 180;\n        var x1 = x + rx * Math.cos(-ry * rad);\n        var x2 = x + rx * Math.cos(-a * rad);\n        var y1 = y + rx * Math.sin(-ry * rad);\n        var y2 = y + rx * Math.sin(-a * rad);\n        return [[\"M\", x1, y1], [\"A\", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n    }\n    return [[\"M\", x, y], [\"m\", 0, -ry], [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry], [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry], [\"z\"]];\n}\n\n;\n\nfunction pathToAbsolute(pathArray) {\n    pathArray = parsePathString(pathArray);\n\n    if (!pathArray || !pathArray.length) {\n        return [[\"M\", 0, 0]];\n    }\n    var res = [],\n        x = 0,\n        y = 0,\n        mx = 0,\n        my = 0,\n        start = 0,\n        pa0;\n    if (pathArray[0][0] == \"M\") {\n        x = +pathArray[0][1];\n        y = +pathArray[0][2];\n        mx = x;\n        my = y;\n        start++;\n        res[0] = [\"M\", x, y];\n    }\n    var crz = pathArray.length == 3 && pathArray[0][0] == \"M\" && pathArray[1][0].toUpperCase() == \"R\" && pathArray[2][0].toUpperCase() == \"Z\";\n    for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n        res.push(r = []);\n        pa = pathArray[i];\n        pa0 = pa[0];\n        if (pa0 != pa0.toUpperCase()) {\n            r[0] = pa0.toUpperCase();\n            switch (r[0]) {\n                case \"A\":\n                    r[1] = pa[1];\n                    r[2] = pa[2];\n                    r[3] = pa[3];\n                    r[4] = pa[4];\n                    r[5] = pa[5];\n                    r[6] = +pa[6] + x;\n                    r[7] = +pa[7] + y;\n                    break;\n                case \"V\":\n                    r[1] = +pa[1] + y;\n                    break;\n                case \"H\":\n                    r[1] = +pa[1] + x;\n                    break;\n                case \"R\":\n                    var dots = [x, y].concat(pa.slice(1));\n                    for (var j = 2, jj = dots.length; j < jj; j++) {\n                        dots[j] = +dots[j] + x;\n                        dots[++j] = +dots[j] + y;\n                    }\n                    res.pop();\n                    res = res.concat(catmullRom2bezier(dots, crz));\n                    break;\n                case \"O\":\n                    res.pop();\n                    dots = ellipsePath(x, y, pa[1], pa[2]);\n                    dots.push(dots[0]);\n                    res = res.concat(dots);\n                    break;\n                case \"U\":\n                    res.pop();\n                    res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                    r = [\"U\"].concat(res[res.length - 1].slice(-2));\n                    break;\n                case \"M\":\n                    mx = +pa[1] + x;\n                    my = +pa[2] + y;\n                default:\n                    for (j = 1, jj = pa.length; j < jj; j++) {\n                        r[j] = +pa[j] + (j % 2 ? x : y);\n                    }\n            }\n        } else if (pa0 == \"R\") {\n            dots = [x, y].concat(pa.slice(1));\n            res.pop();\n            res = res.concat(catmullRom2bezier(dots, crz));\n            r = [\"R\"].concat(pa.slice(-2));\n        } else if (pa0 == \"O\") {\n            res.pop();\n            dots = ellipsePath(x, y, pa[1], pa[2]);\n            dots.push(dots[0]);\n            res = res.concat(dots);\n        } else if (pa0 == \"U\") {\n            res.pop();\n            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n            r = [\"U\"].concat(res[res.length - 1].slice(-2));\n        } else {\n            for (var k = 0, kk = pa.length; k < kk; k++) {\n                r[k] = pa[k];\n            }\n        }\n        pa0 = pa0.toUpperCase();\n        if (pa0 != \"O\") {\n            switch (r[0]) {\n                case \"Z\":\n                    x = +mx;\n                    y = +my;\n                    break;\n                case \"H\":\n                    x = r[1];\n                    break;\n                case \"V\":\n                    y = r[1];\n                    break;\n                case \"M\":\n                    mx = r[r.length - 2];\n                    my = r[r.length - 1];\n                default:\n                    x = r[r.length - 2];\n                    y = r[r.length - 1];\n            }\n        }\n    }\n\n    return res;\n}\n\n;\n\nfunction l2c(x1, y1, x2, y2) {\n    return [x1, y1, x2, y2, x2, y2];\n}\n\n;\n\nfunction q2c(x1, y1, ax, ay, x2, y2) {\n    var _13 = 1 / 3,\n        _23 = 2 / 3;\n    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n}\n\n;\n\nfunction a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n    // for more information of where this math came from visit:\n    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n    var _120 = Math.PI * 120 / 180,\n        rad = Math.PI / 180 * (+angle || 0),\n        res = [],\n        xy,\n        rotate = function rotate(x, y, rad) {\n        var X = x * Math.cos(rad) - y * Math.sin(rad),\n            Y = x * Math.sin(rad) + y * Math.cos(rad);\n        return { x: X, y: Y };\n    };\n    if (!recursive) {\n        xy = rotate(x1, y1, -rad);\n        x1 = xy.x;\n        y1 = xy.y;\n        xy = rotate(x2, y2, -rad);\n        x2 = xy.x;\n        y2 = xy.y;\n        var cos = Math.cos(Math.PI / 180 * angle),\n            sin = Math.sin(Math.PI / 180 * angle),\n            x = (x1 - x2) / 2,\n            y = (y1 - y2) / 2;\n        var h = x * x / (rx * rx) + y * y / (ry * ry);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            rx = h * rx;\n            ry = h * ry;\n        }\n        var rx2 = rx * rx,\n            ry2 = ry * ry,\n            k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n            cx = k * rx * y / ry + (x1 + x2) / 2,\n            cy = k * -ry * x / rx + (y1 + y2) / 2,\n            f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),\n            f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n\n        f1 = x1 < cx ? Math.PI - f1 : f1;\n        f2 = x2 < cx ? Math.PI - f2 : f2;\n        f1 < 0 && (f1 = Math.PI * 2 + f1);\n        f2 < 0 && (f2 = Math.PI * 2 + f2);\n        if (sweep_flag && f1 > f2) {\n            f1 = f1 - Math.PI * 2;\n        }\n        if (!sweep_flag && f2 > f1) {\n            f2 = f2 - Math.PI * 2;\n        }\n    } else {\n        f1 = recursive[0];\n        f2 = recursive[1];\n        cx = recursive[2];\n        cy = recursive[3];\n    }\n    var df = f2 - f1;\n    if (Math.abs(df) > _120) {\n        var f2old = f2,\n            x2old = x2,\n            y2old = y2;\n        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n        x2 = cx + rx * Math.cos(f2);\n        y2 = cy + ry * Math.sin(f2);\n        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    var c1 = Math.cos(f1),\n        s1 = Math.sin(f1),\n        c2 = Math.cos(f2),\n        s2 = Math.sin(f2),\n        t = Math.tan(df / 4),\n        hx = 4 / 3 * rx * t,\n        hy = 4 / 3 * ry * t,\n        m1 = [x1, y1],\n        m2 = [x1 + hx * s1, y1 - hy * c1],\n        m3 = [x2 + hx * s2, y2 - hy * c2],\n        m4 = [x2, y2];\n    m2[0] = 2 * m1[0] - m2[0];\n    m2[1] = 2 * m1[1] - m2[1];\n    if (recursive) {\n        return [m2, m3, m4].concat(res);\n    } else {\n        res = [m2, m3, m4].concat(res).join().split(\",\");\n        var newres = [];\n        for (var i = 0, ii = res.length; i < ii; i++) {\n            newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n        }\n        return newres;\n    }\n}\n\n;\n\nfunction path2curve(path, path2) {\n    var p = pathToAbsolute(path),\n        p2 = path2 && pathToAbsolute(path2),\n        attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },\n        attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },\n        processPath = function processPath(path, d, pcom) {\n        var nx, ny;\n        if (!path) {\n            return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n        }\n        !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);\n        switch (path[0]) {\n            case \"M\":\n                d.X = path[1];\n                d.Y = path[2];\n                break;\n            case \"A\":\n                path = [\"C\"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                break;\n            case \"S\":\n                if (pcom == \"C\" || pcom == \"S\") {\n                    // In \"S\" case we have to take into account, if the previous command is C/S.\n                    nx = d.x * 2 - d.bx; // And reflect the previous\n                    ny = d.y * 2 - d.by; // command's control point relative to the current point.\n                } else {\n                        // or some else or nothing\n                        nx = d.x;\n                        ny = d.y;\n                    }\n                path = [\"C\", nx, ny].concat(path.slice(1));\n                break;\n            case \"T\":\n                if (pcom == \"Q\" || pcom == \"T\") {\n                    // In \"T\" case we have to take into account, if the previous command is Q/T.\n                    d.qx = d.x * 2 - d.qx; // And make a reflection similar\n                    d.qy = d.y * 2 - d.qy; // to case \"S\".\n                } else {\n                        // or something else or nothing\n                        d.qx = d.x;\n                        d.qy = d.y;\n                    }\n                path = [\"C\"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                break;\n            case \"Q\":\n                d.qx = path[1];\n                d.qy = path[2];\n                path = [\"C\"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                break;\n            case \"L\":\n                path = [\"C\"].concat(l2c(d.x, d.y, path[1], path[2]));\n                break;\n            case \"H\":\n                path = [\"C\"].concat(l2c(d.x, d.y, path[1], d.y));\n                break;\n            case \"V\":\n                path = [\"C\"].concat(l2c(d.x, d.y, d.x, path[1]));\n                break;\n            case \"Z\":\n                path = [\"C\"].concat(l2c(d.x, d.y, d.X, d.Y));\n                break;\n        }\n        return path;\n    },\n        fixArc = function fixArc(pp, i) {\n        if (pp[i].length > 7) {\n            pp[i].shift();\n            var pi = pp[i];\n            while (pi.length) {\n                pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n                p2 && (pcoms2[i] = \"A\"); // the same as above\n                pp.splice(i++, 0, [\"C\"].concat(pi.splice(0, 6)));\n            }\n            pp.splice(i, 1);\n            ii = Math.max(p.length, p2 && p2.length || 0);\n        }\n    },\n        fixM = function fixM(path1, path2, a1, a2, i) {\n        if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n            path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n            a1.bx = 0;\n            a1.by = 0;\n            a1.x = path1[i][1];\n            a1.y = path1[i][2];\n            ii = Math.max(p.length, p2 && p2.length || 0);\n        }\n    },\n        pcoms1 = [],\n        // path commands of original path p\n    pcoms2 = [],\n        // path commands of original path p2\n    pfirst = \"\",\n        // temporary holder for original path command\n    pcom = \"\"; // holder for previous path command of original path\n    for (var i = 0, ii = Math.max(p.length, p2 && p2.length || 0); i < ii; i++) {\n        p[i] && (pfirst = p[i][0]); // save current path command\n\n        if (pfirst != \"C\") {\n            // C is not saved yet, because it may be result of conversion\n            pcoms1[i] = pfirst; // Save current path command\n            i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\n        }\n        p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n        if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n        // which may produce multiple C:s\n        // so we have to make sure that C is also C in original path\n\n        fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n        if (p2) {\n            // the same procedures is done to p2\n            p2[i] && (pfirst = p2[i][0]);\n            if (pfirst != \"C\") {\n                pcoms2[i] = pfirst;\n                i && (pcom = pcoms2[i - 1]);\n            }\n            p2[i] = processPath(p2[i], attrs2, pcom);\n\n            if (pcoms2[i] != \"A\" && pfirst == \"C\") {\n                pcoms2[i] = \"C\";\n            }\n\n            fixArc(p2, i);\n        }\n        fixM(p, p2, attrs, attrs2, i);\n        fixM(p2, p, attrs2, attrs, i);\n        var seg = p[i],\n            seg2 = p2 && p2[i],\n            seglen = seg.length,\n            seg2len = p2 && seg2.length;\n        attrs.x = seg[seglen - 2];\n        attrs.y = seg[seglen - 1];\n        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n        attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);\n        attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);\n        attrs2.x = p2 && seg2[seg2len - 2];\n        attrs2.y = p2 && seg2[seg2len - 1];\n    }\n\n    return p2 ? [p, p2] : p;\n}\n\n;\n\nfunction box(x, y, width, height) {\n    if (x == null) {\n        x = y = width = height = 0;\n    }\n    if (y == null) {\n        y = x.y;\n        width = x.width;\n        height = x.height;\n        x = x.x;\n    }\n    return {\n        x: x,\n        y: y,\n        w: width,\n        h: height,\n        cx: x + width / 2,\n        cy: y + height / 2\n    };\n}\n\n;\n\n// Returns bounding box of cubic bezier curve.\n// Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n// Original version: NISHIO Hirokazu\n// Modifications: https://github.com/timo22345\n\nfunction curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n    var tvalues = [],\n        bounds = [[], []],\n        a,\n        b,\n        c,\n        t,\n        t1,\n        t2,\n        b2ac,\n        sqrtb2ac;\n    for (var i = 0; i < 2; ++i) {\n        if (i == 0) {\n            b = 6 * x0 - 12 * x1 + 6 * x2;\n            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n            c = 3 * x1 - 3 * x0;\n        } else {\n            b = 6 * y0 - 12 * y1 + 6 * y2;\n            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n            c = 3 * y1 - 3 * y0;\n        }\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) < 1e-12) {\n                continue;\n            }\n            t = -c / b;\n            if (0 < t && t < 1) {\n                tvalues.push(t);\n            }\n            continue;\n        }\n        b2ac = b * b - 4 * c * a;\n        sqrtb2ac = Math.sqrt(b2ac);\n        if (b2ac < 0) {\n            continue;\n        }\n        t1 = (-b + sqrtb2ac) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            tvalues.push(t1);\n        }\n        t2 = (-b - sqrtb2ac) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            tvalues.push(t2);\n        }\n    }\n\n    var x,\n        y,\n        j = tvalues.length,\n        jlen = j,\n        mt;\n    while (j--) {\n        t = tvalues[j];\n        mt = 1 - t;\n        bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n        bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n    }\n\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    bounds[0].length = bounds[1].length = jlen + 2;\n\n    return {\n        min: { x: Math.min.apply(0, bounds[0]), y: Math.min.apply(0, bounds[1]) },\n        max: { x: Math.max.apply(0, bounds[0]), y: Math.max.apply(0, bounds[1]) }\n    };\n}\n\n;\n\nfunction curvePathBBox(path) {\n    var x = 0,\n        y = 0,\n        X = [],\n        Y = [],\n        p;\n    for (var i = 0, ii = path.length; i < ii; i++) {\n        p = path[i];\n        if (p[0] == \"M\") {\n            x = p[1];\n            y = p[2];\n            X.push(x);\n            Y.push(y);\n        } else {\n            var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n            X = X.concat(dim.min.x, dim.max.x);\n            Y = Y.concat(dim.min.y, dim.max.y);\n            x = p[5];\n            y = p[6];\n        }\n    }\n    var xmin = Math.min.apply(0, X),\n        ymin = Math.min.apply(0, Y),\n        xmax = Math.max.apply(0, X),\n        ymax = Math.max.apply(0, Y),\n        bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n\n    return bb;\n}\n\n;\n\nvar p2s = /,?([a-z]),?/gi;\n\nfunction path2string(path) {\n    return path.join(',').replace(p2s, \"$1\");\n}\n\n;\n\n/*\n * Styles\n */\n\nvar hsrg = { hs: 1, rg: 1 },\n    has = \"hasOwnProperty\",\n    colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\))\\s*$/i,\n    commaSpaces = new RegExp(\"[\" + spaces + \"]*,[\" + spaces + \"]*\");\n\n// Converts RGB values to a hex representation of the color\n// var rgb = function (r, g, b, o) {\n//   if (isFinite(o)) {\n//     var round = math.round;\n//     return \"rgba(\" + [round(r), round(g), round(b), +o.toFixed(2)] + \")\";\n//   }\n//   return \"#\" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);\n// };\n\nfunction rgbToString(rgb) {\n    var round = Math.round;\n    return \"rgba(\" + [round(rgb.r), round(rgb.g), round(rgb.b), +rgb.opacity.toFixed(2)] + \")\";\n}\n\n;\n\nfunction toHex(color) {\n    // Remind: to fix SSR problem issue#3\n    if (typeof window === \"undefined\") return;\n\n    var i = window.document.getElementsByTagName(\"head\")[0] || window.document.getElementsByTagName(\"svg\")[0],\n        red = \"rgb(255, 0, 0)\";\n    exports.toHex = toHex = function (color) {\n        if (color.toLowerCase() == \"red\") {\n            return red;\n        }\n        i.style.color = red;\n        i.style.color = color;\n        var out = window.document.defaultView.getComputedStyle(i, \"\").getPropertyValue(\"color\");\n        return out == red ? null : out;\n    };\n    return toHex(color);\n}\n\n;\n\nfunction packageRGB(r, g, b, o) {\n    r = Math.round(r * 255);\n    g = Math.round(g * 255);\n    b = Math.round(b * 255);\n    var rgb = {\n        r: r,\n        g: g,\n        b: b,\n        opacity: isFinite(o) ? o : 1\n    };\n    return rgb;\n}\n\n;\n\n// Converts HSB values to an RGB object\n\nfunction hsb2rgb(h, s, v, o) {\n    if (typeof h === typeof {} && \"h\" in h && \"s\" in h && \"b\" in h) {\n        v = h.b;\n        s = h.s;\n        h = h.h;\n        o = h.o;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = h % 360 / 60;\n    C = v * s;\n    X = C * (1 - Math.abs(h % 2 - 1));\n    R = G = B = v - C;\n\n    h = ~ ~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n}\n\n;\n\n// Converts HSL values to an RGB object\n\nfunction hsl2rgb(h, s, l, o) {\n    if (typeof h === typeof {} && \"h\" in h && \"s\" in h && \"l\" in h) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n    }\n    if (h > 1 || s > 1 || l > 1) {\n        h /= 360;\n        s /= 100;\n        l /= 100;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = h % 360 / 60;\n    C = 2 * s * (l < .5 ? l : 1 - l);\n    X = C * (1 - Math.abs(h % 2 - 1));\n    R = G = B = l - C / 2;\n\n    h = ~ ~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n}\n\n;\n\n// Parses color string as RGB object\n\nfunction getRGB(colour) {\n    if (!colour || !!((colour = String(colour)).indexOf(\"-\") + 1)) {\n        return { r: -1, g: -1, b: -1, opacity: -1, error: 1 };\n    }\n    if (colour == \"none\") {\n        return { r: -1, g: -1, b: -1, opacity: -1 };\n    }\n    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n    if (!colour) {\n        return { r: -1, g: -1, b: -1, opacity: -1, error: 1 };\n    }\n    var res,\n        red,\n        green,\n        blue,\n        opacity,\n        t,\n        values,\n        rgb = colour.match(colourRegExp);\n    if (rgb) {\n        if (rgb[2]) {\n            blue = parseInt(rgb[2].substring(5), 16);\n            green = parseInt(rgb[2].substring(3, 5), 16);\n            red = parseInt(rgb[2].substring(1, 3), 16);\n        }\n        if (rgb[3]) {\n            blue = parseInt((t = rgb[3].charAt(3)) + t, 16);\n            green = parseInt((t = rgb[3].charAt(2)) + t, 16);\n            red = parseInt((t = rgb[3].charAt(1)) + t, 16);\n        }\n        if (rgb[4]) {\n            values = rgb[4].split(commaSpaces);\n            red = parseFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red *= 2.55);\n            green = parseFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green *= 2.55);\n            blue = parseFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue *= 2.55);\n            rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = parseFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n        }\n        if (rgb[5]) {\n            values = rgb[5].split(commaSpaces);\n            red = parseFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = parseFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = parseFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = parseFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return hsb2rgb(red, green, blue, opacity);\n        }\n        if (rgb[6]) {\n            values = rgb[6].split(commaSpaces);\n            red = parseFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = parseFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = parseFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = parseFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return hsl2rgb(red, green, blue, opacity);\n        }\n        red = Math.min(Math.round(red), 255);\n        green = Math.min(Math.round(green), 255);\n        blue = Math.min(Math.round(blue), 255);\n        opacity = Math.min(Math.max(opacity, 0), 1);\n        rgb = { r: red, g: green, b: blue };\n        rgb.opacity = isFinite(opacity) ? opacity : 1;\n        return rgb;\n    }\n    return { r: -1, g: -1, b: -1, opacity: -1, error: 1 };\n}\n\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ZnLW1vcnBoL2xpYi91dGlscy9zdmdsaXRlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUNYLGtCQUFrQjtBQUNsQixXQUFXO0FBQ1gsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsbUJBQW1CLGdDQUFnQyxJQUFJLDRCQUE0QixJQUFJLGdDQUFnQyxJQUFJLGdDQUFnQztBQUMzSjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGNBQWM7QUFDZCx5QkFBeUI7QUFDekIsY0FBYztBQUNkLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBMEQ7QUFDNUUsbUJBQW1CLDBEQUEwRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0Msa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixtRUFBbUUsUUFBUTtBQUMzRSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUNBQXlDO0FBQ3pDO0FBQ0EsK0NBQStDOztBQUUvQyxnRUFBZ0U7QUFDaEU7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxrRUFBa0U7QUFDakYsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsbUNBQW1DLEVBQUUsWUFBWSxFQUFFO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXN2Zy1tb3JwaC9saWIvdXRpbHMvc3ZnbGl0ZS5qcz8wZWE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBVc2VmdWwgdGhpbmdzIGZyb20gQWRvYmUncyBTbmFwLnN2ZyBhZG9wdGVkIHRvIHRoZSBsaWJyYXJ5IG5lZWRzXG4gKi9cblxuLypcbiAqIFBhdGhzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFyc2VQYXRoU3RyaW5nID0gcGFyc2VQYXRoU3RyaW5nO1xuZXhwb3J0cy5jYXRtdWxsUm9tMmJlemllciA9IGNhdG11bGxSb20yYmV6aWVyO1xuZXhwb3J0cy5lbGxpcHNlUGF0aCA9IGVsbGlwc2VQYXRoO1xuZXhwb3J0cy5wYXRoVG9BYnNvbHV0ZSA9IHBhdGhUb0Fic29sdXRlO1xuZXhwb3J0cy5sMmMgPSBsMmM7XG5leHBvcnRzLnEyYyA9IHEyYztcbmV4cG9ydHMuYTJjID0gYTJjO1xuZXhwb3J0cy5wYXRoMmN1cnZlID0gcGF0aDJjdXJ2ZTtcbmV4cG9ydHMuYm94ID0gYm94O1xuZXhwb3J0cy5jdXJ2ZURpbSA9IGN1cnZlRGltO1xuZXhwb3J0cy5jdXJ2ZVBhdGhCQm94ID0gY3VydmVQYXRoQkJveDtcbmV4cG9ydHMucGF0aDJzdHJpbmcgPSBwYXRoMnN0cmluZztcbmV4cG9ydHMucmdiVG9TdHJpbmcgPSByZ2JUb1N0cmluZztcbmV4cG9ydHMudG9IZXggPSB0b0hleDtcbmV4cG9ydHMucGFja2FnZVJHQiA9IHBhY2thZ2VSR0I7XG5leHBvcnRzLmhzYjJyZ2IgPSBoc2IycmdiO1xuZXhwb3J0cy5oc2wycmdiID0gaHNsMnJnYjtcbmV4cG9ydHMuZ2V0UkdCID0gZ2V0UkdCO1xudmFyIHNwYWNlcyA9IFwiXFx0XFxuXFx1MDAwYlxcZlxcciDCoOGagOGgjuKAgOKAgeKAguKAg+KAhOKAheKAhuKAh+KAiOKAieKAiuKAr+KBn+OAgFxcdTIwMjhcXHUyMDI5XCI7XG52YXIgcGF0aENvbW1hbmQgPSBuZXcgUmVnRXhwKFwiKFthLXpdKVtcIiArIHNwYWNlcyArIFwiLF0qKCgtP1xcXFxkKlxcXFwuP1xcXFxkKig/OmVbXFxcXC0rXT9cXFxcZCspP1tcIiArIHNwYWNlcyArIFwiXSosP1tcIiArIHNwYWNlcyArIFwiXSopKylcIiwgXCJpZ1wiKTtcbnZhciBwYXRoVmFsdWVzID0gbmV3IFJlZ0V4cChcIigtP1xcXFxkKlxcXFwuP1xcXFxkKig/OmVbXFxcXC0rXT9cXFxcZCspPylbXCIgKyBzcGFjZXMgKyBcIl0qLD9bXCIgKyBzcGFjZXMgKyBcIl0qXCIsIFwiaWdcIik7XG5cbi8vIFBhcnNlcyBnaXZlbiBwYXRoIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwYXRoIHNlZ21lbnRzXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aFN0cmluZyhwYXRoU3RyaW5nKSB7XG4gICAgaWYgKCFwYXRoU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGF0aFN0cmluZyA9PT0gdHlwZW9mIFtdKSB7XG4gICAgICAgIHJldHVybiBwYXRoU3RyaW5nO1xuICAgIH1cbiAgICB2YXIgcGFyYW1Db3VudHMgPSB7IGE6IDcsIGM6IDYsIG86IDIsIGg6IDEsIGw6IDIsIG06IDIsIHI6IDQsIHE6IDQsIHM6IDQsIHQ6IDIsIHY6IDEsIHU6IDMsIHo6IDAgfTtcbiAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgU3RyaW5nKHBhdGhTdHJpbmcpLnJlcGxhY2UocGF0aENvbW1hbmQsIGZ1bmN0aW9uIHJlcGxhY2VQYXRoKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgbmFtZSA9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGwgPSBiO1xuICAgICAgICBjLnJlcGxhY2UocGF0aFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZUMoYSwgYikge1xuICAgICAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCgrYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJtXCIgJiYgcGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgMikpKTtcbiAgICAgICAgICAgIG5hbWUgPSBcImxcIjtcbiAgICAgICAgICAgIGwgPSBiID09PSBcIm1cIiA/IFwibFwiIDogXCJMXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09IFwib1wiICYmIHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChbbCwgcGFyYW1zWzBdXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09IFwiclwiKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2goW2xdLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChwYXJhbXMubGVuZ3RoID49IHBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtsXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCBwYXJhbUNvdW50c1tuYW1lXSkpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRhdGE7XG59XG5cbi8vIGh0dHA6Ly9zY2hlcGVycy5jYy9nZXR0aW5nLXRvLXRoZS1wb2ludFxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tMmJlemllcihjcnAsIHopIHtcbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgaUxlbiA9IGNycC5sZW5ndGg7XG4gICAgZm9yICg7IGlMZW4gLSAyICogIXogPiBpOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIHAgPSBbeyB4OiArY3JwW2kgLSAyXSwgeTogK2NycFtpIC0gMV0gfSwgeyB4OiArY3JwW2ldLCB5OiArY3JwW2kgKyAxXSB9LCB7IHg6ICtjcnBbaSArIDJdLCB5OiArY3JwW2kgKyAzXSB9LCB7IHg6ICtjcnBbaSArIDRdLCB5OiArY3JwW2kgKyA1XSB9XTtcbiAgICAgICAgaWYgKHopIHtcbiAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgIHBbMF0gPSB7IHg6ICtjcnBbaUxlbiAtIDJdLCB5OiArY3JwW2lMZW4gLSAxXSB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpTGVuIC0gNCA9PT0gaSkge1xuICAgICAgICAgICAgICAgIHBbM10gPSB7IHg6ICtjcnBbMF0sIHk6ICtjcnBbMV0gfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaUxlbiAtIDIgPT09IGkpIHtcbiAgICAgICAgICAgICAgICBwWzJdID0geyB4OiArY3JwWzBdLCB5OiArY3JwWzFdIH07XG4gICAgICAgICAgICAgICAgcFszXSA9IHsgeDogK2NycFsyXSwgeTogK2NycFszXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlMZW4gLSA0ID09PSBpKSB7XG4gICAgICAgICAgICAgICAgcFszXSA9IHBbMl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgcFswXSA9IHsgeDogK2NycFtpXSwgeTogK2NycFtpICsgMV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkLnB1c2goW1wiQ1wiLCAoLXBbMF0ueCArIDYgKiBwWzFdLnggKyBwWzJdLngpIC8gNiwgKC1wWzBdLnkgKyA2ICogcFsxXS55ICsgcFsyXS55KSAvIDYsIChwWzFdLnggKyA2ICogcFsyXS54IC0gcFszXS54KSAvIDYsIChwWzFdLnkgKyA2ICogcFsyXS55IC0gcFszXS55KSAvIDYsIHBbMl0ueCwgcFsyXS55XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59XG5cbmZ1bmN0aW9uIGVsbGlwc2VQYXRoKF94LCBfeSwgX3J4LCBfcnksIGEpIHtcbiAgICB2YXIgcnggPSBfcng7XG4gICAgdmFyIHJ5ID0gX3J5O1xuICAgIHZhciB4ID0gX3g7XG4gICAgdmFyIHkgPSBfeTtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChhID09PSBudWxsICYmIHJ5ID09PSBudWxsKSB7XG4gICAgICAgIHJ5ID0gcng7XG4gICAgfVxuICAgIHggPSAreDtcbiAgICB5ID0gK3k7XG4gICAgcnggPSArcng7XG4gICAgcnkgPSArcnk7XG4gICAgaWYgKGEgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJhZCA9IE1hdGguUEkgLyAxODA7XG4gICAgICAgIHZhciB4MSA9IHggKyByeCAqIE1hdGguY29zKC1yeSAqIHJhZCk7XG4gICAgICAgIHZhciB4MiA9IHggKyByeCAqIE1hdGguY29zKC1hICogcmFkKTtcbiAgICAgICAgdmFyIHkxID0geSArIHJ4ICogTWF0aC5zaW4oLXJ5ICogcmFkKTtcbiAgICAgICAgdmFyIHkyID0geSArIHJ4ICogTWF0aC5zaW4oLWEgKiByYWQpO1xuICAgICAgICByZXR1cm4gW1tcIk1cIiwgeDEsIHkxXSwgW1wiQVwiLCByeCwgcngsIDAsICsoYSAtIHJ5ID4gMTgwKSwgMCwgeDIsIHkyXV07XG4gICAgfVxuICAgIHJldHVybiBbW1wiTVwiLCB4LCB5XSwgW1wibVwiLCAwLCAtcnldLCBbXCJhXCIsIHJ4LCByeSwgMCwgMSwgMSwgMCwgMiAqIHJ5XSwgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIC0yICogcnldLCBbXCJ6XCJdXTtcbn1cblxuO1xuXG5mdW5jdGlvbiBwYXRoVG9BYnNvbHV0ZShwYXRoQXJyYXkpIHtcbiAgICBwYXRoQXJyYXkgPSBwYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcblxuICAgIGlmICghcGF0aEFycmF5IHx8ICFwYXRoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbW1wiTVwiLCAwLCAwXV07XG4gICAgfVxuICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBteCA9IDAsXG4gICAgICAgIG15ID0gMCxcbiAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICBwYTA7XG4gICAgaWYgKHBhdGhBcnJheVswXVswXSA9PSBcIk1cIikge1xuICAgICAgICB4ID0gK3BhdGhBcnJheVswXVsxXTtcbiAgICAgICAgeSA9ICtwYXRoQXJyYXlbMF1bMl07XG4gICAgICAgIG14ID0geDtcbiAgICAgICAgbXkgPSB5O1xuICAgICAgICBzdGFydCsrO1xuICAgICAgICByZXNbMF0gPSBbXCJNXCIsIHgsIHldO1xuICAgIH1cbiAgICB2YXIgY3J6ID0gcGF0aEFycmF5Lmxlbmd0aCA9PSAzICYmIHBhdGhBcnJheVswXVswXSA9PSBcIk1cIiAmJiBwYXRoQXJyYXlbMV1bMF0udG9VcHBlckNhc2UoKSA9PSBcIlJcIiAmJiBwYXRoQXJyYXlbMl1bMF0udG9VcHBlckNhc2UoKSA9PSBcIlpcIjtcbiAgICBmb3IgKHZhciByLCBwYSwgaSA9IHN0YXJ0LCBpaSA9IHBhdGhBcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHJlcy5wdXNoKHIgPSBbXSk7XG4gICAgICAgIHBhID0gcGF0aEFycmF5W2ldO1xuICAgICAgICBwYTAgPSBwYVswXTtcbiAgICAgICAgaWYgKHBhMCAhPSBwYTAudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgclswXSA9IHBhMC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChyWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgICAgICAgICAgclsxXSA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICByWzJdID0gcGFbMl07XG4gICAgICAgICAgICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICAgICAgICAgICAgcls0XSA9IHBhWzRdO1xuICAgICAgICAgICAgICAgICAgICByWzVdID0gcGFbNV07XG4gICAgICAgICAgICAgICAgICAgIHJbNl0gPSArcGFbNl0gKyB4O1xuICAgICAgICAgICAgICAgICAgICByWzddID0gK3BhWzddICsgeTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICAgICAgclsxXSA9ICtwYVsxXSArIHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiUlwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgZG90cyA9IFt4LCB5XS5jb25jYXQocGEuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMiwgamogPSBkb3RzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdHNbal0gPSArZG90c1tqXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzWysral0gPSArZG90c1tqXSArIHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGNhdG11bGxSb20yYmV6aWVyKGRvdHMsIGNyeikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiT1wiOlxuICAgICAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGRvdHMgPSBlbGxpcHNlUGF0aCh4LCB5LCBwYVsxXSwgcGFbMl0pO1xuICAgICAgICAgICAgICAgICAgICBkb3RzLnB1c2goZG90c1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZG90cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJVXCI6XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChlbGxpcHNlUGF0aCh4LCB5LCBwYVsxXSwgcGFbMl0sIHBhWzNdKSk7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBbXCJVXCJdLmNvbmNhdChyZXNbcmVzLmxlbmd0aCAtIDFdLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgICAgIG14ID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgbXkgPSArcGFbMl0gKyB5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDEsIGpqID0gcGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcltqXSA9ICtwYVtqXSArIChqICUgMiA/IHggOiB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhMCA9PSBcIlJcIikge1xuICAgICAgICAgICAgZG90cyA9IFt4LCB5XS5jb25jYXQocGEuc2xpY2UoMSkpO1xuICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChjYXRtdWxsUm9tMmJlemllcihkb3RzLCBjcnopKTtcbiAgICAgICAgICAgIHIgPSBbXCJSXCJdLmNvbmNhdChwYS5zbGljZSgtMikpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhMCA9PSBcIk9cIikge1xuICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgZG90cyA9IGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSk7XG4gICAgICAgICAgICBkb3RzLnB1c2goZG90c1swXSk7XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGRvdHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhMCA9PSBcIlVcIikge1xuICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChlbGxpcHNlUGF0aCh4LCB5LCBwYVsxXSwgcGFbMl0sIHBhWzNdKSk7XG4gICAgICAgICAgICByID0gW1wiVVwiXS5jb25jYXQocmVzW3Jlcy5sZW5ndGggLSAxXS5zbGljZSgtMikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gcGEubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICAgIHJba10gPSBwYVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYTAgPSBwYTAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHBhMCAhPSBcIk9cIikge1xuICAgICAgICAgICAgc3dpdGNoIChyWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgICAgICAgICAgeCA9ICtteDtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICtteTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgeCA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgIHkgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICBteCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgbXkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgeCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbjtcblxuZnVuY3Rpb24gbDJjKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbn1cblxuO1xuXG5mdW5jdGlvbiBxMmMoeDEsIHkxLCBheCwgYXksIHgyLCB5Mikge1xuICAgIHZhciBfMTMgPSAxIC8gMyxcbiAgICAgICAgXzIzID0gMiAvIDM7XG4gICAgcmV0dXJuIFtfMTMgKiB4MSArIF8yMyAqIGF4LCBfMTMgKiB5MSArIF8yMyAqIGF5LCBfMTMgKiB4MiArIF8yMyAqIGF4LCBfMTMgKiB5MiArIF8yMyAqIGF5LCB4MiwgeTJdO1xufVxuXG47XG5cbmZ1bmN0aW9uIGEyYyh4MSwgeTEsIHJ4LCByeSwgYW5nbGUsIGxhcmdlX2FyY19mbGFnLCBzd2VlcF9mbGFnLCB4MiwgeTIsIHJlY3Vyc2l2ZSkge1xuICAgIC8vIGZvciBtb3JlIGluZm9ybWF0aW9uIG9mIHdoZXJlIHRoaXMgbWF0aCBjYW1lIGZyb20gdmlzaXQ6XG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgdmFyIF8xMjAgPSBNYXRoLlBJICogMTIwIC8gMTgwLFxuICAgICAgICByYWQgPSBNYXRoLlBJIC8gMTgwICogKCthbmdsZSB8fCAwKSxcbiAgICAgICAgcmVzID0gW10sXG4gICAgICAgIHh5LFxuICAgICAgICByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoeCwgeSwgcmFkKSB7XG4gICAgICAgIHZhciBYID0geCAqIE1hdGguY29zKHJhZCkgLSB5ICogTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgICAgIFkgPSB4ICogTWF0aC5zaW4ocmFkKSArIHkgKiBNYXRoLmNvcyhyYWQpO1xuICAgICAgICByZXR1cm4geyB4OiBYLCB5OiBZIH07XG4gICAgfTtcbiAgICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgICAgICB4eSA9IHJvdGF0ZSh4MSwgeTEsIC1yYWQpO1xuICAgICAgICB4MSA9IHh5Lng7XG4gICAgICAgIHkxID0geHkueTtcbiAgICAgICAgeHkgPSByb3RhdGUoeDIsIHkyLCAtcmFkKTtcbiAgICAgICAgeDIgPSB4eS54O1xuICAgICAgICB5MiA9IHh5Lnk7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oTWF0aC5QSSAvIDE4MCAqIGFuZ2xlKSxcbiAgICAgICAgICAgIHggPSAoeDEgLSB4MikgLyAyLFxuICAgICAgICAgICAgeSA9ICh5MSAtIHkyKSAvIDI7XG4gICAgICAgIHZhciBoID0geCAqIHggLyAocnggKiByeCkgKyB5ICogeSAvIChyeSAqIHJ5KTtcbiAgICAgICAgaWYgKGggPiAxKSB7XG4gICAgICAgICAgICBoID0gTWF0aC5zcXJ0KGgpO1xuICAgICAgICAgICAgcnggPSBoICogcng7XG4gICAgICAgICAgICByeSA9IGggKiByeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcngyID0gcnggKiByeCxcbiAgICAgICAgICAgIHJ5MiA9IHJ5ICogcnksXG4gICAgICAgICAgICBrID0gKGxhcmdlX2FyY19mbGFnID09IHN3ZWVwX2ZsYWcgPyAtMSA6IDEpICogTWF0aC5zcXJ0KE1hdGguYWJzKChyeDIgKiByeTIgLSByeDIgKiB5ICogeSAtIHJ5MiAqIHggKiB4KSAvIChyeDIgKiB5ICogeSArIHJ5MiAqIHggKiB4KSkpLFxuICAgICAgICAgICAgY3ggPSBrICogcnggKiB5IC8gcnkgKyAoeDEgKyB4MikgLyAyLFxuICAgICAgICAgICAgY3kgPSBrICogLXJ5ICogeCAvIHJ4ICsgKHkxICsgeTIpIC8gMixcbiAgICAgICAgICAgIGYxID0gTWF0aC5hc2luKCgoeTEgLSBjeSkgLyByeSkudG9GaXhlZCg5KSksXG4gICAgICAgICAgICBmMiA9IE1hdGguYXNpbigoKHkyIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpO1xuXG4gICAgICAgIGYxID0geDEgPCBjeCA/IE1hdGguUEkgLSBmMSA6IGYxO1xuICAgICAgICBmMiA9IHgyIDwgY3ggPyBNYXRoLlBJIC0gZjIgOiBmMjtcbiAgICAgICAgZjEgPCAwICYmIChmMSA9IE1hdGguUEkgKiAyICsgZjEpO1xuICAgICAgICBmMiA8IDAgJiYgKGYyID0gTWF0aC5QSSAqIDIgKyBmMik7XG4gICAgICAgIGlmIChzd2VlcF9mbGFnICYmIGYxID4gZjIpIHtcbiAgICAgICAgICAgIGYxID0gZjEgLSBNYXRoLlBJICogMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSkge1xuICAgICAgICAgICAgZjIgPSBmMiAtIE1hdGguUEkgKiAyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZjEgPSByZWN1cnNpdmVbMF07XG4gICAgICAgIGYyID0gcmVjdXJzaXZlWzFdO1xuICAgICAgICBjeCA9IHJlY3Vyc2l2ZVsyXTtcbiAgICAgICAgY3kgPSByZWN1cnNpdmVbM107XG4gICAgfVxuICAgIHZhciBkZiA9IGYyIC0gZjE7XG4gICAgaWYgKE1hdGguYWJzKGRmKSA+IF8xMjApIHtcbiAgICAgICAgdmFyIGYyb2xkID0gZjIsXG4gICAgICAgICAgICB4Mm9sZCA9IHgyLFxuICAgICAgICAgICAgeTJvbGQgPSB5MjtcbiAgICAgICAgZjIgPSBmMSArIF8xMjAgKiAoc3dlZXBfZmxhZyAmJiBmMiA+IGYxID8gMSA6IC0xKTtcbiAgICAgICAgeDIgPSBjeCArIHJ4ICogTWF0aC5jb3MoZjIpO1xuICAgICAgICB5MiA9IGN5ICsgcnkgKiBNYXRoLnNpbihmMik7XG4gICAgICAgIHJlcyA9IGEyYyh4MiwgeTIsIHJ4LCByeSwgYW5nbGUsIDAsIHN3ZWVwX2ZsYWcsIHgyb2xkLCB5Mm9sZCwgW2YyLCBmMm9sZCwgY3gsIGN5XSk7XG4gICAgfVxuICAgIGRmID0gZjIgLSBmMTtcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyhmMSksXG4gICAgICAgIHMxID0gTWF0aC5zaW4oZjEpLFxuICAgICAgICBjMiA9IE1hdGguY29zKGYyKSxcbiAgICAgICAgczIgPSBNYXRoLnNpbihmMiksXG4gICAgICAgIHQgPSBNYXRoLnRhbihkZiAvIDQpLFxuICAgICAgICBoeCA9IDQgLyAzICogcnggKiB0LFxuICAgICAgICBoeSA9IDQgLyAzICogcnkgKiB0LFxuICAgICAgICBtMSA9IFt4MSwgeTFdLFxuICAgICAgICBtMiA9IFt4MSArIGh4ICogczEsIHkxIC0gaHkgKiBjMV0sXG4gICAgICAgIG0zID0gW3gyICsgaHggKiBzMiwgeTIgLSBoeSAqIGMyXSxcbiAgICAgICAgbTQgPSBbeDIsIHkyXTtcbiAgICBtMlswXSA9IDIgKiBtMVswXSAtIG0yWzBdO1xuICAgIG0yWzFdID0gMiAqIG0xWzFdIC0gbTJbMV07XG4gICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICByZXR1cm4gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IFttMiwgbTMsIG00XS5jb25jYXQocmVzKS5qb2luKCkuc3BsaXQoXCIsXCIpO1xuICAgICAgICB2YXIgbmV3cmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHJlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBuZXdyZXNbaV0gPSBpICUgMiA/IHJvdGF0ZShyZXNbaSAtIDFdLCByZXNbaV0sIHJhZCkueSA6IHJvdGF0ZShyZXNbaV0sIHJlc1tpICsgMV0sIHJhZCkueDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3cmVzO1xuICAgIH1cbn1cblxuO1xuXG5mdW5jdGlvbiBwYXRoMmN1cnZlKHBhdGgsIHBhdGgyKSB7XG4gICAgdmFyIHAgPSBwYXRoVG9BYnNvbHV0ZShwYXRoKSxcbiAgICAgICAgcDIgPSBwYXRoMiAmJiBwYXRoVG9BYnNvbHV0ZShwYXRoMiksXG4gICAgICAgIGF0dHJzID0geyB4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbCB9LFxuICAgICAgICBhdHRyczIgPSB7IHg6IDAsIHk6IDAsIGJ4OiAwLCBieTogMCwgWDogMCwgWTogMCwgcXg6IG51bGwsIHF5OiBudWxsIH0sXG4gICAgICAgIHByb2Nlc3NQYXRoID0gZnVuY3Rpb24gcHJvY2Vzc1BhdGgocGF0aCwgZCwgcGNvbSkge1xuICAgICAgICB2YXIgbngsIG55O1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXCJDXCIsIGQueCwgZC55LCBkLngsIGQueSwgZC54LCBkLnldO1xuICAgICAgICB9XG4gICAgICAgICEocGF0aFswXSBpbiB7IFQ6IDEsIFE6IDEgfSkgJiYgKGQucXggPSBkLnF5ID0gbnVsbCk7XG4gICAgICAgIHN3aXRjaCAocGF0aFswXSkge1xuICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICBkLlggPSBwYXRoWzFdO1xuICAgICAgICAgICAgICAgIGQuWSA9IHBhdGhbMl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChhMmMuYXBwbHkoMCwgW2QueCwgZC55XS5jb25jYXQocGF0aC5zbGljZSgxKSkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBjb20gPT0gXCJDXCIgfHwgcGNvbSA9PSBcIlNcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBcIlNcIiBjYXNlIHdlIGhhdmUgdG8gdGFrZSBpbnRvIGFjY291bnQsIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIGlzIEMvUy5cbiAgICAgICAgICAgICAgICAgICAgbnggPSBkLnggKiAyIC0gZC5ieDsgLy8gQW5kIHJlZmxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgIG55ID0gZC55ICogMiAtIGQuYnk7IC8vIGNvbW1hbmQncyBjb250cm9sIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBzb21lIGVsc2Ugb3Igbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbnggPSBkLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBueSA9IGQueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCIsIG54LCBueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlRcIjpcbiAgICAgICAgICAgICAgICBpZiAocGNvbSA9PSBcIlFcIiB8fCBwY29tID09IFwiVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIFwiVFwiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgUS9ULlxuICAgICAgICAgICAgICAgICAgICBkLnF4ID0gZC54ICogMiAtIGQucXg7IC8vIEFuZCBtYWtlIGEgcmVmbGVjdGlvbiBzaW1pbGFyXG4gICAgICAgICAgICAgICAgICAgIGQucXkgPSBkLnkgKiAyIC0gZC5xeTsgLy8gdG8gY2FzZSBcIlNcIi5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igc29tZXRoaW5nIGVsc2Ugb3Igbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBkLnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQocTJjKGQueCwgZC55LCBkLnF4LCBkLnF5LCBwYXRoWzFdLCBwYXRoWzJdKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUVwiOlxuICAgICAgICAgICAgICAgIGQucXggPSBwYXRoWzFdO1xuICAgICAgICAgICAgICAgIGQucXkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChxMmMoZC54LCBkLnksIHBhdGhbMV0sIHBhdGhbMl0sIHBhdGhbM10sIHBhdGhbNF0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGwyYyhkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBwYXRoWzFdLCBkLnkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGwyYyhkLngsIGQueSwgZC54LCBwYXRoWzFdKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChsMmMoZC54LCBkLnksIGQuWCwgZC5ZKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcbiAgICAgICAgZml4QXJjID0gZnVuY3Rpb24gZml4QXJjKHBwLCBpKSB7XG4gICAgICAgIGlmIChwcFtpXS5sZW5ndGggPiA3KSB7XG4gICAgICAgICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIHBpID0gcHBbaV07XG4gICAgICAgICAgICB3aGlsZSAocGkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGNvbXMxW2ldID0gXCJBXCI7IC8vIGlmIGNyZWF0ZWQgbXVsdGlwbGUgQzpzLCB0aGVpciBvcmlnaW5hbCBzZWcgaXMgc2F2ZWRcbiAgICAgICAgICAgICAgICBwMiAmJiAocGNvbXMyW2ldID0gXCJBXCIpOyAvLyB0aGUgc2FtZSBhcyBhYm92ZVxuICAgICAgICAgICAgICAgIHBwLnNwbGljZShpKyssIDAsIFtcIkNcIl0uY29uY2F0KHBpLnNwbGljZSgwLCA2KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaWkgPSBNYXRoLm1heChwLmxlbmd0aCwgcDIgJiYgcDIubGVuZ3RoIHx8IDApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAgICAgZml4TSA9IGZ1bmN0aW9uIGZpeE0ocGF0aDEsIHBhdGgyLCBhMSwgYTIsIGkpIHtcbiAgICAgICAgaWYgKHBhdGgxICYmIHBhdGgyICYmIHBhdGgxW2ldWzBdID09IFwiTVwiICYmIHBhdGgyW2ldWzBdICE9IFwiTVwiKSB7XG4gICAgICAgICAgICBwYXRoMi5zcGxpY2UoaSwgMCwgW1wiTVwiLCBhMi54LCBhMi55XSk7XG4gICAgICAgICAgICBhMS5ieCA9IDA7XG4gICAgICAgICAgICBhMS5ieSA9IDA7XG4gICAgICAgICAgICBhMS54ID0gcGF0aDFbaV1bMV07XG4gICAgICAgICAgICBhMS55ID0gcGF0aDFbaV1bMl07XG4gICAgICAgICAgICBpaSA9IE1hdGgubWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICAgICBwY29tczEgPSBbXSxcbiAgICAgICAgLy8gcGF0aCBjb21tYW5kcyBvZiBvcmlnaW5hbCBwYXRoIHBcbiAgICBwY29tczIgPSBbXSxcbiAgICAgICAgLy8gcGF0aCBjb21tYW5kcyBvZiBvcmlnaW5hbCBwYXRoIHAyXG4gICAgcGZpcnN0ID0gXCJcIixcbiAgICAgICAgLy8gdGVtcG9yYXJ5IGhvbGRlciBmb3Igb3JpZ2luYWwgcGF0aCBjb21tYW5kXG4gICAgcGNvbSA9IFwiXCI7IC8vIGhvbGRlciBmb3IgcHJldmlvdXMgcGF0aCBjb21tYW5kIG9mIG9yaWdpbmFsIHBhdGhcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBNYXRoLm1heChwLmxlbmd0aCwgcDIgJiYgcDIubGVuZ3RoIHx8IDApOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBwW2ldICYmIChwZmlyc3QgPSBwW2ldWzBdKTsgLy8gc2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuXG4gICAgICAgIGlmIChwZmlyc3QgIT0gXCJDXCIpIHtcbiAgICAgICAgICAgIC8vIEMgaXMgbm90IHNhdmVkIHlldCwgYmVjYXVzZSBpdCBtYXkgYmUgcmVzdWx0IG9mIGNvbnZlcnNpb25cbiAgICAgICAgICAgIHBjb21zMVtpXSA9IHBmaXJzdDsgLy8gU2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuICAgICAgICAgICAgaSAmJiAocGNvbSA9IHBjb21zMVtpIC0gMV0pOyAvLyBHZXQgcHJldmlvdXMgcGF0aCBjb21tYW5kIHBjb21cbiAgICAgICAgfVxuICAgICAgICBwW2ldID0gcHJvY2Vzc1BhdGgocFtpXSwgYXR0cnMsIHBjb20pOyAvLyBQcmV2aW91cyBwYXRoIGNvbW1hbmQgaXMgaW5wdXR0ZWQgdG8gcHJvY2Vzc1BhdGhcblxuICAgICAgICBpZiAocGNvbXMxW2ldICE9IFwiQVwiICYmIHBmaXJzdCA9PSBcIkNcIikgcGNvbXMxW2ldID0gXCJDXCI7IC8vIEEgaXMgdGhlIG9ubHkgY29tbWFuZFxuICAgICAgICAvLyB3aGljaCBtYXkgcHJvZHVjZSBtdWx0aXBsZSBDOnNcbiAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCBDIGlzIGFsc28gQyBpbiBvcmlnaW5hbCBwYXRoXG5cbiAgICAgICAgZml4QXJjKHAsIGkpOyAvLyBmaXhBcmMgYWRkcyBhbHNvIHRoZSByaWdodCBhbW91bnQgb2YgQTpzIHRvIHBjb21zMVxuXG4gICAgICAgIGlmIChwMikge1xuICAgICAgICAgICAgLy8gdGhlIHNhbWUgcHJvY2VkdXJlcyBpcyBkb25lIHRvIHAyXG4gICAgICAgICAgICBwMltpXSAmJiAocGZpcnN0ID0gcDJbaV1bMF0pO1xuICAgICAgICAgICAgaWYgKHBmaXJzdCAhPSBcIkNcIikge1xuICAgICAgICAgICAgICAgIHBjb21zMltpXSA9IHBmaXJzdDtcbiAgICAgICAgICAgICAgICBpICYmIChwY29tID0gcGNvbXMyW2kgLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwMltpXSA9IHByb2Nlc3NQYXRoKHAyW2ldLCBhdHRyczIsIHBjb20pO1xuXG4gICAgICAgICAgICBpZiAocGNvbXMyW2ldICE9IFwiQVwiICYmIHBmaXJzdCA9PSBcIkNcIikge1xuICAgICAgICAgICAgICAgIHBjb21zMltpXSA9IFwiQ1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXhBcmMocDIsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpeE0ocCwgcDIsIGF0dHJzLCBhdHRyczIsIGkpO1xuICAgICAgICBmaXhNKHAyLCBwLCBhdHRyczIsIGF0dHJzLCBpKTtcbiAgICAgICAgdmFyIHNlZyA9IHBbaV0sXG4gICAgICAgICAgICBzZWcyID0gcDIgJiYgcDJbaV0sXG4gICAgICAgICAgICBzZWdsZW4gPSBzZWcubGVuZ3RoLFxuICAgICAgICAgICAgc2VnMmxlbiA9IHAyICYmIHNlZzIubGVuZ3RoO1xuICAgICAgICBhdHRycy54ID0gc2VnW3NlZ2xlbiAtIDJdO1xuICAgICAgICBhdHRycy55ID0gc2VnW3NlZ2xlbiAtIDFdO1xuICAgICAgICBhdHRycy5ieCA9IHBhcnNlRmxvYXQoc2VnW3NlZ2xlbiAtIDRdKSB8fCBhdHRycy54O1xuICAgICAgICBhdHRycy5ieSA9IHBhcnNlRmxvYXQoc2VnW3NlZ2xlbiAtIDNdKSB8fCBhdHRycy55O1xuICAgICAgICBhdHRyczIuYnggPSBwMiAmJiAocGFyc2VGbG9hdChzZWcyW3NlZzJsZW4gLSA0XSkgfHwgYXR0cnMyLngpO1xuICAgICAgICBhdHRyczIuYnkgPSBwMiAmJiAocGFyc2VGbG9hdChzZWcyW3NlZzJsZW4gLSAzXSkgfHwgYXR0cnMyLnkpO1xuICAgICAgICBhdHRyczIueCA9IHAyICYmIHNlZzJbc2VnMmxlbiAtIDJdO1xuICAgICAgICBhdHRyczIueSA9IHAyICYmIHNlZzJbc2VnMmxlbiAtIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBwMiA/IFtwLCBwMl0gOiBwO1xufVxuXG47XG5cbmZ1bmN0aW9uIGJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICB4ID0geSA9IHdpZHRoID0gaGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICB5ID0geC55O1xuICAgICAgICB3aWR0aCA9IHgud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICB4ID0geC54O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgaDogaGVpZ2h0LFxuICAgICAgICBjeDogeCArIHdpZHRoIC8gMixcbiAgICAgICAgY3k6IHkgKyBoZWlnaHQgLyAyXG4gICAgfTtcbn1cblxuO1xuXG4vLyBSZXR1cm5zIGJvdW5kaW5nIGJveCBvZiBjdWJpYyBiZXppZXIgY3VydmUuXG4vLyBTb3VyY2U6IGh0dHA6Ly9ibG9nLmhhY2tlcnMtY2FmZS5uZXQvMjAwOS8wNi9ob3ctdG8tY2FsY3VsYXRlLWJlemllci1jdXJ2ZXMtYm91bmRpbmcuaHRtbFxuLy8gT3JpZ2luYWwgdmVyc2lvbjogTklTSElPIEhpcm9rYXp1XG4vLyBNb2RpZmljYXRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vdGltbzIyMzQ1XG5cbmZ1bmN0aW9uIGN1cnZlRGltKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciB0dmFsdWVzID0gW10sXG4gICAgICAgIGJvdW5kcyA9IFtbXSwgW11dLFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBjLFxuICAgICAgICB0LFxuICAgICAgICB0MSxcbiAgICAgICAgdDIsXG4gICAgICAgIGIyYWMsXG4gICAgICAgIHNxcnRiMmFjO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgICAgICAgICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgICAgICAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgICBzcXJ0YjJhYyA9IE1hdGguc3FydChiMmFjKTtcbiAgICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgICB9XG4gICAgICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeCxcbiAgICAgICAgeSxcbiAgICAgICAgaiA9IHR2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBqbGVuID0gaixcbiAgICAgICAgbXQ7XG4gICAgd2hpbGUgKGotLSkge1xuICAgICAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICAgICAgbXQgPSAxIC0gdDtcbiAgICAgICAgYm91bmRzWzBdW2pdID0gbXQgKiBtdCAqIG10ICogeDAgKyAzICogbXQgKiBtdCAqIHQgKiB4MSArIDMgKiBtdCAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICAgICAgYm91bmRzWzFdW2pdID0gbXQgKiBtdCAqIG10ICogeTAgKyAzICogbXQgKiBtdCAqIHQgKiB5MSArIDMgKiBtdCAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgICB9XG5cbiAgICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICAgIGJvdW5kc1swXS5sZW5ndGggPSBib3VuZHNbMV0ubGVuZ3RoID0gamxlbiArIDI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHsgeDogTWF0aC5taW4uYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogTWF0aC5taW4uYXBwbHkoMCwgYm91bmRzWzFdKSB9LFxuICAgICAgICBtYXg6IHsgeDogTWF0aC5tYXguYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogTWF0aC5tYXguYXBwbHkoMCwgYm91bmRzWzFdKSB9XG4gICAgfTtcbn1cblxuO1xuXG5mdW5jdGlvbiBjdXJ2ZVBhdGhCQm94KHBhdGgpIHtcbiAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBYID0gW10sXG4gICAgICAgIFkgPSBbXSxcbiAgICAgICAgcDtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXRoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgcCA9IHBhdGhbaV07XG4gICAgICAgIGlmIChwWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICB4ID0gcFsxXTtcbiAgICAgICAgICAgIHkgPSBwWzJdO1xuICAgICAgICAgICAgWC5wdXNoKHgpO1xuICAgICAgICAgICAgWS5wdXNoKHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpbSA9IGN1cnZlRGltKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgWCA9IFguY29uY2F0KGRpbS5taW4ueCwgZGltLm1heC54KTtcbiAgICAgICAgICAgIFkgPSBZLmNvbmNhdChkaW0ubWluLnksIGRpbS5tYXgueSk7XG4gICAgICAgICAgICB4ID0gcFs1XTtcbiAgICAgICAgICAgIHkgPSBwWzZdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB4bWluID0gTWF0aC5taW4uYXBwbHkoMCwgWCksXG4gICAgICAgIHltaW4gPSBNYXRoLm1pbi5hcHBseSgwLCBZKSxcbiAgICAgICAgeG1heCA9IE1hdGgubWF4LmFwcGx5KDAsIFgpLFxuICAgICAgICB5bWF4ID0gTWF0aC5tYXguYXBwbHkoMCwgWSksXG4gICAgICAgIGJiID0gYm94KHhtaW4sIHltaW4sIHhtYXggLSB4bWluLCB5bWF4IC0geW1pbik7XG5cbiAgICByZXR1cm4gYmI7XG59XG5cbjtcblxudmFyIHAycyA9IC8sPyhbYS16XSksPy9naTtcblxuZnVuY3Rpb24gcGF0aDJzdHJpbmcocGF0aCkge1xuICAgIHJldHVybiBwYXRoLmpvaW4oJywnKS5yZXBsYWNlKHAycywgXCIkMVwiKTtcbn1cblxuO1xuXG4vKlxuICogU3R5bGVzXG4gKi9cblxudmFyIGhzcmcgPSB7IGhzOiAxLCByZzogMSB9LFxuICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICBjb2xvdXJSZWdFeHAgPSAvXlxccyooKCNbYS1mXFxkXXs2fSl8KCNbYS1mXFxkXXszfSl8cmdiYT9cXChcXHMqKFtcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSslPyg/OlxccyosXFxzKltcXGRcXC5dKyU/KT8pXFxzKlxcKXxoc2JhP1xcKFxccyooW1xcZFxcLl0rKD86ZGVnfFxceGIwfCUpP1xccyosXFxzKltcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rKD86JT9cXHMqLFxccypbXFxkXFwuXSspPyU/KVxccypcXCl8aHNsYT9cXChcXHMqKFtcXGRcXC5dKyg/OmRlZ3xcXHhiMHwlKT9cXHMqLFxccypbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyg/OiU/XFxzKixcXHMqW1xcZFxcLl0rKT8lPylcXHMqXFwpKVxccyokL2ksXG4gICAgY29tbWFTcGFjZXMgPSBuZXcgUmVnRXhwKFwiW1wiICsgc3BhY2VzICsgXCJdKixbXCIgKyBzcGFjZXMgKyBcIl0qXCIpO1xuXG4vLyBDb252ZXJ0cyBSR0IgdmFsdWVzIHRvIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuLy8gdmFyIHJnYiA9IGZ1bmN0aW9uIChyLCBnLCBiLCBvKSB7XG4vLyAgIGlmIChpc0Zpbml0ZShvKSkge1xuLy8gICAgIHZhciByb3VuZCA9IG1hdGgucm91bmQ7XG4vLyAgICAgcmV0dXJuIFwicmdiYShcIiArIFtyb3VuZChyKSwgcm91bmQoZyksIHJvdW5kKGIpLCArby50b0ZpeGVkKDIpXSArIFwiKVwiO1xuLy8gICB9XG4vLyAgIHJldHVybiBcIiNcIiArICgxNjc3NzIxNiB8IGIgfCAoZyA8PCA4KSB8IChyIDw8IDE2KSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuLy8gfTtcblxuZnVuY3Rpb24gcmdiVG9TdHJpbmcocmdiKSB7XG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICByZXR1cm4gXCJyZ2JhKFwiICsgW3JvdW5kKHJnYi5yKSwgcm91bmQocmdiLmcpLCByb3VuZChyZ2IuYiksICtyZ2Iub3BhY2l0eS50b0ZpeGVkKDIpXSArIFwiKVwiO1xufVxuXG47XG5cbmZ1bmN0aW9uIHRvSGV4KGNvbG9yKSB7XG4gICAgLy8gUmVtaW5kOiB0byBmaXggU1NSIHByb2JsZW0gaXNzdWUjM1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG5cbiAgICB2YXIgaSA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0gfHwgd2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdLFxuICAgICAgICByZWQgPSBcInJnYigyNTUsIDAsIDApXCI7XG4gICAgZXhwb3J0cy50b0hleCA9IHRvSGV4ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmIChjb2xvci50b0xvd2VyQ2FzZSgpID09IFwicmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IHJlZDtcbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgICAgICB2YXIgb3V0ID0gd2luZG93LmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoaSwgXCJcIikuZ2V0UHJvcGVydHlWYWx1ZShcImNvbG9yXCIpO1xuICAgICAgICByZXR1cm4gb3V0ID09IHJlZCA/IG51bGwgOiBvdXQ7XG4gICAgfTtcbiAgICByZXR1cm4gdG9IZXgoY29sb3IpO1xufVxuXG47XG5cbmZ1bmN0aW9uIHBhY2thZ2VSR0IociwgZywgYiwgbykge1xuICAgIHIgPSBNYXRoLnJvdW5kKHIgKiAyNTUpO1xuICAgIGcgPSBNYXRoLnJvdW5kKGcgKiAyNTUpO1xuICAgIGIgPSBNYXRoLnJvdW5kKGIgKiAyNTUpO1xuICAgIHZhciByZ2IgPSB7XG4gICAgICAgIHI6IHIsXG4gICAgICAgIGc6IGcsXG4gICAgICAgIGI6IGIsXG4gICAgICAgIG9wYWNpdHk6IGlzRmluaXRlKG8pID8gbyA6IDFcbiAgICB9O1xuICAgIHJldHVybiByZ2I7XG59XG5cbjtcblxuLy8gQ29udmVydHMgSFNCIHZhbHVlcyB0byBhbiBSR0Igb2JqZWN0XG5cbmZ1bmN0aW9uIGhzYjJyZ2IoaCwgcywgdiwgbykge1xuICAgIGlmICh0eXBlb2YgaCA9PT0gdHlwZW9mIHt9ICYmIFwiaFwiIGluIGggJiYgXCJzXCIgaW4gaCAmJiBcImJcIiBpbiBoKSB7XG4gICAgICAgIHYgPSBoLmI7XG4gICAgICAgIHMgPSBoLnM7XG4gICAgICAgIGggPSBoLmg7XG4gICAgICAgIG8gPSBoLm87XG4gICAgfVxuICAgIGggKj0gMzYwO1xuICAgIHZhciBSLCBHLCBCLCBYLCBDO1xuICAgIGggPSBoICUgMzYwIC8gNjA7XG4gICAgQyA9IHYgKiBzO1xuICAgIFggPSBDICogKDEgLSBNYXRoLmFicyhoICUgMiAtIDEpKTtcbiAgICBSID0gRyA9IEIgPSB2IC0gQztcblxuICAgIGggPSB+IH5oO1xuICAgIFIgKz0gW0MsIFgsIDAsIDAsIFgsIENdW2hdO1xuICAgIEcgKz0gW1gsIEMsIEMsIFgsIDAsIDBdW2hdO1xuICAgIEIgKz0gWzAsIDAsIFgsIEMsIEMsIFhdW2hdO1xuICAgIHJldHVybiBwYWNrYWdlUkdCKFIsIEcsIEIsIG8pO1xufVxuXG47XG5cbi8vIENvbnZlcnRzIEhTTCB2YWx1ZXMgdG8gYW4gUkdCIG9iamVjdFxuXG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwsIG8pIHtcbiAgICBpZiAodHlwZW9mIGggPT09IHR5cGVvZiB7fSAmJiBcImhcIiBpbiBoICYmIFwic1wiIGluIGggJiYgXCJsXCIgaW4gaCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBzID0gaC5zO1xuICAgICAgICBoID0gaC5oO1xuICAgIH1cbiAgICBpZiAoaCA+IDEgfHwgcyA+IDEgfHwgbCA+IDEpIHtcbiAgICAgICAgaCAvPSAzNjA7XG4gICAgICAgIHMgLz0gMTAwO1xuICAgICAgICBsIC89IDEwMDtcbiAgICB9XG4gICAgaCAqPSAzNjA7XG4gICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgaCA9IGggJSAzNjAgLyA2MDtcbiAgICBDID0gMiAqIHMgKiAobCA8IC41ID8gbCA6IDEgLSBsKTtcbiAgICBYID0gQyAqICgxIC0gTWF0aC5hYnMoaCAlIDIgLSAxKSk7XG4gICAgUiA9IEcgPSBCID0gbCAtIEMgLyAyO1xuXG4gICAgaCA9IH4gfmg7XG4gICAgUiArPSBbQywgWCwgMCwgMCwgWCwgQ11baF07XG4gICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgQiArPSBbMCwgMCwgWCwgQywgQywgWF1baF07XG4gICAgcmV0dXJuIHBhY2thZ2VSR0IoUiwgRywgQiwgbyk7XG59XG5cbjtcblxuLy8gUGFyc2VzIGNvbG9yIHN0cmluZyBhcyBSR0Igb2JqZWN0XG5cbmZ1bmN0aW9uIGdldFJHQihjb2xvdXIpIHtcbiAgICBpZiAoIWNvbG91ciB8fCAhISgoY29sb3VyID0gU3RyaW5nKGNvbG91cikpLmluZGV4T2YoXCItXCIpICsgMSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogLTEsIGc6IC0xLCBiOiAtMSwgb3BhY2l0eTogLTEsIGVycm9yOiAxIH07XG4gICAgfVxuICAgIGlmIChjb2xvdXIgPT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogLTEsIGc6IC0xLCBiOiAtMSwgb3BhY2l0eTogLTEgfTtcbiAgICB9XG4gICAgIShoc3JnW2hhc10oY29sb3VyLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsIDIpKSB8fCBjb2xvdXIuY2hhckF0KCkgPT0gXCIjXCIpICYmIChjb2xvdXIgPSB0b0hleChjb2xvdXIpKTtcbiAgICBpZiAoIWNvbG91cikge1xuICAgICAgICByZXR1cm4geyByOiAtMSwgZzogLTEsIGI6IC0xLCBvcGFjaXR5OiAtMSwgZXJyb3I6IDEgfTtcbiAgICB9XG4gICAgdmFyIHJlcyxcbiAgICAgICAgcmVkLFxuICAgICAgICBncmVlbixcbiAgICAgICAgYmx1ZSxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgdCxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICByZ2IgPSBjb2xvdXIubWF0Y2goY29sb3VyUmVnRXhwKTtcbiAgICBpZiAocmdiKSB7XG4gICAgICAgIGlmIChyZ2JbMl0pIHtcbiAgICAgICAgICAgIGJsdWUgPSBwYXJzZUludChyZ2JbMl0uc3Vic3RyaW5nKDUpLCAxNik7XG4gICAgICAgICAgICBncmVlbiA9IHBhcnNlSW50KHJnYlsyXS5zdWJzdHJpbmcoMywgNSksIDE2KTtcbiAgICAgICAgICAgIHJlZCA9IHBhcnNlSW50KHJnYlsyXS5zdWJzdHJpbmcoMSwgMyksIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmdiWzNdKSB7XG4gICAgICAgICAgICBibHVlID0gcGFyc2VJbnQoKHQgPSByZ2JbM10uY2hhckF0KDMpKSArIHQsIDE2KTtcbiAgICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQoKHQgPSByZ2JbM10uY2hhckF0KDIpKSArIHQsIDE2KTtcbiAgICAgICAgICAgIHJlZCA9IHBhcnNlSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgxKSkgKyB0LCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJnYls0XSkge1xuICAgICAgICAgICAgdmFsdWVzID0gcmdiWzRdLnNwbGl0KGNvbW1hU3BhY2VzKTtcbiAgICAgICAgICAgIHJlZCA9IHBhcnNlRmxvYXQodmFsdWVzWzBdKTtcbiAgICAgICAgICAgIHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKHJlZCAqPSAyLjU1KTtcbiAgICAgICAgICAgIGdyZWVuID0gcGFyc2VGbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgdmFsdWVzWzFdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoZ3JlZW4gKj0gMi41NSk7XG4gICAgICAgICAgICBibHVlID0gcGFyc2VGbG9hdCh2YWx1ZXNbMl0pO1xuICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAqPSAyLjU1KTtcbiAgICAgICAgICAgIHJnYlsxXS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDQpID09IFwicmdiYVwiICYmIChvcGFjaXR5ID0gcGFyc2VGbG9hdCh2YWx1ZXNbM10pKTtcbiAgICAgICAgICAgIHZhbHVlc1szXSAmJiB2YWx1ZXNbM10uc2xpY2UoLTEpID09IFwiJVwiICYmIChvcGFjaXR5IC89IDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJnYls1XSkge1xuICAgICAgICAgICAgdmFsdWVzID0gcmdiWzVdLnNwbGl0KGNvbW1hU3BhY2VzKTtcbiAgICAgICAgICAgIHJlZCA9IHBhcnNlRmxvYXQodmFsdWVzWzBdKTtcbiAgICAgICAgICAgIHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKHJlZCAvPSAxMDApO1xuICAgICAgICAgICAgZ3JlZW4gPSBwYXJzZUZsb2F0KHZhbHVlc1sxXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMV0uc2xpY2UoLTEpID09IFwiJVwiICYmIChncmVlbiAvPSAxMDApO1xuICAgICAgICAgICAgYmx1ZSA9IHBhcnNlRmxvYXQodmFsdWVzWzJdKTtcbiAgICAgICAgICAgIHZhbHVlc1syXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGJsdWUgLz0gMTAwKTtcbiAgICAgICAgICAgICh2YWx1ZXNbMF0uc2xpY2UoLTMpID09IFwiZGVnXCIgfHwgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIlxceGIwXCIpICYmIChyZWQgLz0gMzYwKTtcbiAgICAgICAgICAgIHJnYlsxXS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDQpID09IFwiaHNiYVwiICYmIChvcGFjaXR5ID0gcGFyc2VGbG9hdCh2YWx1ZXNbM10pKTtcbiAgICAgICAgICAgIHZhbHVlc1szXSAmJiB2YWx1ZXNbM10uc2xpY2UoLTEpID09IFwiJVwiICYmIChvcGFjaXR5IC89IDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gaHNiMnJnYihyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmdiWzZdKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSByZ2JbNl0uc3BsaXQoY29tbWFTcGFjZXMpO1xuICAgICAgICAgICAgcmVkID0gcGFyc2VGbG9hdCh2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAocmVkIC89IDEwMCk7XG4gICAgICAgICAgICBncmVlbiA9IHBhcnNlRmxvYXQodmFsdWVzWzFdKTtcbiAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuIC89IDEwMCk7XG4gICAgICAgICAgICBibHVlID0gcGFyc2VGbG9hdCh2YWx1ZXNbMl0pO1xuICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAvPSAxMDApO1xuICAgICAgICAgICAgKHZhbHVlc1swXS5zbGljZSgtMykgPT0gXCJkZWdcIiB8fCB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiXFx4YjBcIikgJiYgKHJlZCAvPSAzNjApO1xuICAgICAgICAgICAgcmdiWzFdLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNCkgPT0gXCJoc2xhXCIgJiYgKG9wYWNpdHkgPSBwYXJzZUZsb2F0KHZhbHVlc1szXSkpO1xuICAgICAgICAgICAgdmFsdWVzWzNdICYmIHZhbHVlc1szXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKG9wYWNpdHkgLz0gMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBoc2wycmdiKHJlZCwgZ3JlZW4sIGJsdWUsIG9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHJlZCA9IE1hdGgubWluKE1hdGgucm91bmQocmVkKSwgMjU1KTtcbiAgICAgICAgZ3JlZW4gPSBNYXRoLm1pbihNYXRoLnJvdW5kKGdyZWVuKSwgMjU1KTtcbiAgICAgICAgYmx1ZSA9IE1hdGgubWluKE1hdGgucm91bmQoYmx1ZSksIDI1NSk7XG4gICAgICAgIG9wYWNpdHkgPSBNYXRoLm1pbihNYXRoLm1heChvcGFjaXR5LCAwKSwgMSk7XG4gICAgICAgIHJnYiA9IHsgcjogcmVkLCBnOiBncmVlbiwgYjogYmx1ZSB9O1xuICAgICAgICByZ2Iub3BhY2l0eSA9IGlzRmluaXRlKG9wYWNpdHkpID8gb3BhY2l0eSA6IDE7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIHJldHVybiB7IHI6IC0xLCBnOiAtMSwgYjogLTEsIG9wYWNpdHk6IC0xLCBlcnJvcjogMSB9O1xufVxuXG47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-svg-morph/lib/utils/svglite.js\n");

/***/ }),

/***/ "./node_modules/svgpath/index.js":
/*!***************************************!*\
  !*** ./node_modules/svgpath/index.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/svgpath */ \"./node_modules/svgpath/lib/svgpath.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrR0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N2Z3BhdGgvaW5kZXguanM/MGY0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvc3ZncGF0aCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/svgpath/index.js\n");

/***/ }),

/***/ "./node_modules/svgpath/lib/a2c.js":
/*!*****************************************!*\
  !*** ./node_modules/svgpath/lib/a2c.js ***!
  \*****************************************/
/***/ (function(module) {

eval("// Convert an arc to a sequence of cubic bézier curves\n//\n\n\n\nvar TAU = Math.PI * 2;\n\n\n/* eslint-disable space-infix-ops */\n\n// Calculate an angle between two unit vectors\n//\n// Since we measure angle between radii of circular arcs,\n// we can use simplified math (without length normalization)\n//\nfunction unit_vector_angle(ux, uy, vx, vy) {\n  var sign = (ux * vy - uy * vx < 0) ? -1 : 1;\n  var dot  = ux * vx + uy * vy;\n\n  // Add this to work with arbitrary vectors:\n  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n\n  // rounding errors, e.g. -1.0000000000000002 can screw up this\n  if (dot >  1.0) { dot =  1.0; }\n  if (dot < -1.0) { dot = -1.0; }\n\n  return sign * Math.acos(dot);\n}\n\n\n// Convert from endpoint to center parameterization,\n// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n//\n// Return [cx, cy, theta1, delta_theta]\n//\nfunction get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {\n  // Step 1.\n  //\n  // Moving an ellipse so origin will be the middlepoint between our two\n  // points. After that, rotate it to line up ellipse axes with coordinate\n  // axes.\n  //\n  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;\n  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;\n\n  var rx_sq  =  rx * rx;\n  var ry_sq  =  ry * ry;\n  var x1p_sq = x1p * x1p;\n  var y1p_sq = y1p * y1p;\n\n  // Step 2.\n  //\n  // Compute coordinates of the centre of this ellipse (cx', cy')\n  // in the new coordinate system.\n  //\n  var radicant = (rx_sq * ry_sq) - (rx_sq * y1p_sq) - (ry_sq * x1p_sq);\n\n  if (radicant < 0) {\n    // due to rounding errors it might be e.g. -1.3877787807814457e-17\n    radicant = 0;\n  }\n\n  radicant /=   (rx_sq * y1p_sq) + (ry_sq * x1p_sq);\n  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);\n\n  var cxp = radicant *  rx/ry * y1p;\n  var cyp = radicant * -ry/rx * x1p;\n\n  // Step 3.\n  //\n  // Transform back to get centre coordinates (cx, cy) in the original\n  // coordinate system.\n  //\n  var cx = cos_phi*cxp - sin_phi*cyp + (x1+x2)/2;\n  var cy = sin_phi*cxp + cos_phi*cyp + (y1+y2)/2;\n\n  // Step 4.\n  //\n  // Compute angles (theta1, delta_theta).\n  //\n  var v1x =  (x1p - cxp) / rx;\n  var v1y =  (y1p - cyp) / ry;\n  var v2x = (-x1p - cxp) / rx;\n  var v2y = (-y1p - cyp) / ry;\n\n  var theta1 = unit_vector_angle(1, 0, v1x, v1y);\n  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);\n\n  if (fs === 0 && delta_theta > 0) {\n    delta_theta -= TAU;\n  }\n  if (fs === 1 && delta_theta < 0) {\n    delta_theta += TAU;\n  }\n\n  return [ cx, cy, theta1, delta_theta ];\n}\n\n//\n// Approximate one unit arc segment with bézier curves,\n// see http://math.stackexchange.com/questions/873224\n//\nfunction approximate_unit_arc(theta1, delta_theta) {\n  var alpha = 4/3 * Math.tan(delta_theta/4);\n\n  var x1 = Math.cos(theta1);\n  var y1 = Math.sin(theta1);\n  var x2 = Math.cos(theta1 + delta_theta);\n  var y2 = Math.sin(theta1 + delta_theta);\n\n  return [ x1, y1, x1 - y1*alpha, y1 + x1*alpha, x2 + y2*alpha, y2 - x2*alpha, x2, y2 ];\n}\n\nmodule.exports = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {\n  var sin_phi = Math.sin(phi * TAU / 360);\n  var cos_phi = Math.cos(phi * TAU / 360);\n\n  // Make sure radii are valid\n  //\n  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;\n  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;\n\n  if (x1p === 0 && y1p === 0) {\n    // we're asked to draw line to itself\n    return [];\n  }\n\n  if (rx === 0 || ry === 0) {\n    // one of the radii is zero\n    return [];\n  }\n\n\n  // Compensate out-of-range radii\n  //\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n\n  // Get center parameters (cx, cy, theta1, delta_theta)\n  //\n  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);\n\n  var result = [];\n  var theta1 = cc[2];\n  var delta_theta = cc[3];\n\n  // Split an arc to multiple segments, so each segment\n  // will be less than τ/4 (= 90°)\n  //\n  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);\n  delta_theta /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    result.push(approximate_unit_arc(theta1, delta_theta));\n    theta1 += delta_theta;\n  }\n\n  // We have a bezier approximation of a unit circle,\n  // now need to transform back to the original ellipse\n  //\n  return result.map(function (curve) {\n    for (var i = 0; i < curve.length; i += 2) {\n      var x = curve[i + 0];\n      var y = curve[i + 1];\n\n      // scale\n      x *= rx;\n      y *= ry;\n\n      // rotate\n      var xp = cos_phi*x - sin_phi*y;\n      var yp = sin_phi*x + cos_phi*y;\n\n      // translate\n      curve[i + 0] = xp + cc[0];\n      curve[i + 1] = yp + cc[1];\n    }\n\n    return curve;\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvYTJjLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDYTs7O0FBR2I7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N2Z3BhdGgvbGliL2EyYy5qcz84ODhmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbnZlcnQgYW4gYXJjIHRvIGEgc2VxdWVuY2Ugb2YgY3ViaWMgYsOpemllciBjdXJ2ZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFRBVSA9IE1hdGguUEkgKiAyO1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLWluZml4LW9wcyAqL1xuXG4vLyBDYWxjdWxhdGUgYW4gYW5nbGUgYmV0d2VlbiB0d28gdW5pdCB2ZWN0b3JzXG4vL1xuLy8gU2luY2Ugd2UgbWVhc3VyZSBhbmdsZSBiZXR3ZWVuIHJhZGlpIG9mIGNpcmN1bGFyIGFyY3MsXG4vLyB3ZSBjYW4gdXNlIHNpbXBsaWZpZWQgbWF0aCAod2l0aG91dCBsZW5ndGggbm9ybWFsaXphdGlvbilcbi8vXG5mdW5jdGlvbiB1bml0X3ZlY3Rvcl9hbmdsZSh1eCwgdXksIHZ4LCB2eSkge1xuICB2YXIgc2lnbiA9ICh1eCAqIHZ5IC0gdXkgKiB2eCA8IDApID8gLTEgOiAxO1xuICB2YXIgZG90ICA9IHV4ICogdnggKyB1eSAqIHZ5O1xuXG4gIC8vIEFkZCB0aGlzIHRvIHdvcmsgd2l0aCBhcmJpdHJhcnkgdmVjdG9yczpcbiAgLy8gZG90IC89IE1hdGguc3FydCh1eCAqIHV4ICsgdXkgKiB1eSkgKiBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuXG4gIC8vIHJvdW5kaW5nIGVycm9ycywgZS5nLiAtMS4wMDAwMDAwMDAwMDAwMDAyIGNhbiBzY3JldyB1cCB0aGlzXG4gIGlmIChkb3QgPiAgMS4wKSB7IGRvdCA9ICAxLjA7IH1cbiAgaWYgKGRvdCA8IC0xLjApIHsgZG90ID0gLTEuMDsgfVxuXG4gIHJldHVybiBzaWduICogTWF0aC5hY29zKGRvdCk7XG59XG5cblxuLy8gQ29udmVydCBmcm9tIGVuZHBvaW50IHRvIGNlbnRlciBwYXJhbWV0ZXJpemF0aW9uLFxuLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuLy9cbi8vIFJldHVybiBbY3gsIGN5LCB0aGV0YTEsIGRlbHRhX3RoZXRhXVxuLy9cbmZ1bmN0aW9uIGdldF9hcmNfY2VudGVyKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgc2luX3BoaSwgY29zX3BoaSkge1xuICAvLyBTdGVwIDEuXG4gIC8vXG4gIC8vIE1vdmluZyBhbiBlbGxpcHNlIHNvIG9yaWdpbiB3aWxsIGJlIHRoZSBtaWRkbGVwb2ludCBiZXR3ZWVuIG91ciB0d29cbiAgLy8gcG9pbnRzLiBBZnRlciB0aGF0LCByb3RhdGUgaXQgdG8gbGluZSB1cCBlbGxpcHNlIGF4ZXMgd2l0aCBjb29yZGluYXRlXG4gIC8vIGF4ZXMuXG4gIC8vXG4gIHZhciB4MXAgPSAgY29zX3BoaSooeDEteDIpLzIgKyBzaW5fcGhpKih5MS15MikvMjtcbiAgdmFyIHkxcCA9IC1zaW5fcGhpKih4MS14MikvMiArIGNvc19waGkqKHkxLXkyKS8yO1xuXG4gIHZhciByeF9zcSAgPSAgcnggKiByeDtcbiAgdmFyIHJ5X3NxICA9ICByeSAqIHJ5O1xuICB2YXIgeDFwX3NxID0geDFwICogeDFwO1xuICB2YXIgeTFwX3NxID0geTFwICogeTFwO1xuXG4gIC8vIFN0ZXAgMi5cbiAgLy9cbiAgLy8gQ29tcHV0ZSBjb29yZGluYXRlcyBvZiB0aGUgY2VudHJlIG9mIHRoaXMgZWxsaXBzZSAoY3gnLCBjeScpXG4gIC8vIGluIHRoZSBuZXcgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gIC8vXG4gIHZhciByYWRpY2FudCA9IChyeF9zcSAqIHJ5X3NxKSAtIChyeF9zcSAqIHkxcF9zcSkgLSAocnlfc3EgKiB4MXBfc3EpO1xuXG4gIGlmIChyYWRpY2FudCA8IDApIHtcbiAgICAvLyBkdWUgdG8gcm91bmRpbmcgZXJyb3JzIGl0IG1pZ2h0IGJlIGUuZy4gLTEuMzg3Nzc4NzgwNzgxNDQ1N2UtMTdcbiAgICByYWRpY2FudCA9IDA7XG4gIH1cblxuICByYWRpY2FudCAvPSAgIChyeF9zcSAqIHkxcF9zcSkgKyAocnlfc3EgKiB4MXBfc3EpO1xuICByYWRpY2FudCA9IE1hdGguc3FydChyYWRpY2FudCkgKiAoZmEgPT09IGZzID8gLTEgOiAxKTtcblxuICB2YXIgY3hwID0gcmFkaWNhbnQgKiAgcngvcnkgKiB5MXA7XG4gIHZhciBjeXAgPSByYWRpY2FudCAqIC1yeS9yeCAqIHgxcDtcblxuICAvLyBTdGVwIDMuXG4gIC8vXG4gIC8vIFRyYW5zZm9ybSBiYWNrIHRvIGdldCBjZW50cmUgY29vcmRpbmF0ZXMgKGN4LCBjeSkgaW4gdGhlIG9yaWdpbmFsXG4gIC8vIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAvL1xuICB2YXIgY3ggPSBjb3NfcGhpKmN4cCAtIHNpbl9waGkqY3lwICsgKHgxK3gyKS8yO1xuICB2YXIgY3kgPSBzaW5fcGhpKmN4cCArIGNvc19waGkqY3lwICsgKHkxK3kyKS8yO1xuXG4gIC8vIFN0ZXAgNC5cbiAgLy9cbiAgLy8gQ29tcHV0ZSBhbmdsZXMgKHRoZXRhMSwgZGVsdGFfdGhldGEpLlxuICAvL1xuICB2YXIgdjF4ID0gICh4MXAgLSBjeHApIC8gcng7XG4gIHZhciB2MXkgPSAgKHkxcCAtIGN5cCkgLyByeTtcbiAgdmFyIHYyeCA9ICgteDFwIC0gY3hwKSAvIHJ4O1xuICB2YXIgdjJ5ID0gKC15MXAgLSBjeXApIC8gcnk7XG5cbiAgdmFyIHRoZXRhMSA9IHVuaXRfdmVjdG9yX2FuZ2xlKDEsIDAsIHYxeCwgdjF5KTtcbiAgdmFyIGRlbHRhX3RoZXRhID0gdW5pdF92ZWN0b3JfYW5nbGUodjF4LCB2MXksIHYyeCwgdjJ5KTtcblxuICBpZiAoZnMgPT09IDAgJiYgZGVsdGFfdGhldGEgPiAwKSB7XG4gICAgZGVsdGFfdGhldGEgLT0gVEFVO1xuICB9XG4gIGlmIChmcyA9PT0gMSAmJiBkZWx0YV90aGV0YSA8IDApIHtcbiAgICBkZWx0YV90aGV0YSArPSBUQVU7XG4gIH1cblxuICByZXR1cm4gWyBjeCwgY3ksIHRoZXRhMSwgZGVsdGFfdGhldGEgXTtcbn1cblxuLy9cbi8vIEFwcHJveGltYXRlIG9uZSB1bml0IGFyYyBzZWdtZW50IHdpdGggYsOpemllciBjdXJ2ZXMsXG4vLyBzZWUgaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzg3MzIyNFxuLy9cbmZ1bmN0aW9uIGFwcHJveGltYXRlX3VuaXRfYXJjKHRoZXRhMSwgZGVsdGFfdGhldGEpIHtcbiAgdmFyIGFscGhhID0gNC8zICogTWF0aC50YW4oZGVsdGFfdGhldGEvNCk7XG5cbiAgdmFyIHgxID0gTWF0aC5jb3ModGhldGExKTtcbiAgdmFyIHkxID0gTWF0aC5zaW4odGhldGExKTtcbiAgdmFyIHgyID0gTWF0aC5jb3ModGhldGExICsgZGVsdGFfdGhldGEpO1xuICB2YXIgeTIgPSBNYXRoLnNpbih0aGV0YTEgKyBkZWx0YV90aGV0YSk7XG5cbiAgcmV0dXJuIFsgeDEsIHkxLCB4MSAtIHkxKmFscGhhLCB5MSArIHgxKmFscGhhLCB4MiArIHkyKmFscGhhLCB5MiAtIHgyKmFscGhhLCB4MiwgeTIgXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhMmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwaGkpIHtcbiAgdmFyIHNpbl9waGkgPSBNYXRoLnNpbihwaGkgKiBUQVUgLyAzNjApO1xuICB2YXIgY29zX3BoaSA9IE1hdGguY29zKHBoaSAqIFRBVSAvIDM2MCk7XG5cbiAgLy8gTWFrZSBzdXJlIHJhZGlpIGFyZSB2YWxpZFxuICAvL1xuICB2YXIgeDFwID0gIGNvc19waGkqKHgxLXgyKS8yICsgc2luX3BoaSooeTEteTIpLzI7XG4gIHZhciB5MXAgPSAtc2luX3BoaSooeDEteDIpLzIgKyBjb3NfcGhpKih5MS15MikvMjtcblxuICBpZiAoeDFwID09PSAwICYmIHkxcCA9PT0gMCkge1xuICAgIC8vIHdlJ3JlIGFza2VkIHRvIGRyYXcgbGluZSB0byBpdHNlbGZcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAocnggPT09IDAgfHwgcnkgPT09IDApIHtcbiAgICAvLyBvbmUgb2YgdGhlIHJhZGlpIGlzIHplcm9cbiAgICByZXR1cm4gW107XG4gIH1cblxuXG4gIC8vIENvbXBlbnNhdGUgb3V0LW9mLXJhbmdlIHJhZGlpXG4gIC8vXG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcblxuICB2YXIgbGFtYmRhID0gKHgxcCAqIHgxcCkgLyAocnggKiByeCkgKyAoeTFwICogeTFwKSAvIChyeSAqIHJ5KTtcbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgICByeSAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgfVxuXG5cbiAgLy8gR2V0IGNlbnRlciBwYXJhbWV0ZXJzIChjeCwgY3ksIHRoZXRhMSwgZGVsdGFfdGhldGEpXG4gIC8vXG4gIHZhciBjYyA9IGdldF9hcmNfY2VudGVyKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgc2luX3BoaSwgY29zX3BoaSk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdGhldGExID0gY2NbMl07XG4gIHZhciBkZWx0YV90aGV0YSA9IGNjWzNdO1xuXG4gIC8vIFNwbGl0IGFuIGFyYyB0byBtdWx0aXBsZSBzZWdtZW50cywgc28gZWFjaCBzZWdtZW50XG4gIC8vIHdpbGwgYmUgbGVzcyB0aGFuIM+ELzQgKD0gOTDCsClcbiAgLy9cbiAgdmFyIHNlZ21lbnRzID0gTWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKGRlbHRhX3RoZXRhKSAvIChUQVUgLyA0KSksIDEpO1xuICBkZWx0YV90aGV0YSAvPSBzZWdtZW50cztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChhcHByb3hpbWF0ZV91bml0X2FyYyh0aGV0YTEsIGRlbHRhX3RoZXRhKSk7XG4gICAgdGhldGExICs9IGRlbHRhX3RoZXRhO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBhIGJlemllciBhcHByb3hpbWF0aW9uIG9mIGEgdW5pdCBjaXJjbGUsXG4gIC8vIG5vdyBuZWVkIHRvIHRyYW5zZm9ybSBiYWNrIHRvIHRoZSBvcmlnaW5hbCBlbGxpcHNlXG4gIC8vXG4gIHJldHVybiByZXN1bHQubWFwKGZ1bmN0aW9uIChjdXJ2ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciB4ID0gY3VydmVbaSArIDBdO1xuICAgICAgdmFyIHkgPSBjdXJ2ZVtpICsgMV07XG5cbiAgICAgIC8vIHNjYWxlXG4gICAgICB4ICo9IHJ4O1xuICAgICAgeSAqPSByeTtcblxuICAgICAgLy8gcm90YXRlXG4gICAgICB2YXIgeHAgPSBjb3NfcGhpKnggLSBzaW5fcGhpKnk7XG4gICAgICB2YXIgeXAgPSBzaW5fcGhpKnggKyBjb3NfcGhpKnk7XG5cbiAgICAgIC8vIHRyYW5zbGF0ZVxuICAgICAgY3VydmVbaSArIDBdID0geHAgKyBjY1swXTtcbiAgICAgIGN1cnZlW2kgKyAxXSA9IHlwICsgY2NbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnZlO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/svgpath/lib/a2c.js\n");

/***/ }),

/***/ "./node_modules/svgpath/lib/ellipse.js":
/*!*********************************************!*\
  !*** ./node_modules/svgpath/lib/ellipse.js ***!
  \*********************************************/
/***/ (function(module) {

eval("\n\n/* eslint-disable space-infix-ops */\n\n// The precision used to consider an ellipse as a circle\n//\nvar epsilon = 0.0000000001;\n\n// To convert degree in radians\n//\nvar torad = Math.PI / 180;\n\n// Class constructor :\n//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.\n//\nfunction Ellipse(rx, ry, ax) {\n  if (!(this instanceof Ellipse)) { return new Ellipse(rx, ry, ax); }\n  this.rx = rx;\n  this.ry = ry;\n  this.ax = ax;\n}\n\n// Apply a linear transform m to the ellipse\n// m is an array representing a matrix :\n//    -         -\n//   | m[0] m[2] |\n//   | m[1] m[3] |\n//    -         -\n//\nEllipse.prototype.transform = function (m) {\n  // We consider the current ellipse as image of the unit circle\n  // by first scale(rx,ry) and then rotate(ax) ...\n  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.\n  var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);\n  var ma = [\n    this.rx * (m[0]*c + m[2]*s),\n    this.rx * (m[1]*c + m[3]*s),\n    this.ry * (-m[0]*s + m[2]*c),\n    this.ry * (-m[1]*s + m[3]*c)\n  ];\n\n  // ma * transpose(ma) = [ J L ]\n  //                      [ L K ]\n  // L is calculated later (if the image is not a circle)\n  var J = ma[0]*ma[0] + ma[2]*ma[2],\n      K = ma[1]*ma[1] + ma[3]*ma[3];\n\n  // the discriminant of the characteristic polynomial of ma * transpose(ma)\n  var D = ((ma[0]-ma[3])*(ma[0]-ma[3]) + (ma[2]+ma[1])*(ma[2]+ma[1])) *\n          ((ma[0]+ma[3])*(ma[0]+ma[3]) + (ma[2]-ma[1])*(ma[2]-ma[1]));\n\n  // the \"mean eigenvalue\"\n  var JK = (J + K) / 2;\n\n  // check if the image is (almost) a circle\n  if (D < epsilon * JK) {\n    // if it is\n    this.rx = this.ry = Math.sqrt(JK);\n    this.ax = 0;\n    return this;\n  }\n\n  // if it is not a circle\n  var L = ma[0]*ma[1] + ma[2]*ma[3];\n\n  D = Math.sqrt(D);\n\n  // {l1,l2} = the two eigen values of ma * transpose(ma)\n  var l1 = JK + D/2,\n      l2 = JK - D/2;\n  // the x - axis - rotation angle is the argument of the l1 - eigenvector\n  /*eslint-disable indent*/\n  this.ax = (Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon) ?\n    90\n  :\n    Math.atan(Math.abs(L) > Math.abs(l1 - K) ?\n      (l1 - J) / L\n    :\n      L / (l1 - K)\n    ) * 180 / Math.PI;\n  /*eslint-enable indent*/\n\n  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90\n  if (this.ax >= 0) {\n    // if ax in [0,90]\n    this.rx = Math.sqrt(l1);\n    this.ry = Math.sqrt(l2);\n  } else {\n    // if ax in ]-90,0[ => exchange axes\n    this.ax += 90;\n    this.rx = Math.sqrt(l2);\n    this.ry = Math.sqrt(l1);\n  }\n\n  return this;\n};\n\n// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0\n//\nEllipse.prototype.isDegenerate = function () {\n  return (this.rx < epsilon * this.ry || this.ry < epsilon * this.rx);\n};\n\nmodule.exports = Ellipse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvZWxsaXBzZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvZWxsaXBzZS5qcz84MTFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtaW5maXgtb3BzICovXG5cbi8vIFRoZSBwcmVjaXNpb24gdXNlZCB0byBjb25zaWRlciBhbiBlbGxpcHNlIGFzIGEgY2lyY2xlXG4vL1xudmFyIGVwc2lsb24gPSAwLjAwMDAwMDAwMDE7XG5cbi8vIFRvIGNvbnZlcnQgZGVncmVlIGluIHJhZGlhbnNcbi8vXG52YXIgdG9yYWQgPSBNYXRoLlBJIC8gMTgwO1xuXG4vLyBDbGFzcyBjb25zdHJ1Y3RvciA6XG4vLyAgYW4gZWxsaXBzZSBjZW50cmVkIGF0IDAgd2l0aCByYWRpaSByeCxyeSBhbmQgeCAtIGF4aXMgLSBhbmdsZSBheC5cbi8vXG5mdW5jdGlvbiBFbGxpcHNlKHJ4LCByeSwgYXgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVsbGlwc2UpKSB7IHJldHVybiBuZXcgRWxsaXBzZShyeCwgcnksIGF4KTsgfVxuICB0aGlzLnJ4ID0gcng7XG4gIHRoaXMucnkgPSByeTtcbiAgdGhpcy5heCA9IGF4O1xufVxuXG4vLyBBcHBseSBhIGxpbmVhciB0cmFuc2Zvcm0gbSB0byB0aGUgZWxsaXBzZVxuLy8gbSBpcyBhbiBhcnJheSByZXByZXNlbnRpbmcgYSBtYXRyaXggOlxuLy8gICAgLSAgICAgICAgIC1cbi8vICAgfCBtWzBdIG1bMl0gfFxuLy8gICB8IG1bMV0gbVszXSB8XG4vLyAgICAtICAgICAgICAgLVxuLy9cbkVsbGlwc2UucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gIC8vIFdlIGNvbnNpZGVyIHRoZSBjdXJyZW50IGVsbGlwc2UgYXMgaW1hZ2Ugb2YgdGhlIHVuaXQgY2lyY2xlXG4gIC8vIGJ5IGZpcnN0IHNjYWxlKHJ4LHJ5KSBhbmQgdGhlbiByb3RhdGUoYXgpIC4uLlxuICAvLyBTbyB3ZSBhcHBseSBtYSA9ICBtIHggcm90YXRlKGF4KSB4IHNjYWxlKHJ4LHJ5KSB0byB0aGUgdW5pdCBjaXJjbGUuXG4gIHZhciBjID0gTWF0aC5jb3ModGhpcy5heCAqIHRvcmFkKSwgcyA9IE1hdGguc2luKHRoaXMuYXggKiB0b3JhZCk7XG4gIHZhciBtYSA9IFtcbiAgICB0aGlzLnJ4ICogKG1bMF0qYyArIG1bMl0qcyksXG4gICAgdGhpcy5yeCAqIChtWzFdKmMgKyBtWzNdKnMpLFxuICAgIHRoaXMucnkgKiAoLW1bMF0qcyArIG1bMl0qYyksXG4gICAgdGhpcy5yeSAqICgtbVsxXSpzICsgbVszXSpjKVxuICBdO1xuXG4gIC8vIG1hICogdHJhbnNwb3NlKG1hKSA9IFsgSiBMIF1cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgWyBMIEsgXVxuICAvLyBMIGlzIGNhbGN1bGF0ZWQgbGF0ZXIgKGlmIHRoZSBpbWFnZSBpcyBub3QgYSBjaXJjbGUpXG4gIHZhciBKID0gbWFbMF0qbWFbMF0gKyBtYVsyXSptYVsyXSxcbiAgICAgIEsgPSBtYVsxXSptYVsxXSArIG1hWzNdKm1hWzNdO1xuXG4gIC8vIHRoZSBkaXNjcmltaW5hbnQgb2YgdGhlIGNoYXJhY3RlcmlzdGljIHBvbHlub21pYWwgb2YgbWEgKiB0cmFuc3Bvc2UobWEpXG4gIHZhciBEID0gKChtYVswXS1tYVszXSkqKG1hWzBdLW1hWzNdKSArIChtYVsyXSttYVsxXSkqKG1hWzJdK21hWzFdKSkgKlxuICAgICAgICAgICgobWFbMF0rbWFbM10pKihtYVswXSttYVszXSkgKyAobWFbMl0tbWFbMV0pKihtYVsyXS1tYVsxXSkpO1xuXG4gIC8vIHRoZSBcIm1lYW4gZWlnZW52YWx1ZVwiXG4gIHZhciBKSyA9IChKICsgSykgLyAyO1xuXG4gIC8vIGNoZWNrIGlmIHRoZSBpbWFnZSBpcyAoYWxtb3N0KSBhIGNpcmNsZVxuICBpZiAoRCA8IGVwc2lsb24gKiBKSykge1xuICAgIC8vIGlmIGl0IGlzXG4gICAgdGhpcy5yeCA9IHRoaXMucnkgPSBNYXRoLnNxcnQoSkspO1xuICAgIHRoaXMuYXggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gaWYgaXQgaXMgbm90IGEgY2lyY2xlXG4gIHZhciBMID0gbWFbMF0qbWFbMV0gKyBtYVsyXSptYVszXTtcblxuICBEID0gTWF0aC5zcXJ0KEQpO1xuXG4gIC8vIHtsMSxsMn0gPSB0aGUgdHdvIGVpZ2VuIHZhbHVlcyBvZiBtYSAqIHRyYW5zcG9zZShtYSlcbiAgdmFyIGwxID0gSksgKyBELzIsXG4gICAgICBsMiA9IEpLIC0gRC8yO1xuICAvLyB0aGUgeCAtIGF4aXMgLSByb3RhdGlvbiBhbmdsZSBpcyB0aGUgYXJndW1lbnQgb2YgdGhlIGwxIC0gZWlnZW52ZWN0b3JcbiAgLyplc2xpbnQtZGlzYWJsZSBpbmRlbnQqL1xuICB0aGlzLmF4ID0gKE1hdGguYWJzKEwpIDwgZXBzaWxvbiAmJiBNYXRoLmFicyhsMSAtIEspIDwgZXBzaWxvbikgP1xuICAgIDkwXG4gIDpcbiAgICBNYXRoLmF0YW4oTWF0aC5hYnMoTCkgPiBNYXRoLmFicyhsMSAtIEspID9cbiAgICAgIChsMSAtIEopIC8gTFxuICAgIDpcbiAgICAgIEwgLyAobDEgLSBLKVxuICAgICkgKiAxODAgLyBNYXRoLlBJO1xuICAvKmVzbGludC1lbmFibGUgaW5kZW50Ki9cblxuICAvLyBpZiBheCA+IDAgPT4gcnggPSBzcXJ0KGwxKSwgcnkgPSBzcXJ0KGwyKSwgZWxzZSBleGNoYW5nZSBheGVzIGFuZCBheCArPSA5MFxuICBpZiAodGhpcy5heCA+PSAwKSB7XG4gICAgLy8gaWYgYXggaW4gWzAsOTBdXG4gICAgdGhpcy5yeCA9IE1hdGguc3FydChsMSk7XG4gICAgdGhpcy5yeSA9IE1hdGguc3FydChsMik7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgYXggaW4gXS05MCwwWyA9PiBleGNoYW5nZSBheGVzXG4gICAgdGhpcy5heCArPSA5MDtcbiAgICB0aGlzLnJ4ID0gTWF0aC5zcXJ0KGwyKTtcbiAgICB0aGlzLnJ5ID0gTWF0aC5zcXJ0KGwxKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gQ2hlY2sgaWYgdGhlIGVsbGlwc2UgaXMgKGFsbW9zdCkgZGVnZW5lcmF0ZSwgaS5lLiByeCA9IDAgb3IgcnkgPSAwXG4vL1xuRWxsaXBzZS5wcm90b3R5cGUuaXNEZWdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMucnggPCBlcHNpbG9uICogdGhpcy5yeSB8fCB0aGlzLnJ5IDwgZXBzaWxvbiAqIHRoaXMucngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbGxpcHNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/svgpath/lib/ellipse.js\n");

/***/ }),

/***/ "./node_modules/svgpath/lib/matrix.js":
/*!********************************************!*\
  !*** ./node_modules/svgpath/lib/matrix.js ***!
  \********************************************/
/***/ (function(module) {

eval("\n\n// combine 2 matrixes\n// m1, m2 - [a, b, c, d, e, g]\n//\nfunction combine(m1, m2) {\n  return [\n    m1[0] * m2[0] + m1[2] * m2[1],\n    m1[1] * m2[0] + m1[3] * m2[1],\n    m1[0] * m2[2] + m1[2] * m2[3],\n    m1[1] * m2[2] + m1[3] * m2[3],\n    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n  ];\n}\n\n\nfunction Matrix() {\n  if (!(this instanceof Matrix)) { return new Matrix(); }\n  this.queue = [];   // list of matrixes to apply\n  this.cache = null; // combined matrix cache\n}\n\n\nMatrix.prototype.matrix = function (m) {\n  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {\n    return this;\n  }\n  this.cache = null;\n  this.queue.push(m);\n  return this;\n};\n\n\nMatrix.prototype.translate = function (tx, ty) {\n  if (tx !== 0 || ty !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, 0, 0, 1, tx, ty ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.scale = function (sx, sy) {\n  if (sx !== 1 || sy !== 1) {\n    this.cache = null;\n    this.queue.push([ sx, 0, 0, sy, 0, 0 ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.rotate = function (angle, rx, ry) {\n  var rad, cos, sin;\n\n  if (angle !== 0) {\n    this.translate(rx, ry);\n\n    rad = angle * Math.PI / 180;\n    cos = Math.cos(rad);\n    sin = Math.sin(rad);\n\n    this.queue.push([ cos, sin, -sin, cos, 0, 0 ]);\n    this.cache = null;\n\n    this.translate(-rx, -ry);\n  }\n  return this;\n};\n\n\nMatrix.prototype.skewX = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0 ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.skewY = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0 ]);\n  }\n  return this;\n};\n\n\n// Flatten queue\n//\nMatrix.prototype.toArray = function () {\n  if (this.cache) {\n    return this.cache;\n  }\n\n  if (!this.queue.length) {\n    this.cache = [ 1, 0, 0, 1, 0, 0 ];\n    return this.cache;\n  }\n\n  this.cache = this.queue[0];\n\n  if (this.queue.length === 1) {\n    return this.cache;\n  }\n\n  for (var i = 1; i < this.queue.length; i++) {\n    this.cache = combine(this.cache, this.queue[i]);\n  }\n\n  return this.cache;\n};\n\n\n// Apply list of matrixes to (x,y) point.\n// If `isRelative` set, `translate` component of matrix will be skipped\n//\nMatrix.prototype.calc = function (x, y, isRelative) {\n  var m;\n\n  // Don't change point on empty transforms queue\n  if (!this.queue.length) { return [ x, y ]; }\n\n  // Calculate final matrix, if not exists\n  //\n  // NB. if you deside to apply transforms to point one-by-one,\n  // they should be taken in reverse order\n\n  if (!this.cache) {\n    this.cache = this.toArray();\n  }\n\n  m = this.cache;\n\n  // Apply matrix to point\n  return [\n    x * m[0] + y * m[2] + (isRelative ? 0 : m[4]),\n    x * m[1] + y * m[3] + (isRelative ? 0 : m[5])\n  ];\n};\n\n\nmodule.exports = Matrix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvbWF0cml4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG1DQUFtQztBQUNuQyxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvbWF0cml4LmpzPzI3NWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBjb21iaW5lIDIgbWF0cml4ZXNcbi8vIG0xLCBtMiAtIFthLCBiLCBjLCBkLCBlLCBnXVxuLy9cbmZ1bmN0aW9uIGNvbWJpbmUobTEsIG0yKSB7XG4gIHJldHVybiBbXG4gICAgbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sXG4gICAgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sXG4gICAgbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM10sXG4gICAgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sXG4gICAgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSxcbiAgICBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdXG4gIF07XG59XG5cblxuZnVuY3Rpb24gTWF0cml4KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWF0cml4KSkgeyByZXR1cm4gbmV3IE1hdHJpeCgpOyB9XG4gIHRoaXMucXVldWUgPSBbXTsgICAvLyBsaXN0IG9mIG1hdHJpeGVzIHRvIGFwcGx5XG4gIHRoaXMuY2FjaGUgPSBudWxsOyAvLyBjb21iaW5lZCBtYXRyaXggY2FjaGVcbn1cblxuXG5NYXRyaXgucHJvdG90eXBlLm1hdHJpeCA9IGZ1bmN0aW9uIChtKSB7XG4gIGlmIChtWzBdID09PSAxICYmIG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCAmJiBtWzNdID09PSAxICYmIG1bNF0gPT09IDAgJiYgbVs1XSA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuY2FjaGUgPSBudWxsO1xuICB0aGlzLnF1ZXVlLnB1c2gobSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5NYXRyaXgucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh0eCwgdHkpIHtcbiAgaWYgKHR4ICE9PSAwIHx8IHR5ICE9PSAwKSB7XG4gICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKFsgMSwgMCwgMCwgMSwgdHgsIHR5IF0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5NYXRyaXgucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHN4LCBzeSkge1xuICBpZiAoc3ggIT09IDEgfHwgc3kgIT09IDEpIHtcbiAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlLnB1c2goWyBzeCwgMCwgMCwgc3ksIDAsIDAgXSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbk1hdHJpeC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlLCByeCwgcnkpIHtcbiAgdmFyIHJhZCwgY29zLCBzaW47XG5cbiAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgdGhpcy50cmFuc2xhdGUocngsIHJ5KTtcblxuICAgIHJhZCA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICBjb3MgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHNpbiA9IE1hdGguc2luKHJhZCk7XG5cbiAgICB0aGlzLnF1ZXVlLnB1c2goWyBjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwIF0pO1xuICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuXG4gICAgdGhpcy50cmFuc2xhdGUoLXJ4LCAtcnkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5NYXRyaXgucHJvdG90eXBlLnNrZXdYID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSAhPT0gMCkge1xuICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuICAgIHRoaXMucXVldWUucHVzaChbIDEsIDAsIE1hdGgudGFuKGFuZ2xlICogTWF0aC5QSSAvIDE4MCksIDEsIDAsIDAgXSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbk1hdHJpeC5wcm90b3R5cGUuc2tld1kgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKFsgMSwgTWF0aC50YW4oYW5nbGUgKiBNYXRoLlBJIC8gMTgwKSwgMCwgMSwgMCwgMCBdKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gRmxhdHRlbiBxdWV1ZVxuLy9cbk1hdHJpeC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgfVxuXG4gIGlmICghdGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICB0aGlzLmNhY2hlID0gWyAxLCAwLCAwLCAxLCAwLCAwIF07XG4gICAgcmV0dXJuIHRoaXMuY2FjaGU7XG4gIH1cblxuICB0aGlzLmNhY2hlID0gdGhpcy5xdWV1ZVswXTtcblxuICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuY2FjaGUgPSBjb21iaW5lKHRoaXMuY2FjaGUsIHRoaXMucXVldWVbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY2FjaGU7XG59O1xuXG5cbi8vIEFwcGx5IGxpc3Qgb2YgbWF0cml4ZXMgdG8gKHgseSkgcG9pbnQuXG4vLyBJZiBgaXNSZWxhdGl2ZWAgc2V0LCBgdHJhbnNsYXRlYCBjb21wb25lbnQgb2YgbWF0cml4IHdpbGwgYmUgc2tpcHBlZFxuLy9cbk1hdHJpeC5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uICh4LCB5LCBpc1JlbGF0aXZlKSB7XG4gIHZhciBtO1xuXG4gIC8vIERvbid0IGNoYW5nZSBwb2ludCBvbiBlbXB0eSB0cmFuc2Zvcm1zIHF1ZXVlXG4gIGlmICghdGhpcy5xdWV1ZS5sZW5ndGgpIHsgcmV0dXJuIFsgeCwgeSBdOyB9XG5cbiAgLy8gQ2FsY3VsYXRlIGZpbmFsIG1hdHJpeCwgaWYgbm90IGV4aXN0c1xuICAvL1xuICAvLyBOQi4gaWYgeW91IGRlc2lkZSB0byBhcHBseSB0cmFuc2Zvcm1zIHRvIHBvaW50IG9uZS1ieS1vbmUsXG4gIC8vIHRoZXkgc2hvdWxkIGJlIHRha2VuIGluIHJldmVyc2Ugb3JkZXJcblxuICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICB0aGlzLmNhY2hlID0gdGhpcy50b0FycmF5KCk7XG4gIH1cblxuICBtID0gdGhpcy5jYWNoZTtcblxuICAvLyBBcHBseSBtYXRyaXggdG8gcG9pbnRcbiAgcmV0dXJuIFtcbiAgICB4ICogbVswXSArIHkgKiBtWzJdICsgKGlzUmVsYXRpdmUgPyAwIDogbVs0XSksXG4gICAgeCAqIG1bMV0gKyB5ICogbVszXSArIChpc1JlbGF0aXZlID8gMCA6IG1bNV0pXG4gIF07XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/svgpath/lib/matrix.js\n");

/***/ }),

/***/ "./node_modules/svgpath/lib/path_parse.js":
/*!************************************************!*\
  !*** ./node_modules/svgpath/lib/path_parse.js ***!
  \************************************************/
/***/ (function(module) {

eval("\n\n\nvar paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };\n\nvar SPECIAL_SPACES = [\n  0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,\n  0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF\n];\n\nfunction isSpace(ch) {\n  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) || // Line terminators\n    // White spaces\n    (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n    (ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0);\n}\n\nfunction isCommand(code) {\n  /*eslint-disable no-bitwise*/\n  switch (code | 0x20) {\n    case 0x6D/* m */:\n    case 0x7A/* z */:\n    case 0x6C/* l */:\n    case 0x68/* h */:\n    case 0x76/* v */:\n    case 0x63/* c */:\n    case 0x73/* s */:\n    case 0x71/* q */:\n    case 0x74/* t */:\n    case 0x61/* a */:\n    case 0x72/* r */:\n      return true;\n  }\n  return false;\n}\n\nfunction isArc(code) {\n  return (code | 0x20) === 0x61;\n}\n\nfunction isDigit(code) {\n  return (code >= 48 && code <= 57);   // 0..9\n}\n\nfunction isDigitStart(code) {\n  return (code >= 48 && code <= 57) || /* 0..9 */\n          code === 0x2B || /* + */\n          code === 0x2D || /* - */\n          code === 0x2E;   /* . */\n}\n\n\nfunction State(path) {\n  this.index  = 0;\n  this.path   = path;\n  this.max    = path.length;\n  this.result = [];\n  this.param  = 0.0;\n  this.err    = '';\n  this.segmentStart = 0;\n  this.data   = [];\n}\n\nfunction skipSpaces(state) {\n  while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {\n    state.index++;\n  }\n}\n\n\nfunction scanFlag(state) {\n  var ch = state.path.charCodeAt(state.index);\n\n  if (ch === 0x30/* 0 */) {\n    state.param = 0;\n    state.index++;\n    return;\n  }\n\n  if (ch === 0x31/* 1 */) {\n    state.param = 1;\n    state.index++;\n    return;\n  }\n\n  state.err = 'SvgPath: arc flag can be 0 or 1 only (at pos ' + state.index + ')';\n}\n\n\nfunction scanParam(state) {\n  var start = state.index,\n      index = start,\n      max = state.max,\n      zeroFirst = false,\n      hasCeiling = false,\n      hasDecimal = false,\n      hasDot = false,\n      ch;\n\n  if (index >= max) {\n    state.err = 'SvgPath: missed param (at pos ' + index + ')';\n    return;\n  }\n  ch = state.path.charCodeAt(index);\n\n  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n    index++;\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  //\n  if (!isDigit(ch) && ch !== 0x2E/* . */) {\n    state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    return;\n  }\n\n  if (ch !== 0x2E/* . */) {\n    zeroFirst = (ch === 0x30/* 0 */);\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        state.err = 'SvgPath: numbers started with `0` such as `09` are illegal (at pos ' + start + ')';\n        return;\n      }\n    }\n\n    while (index < max && isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasCeiling = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x2E/* . */) {\n    hasDot = true;\n    index++;\n    while (isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasDecimal = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x65/* e */ || ch === 0x45/* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      index++;\n    }\n    if (index < max && isDigit(state.path.charCodeAt(index))) {\n      while (index < max && isDigit(state.path.charCodeAt(index))) {\n        index++;\n      }\n    } else {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n  }\n\n  state.index = index;\n  state.param = parseFloat(state.path.slice(start, index)) + 0.0;\n}\n\n\nfunction finalizeSegment(state) {\n  var cmd, cmdLC;\n\n  // Process duplicated commands (without comand name)\n\n  // This logic is shamelessly borrowed from Raphael\n  // https://github.com/DmitryBaranovskiy/raphael/\n  //\n  cmd   = state.path[state.segmentStart];\n  cmdLC = cmd.toLowerCase();\n\n  var params = state.data;\n\n  if (cmdLC === 'm' && params.length > 2) {\n    state.result.push([ cmd, params[0], params[1] ]);\n    params = params.slice(2);\n    cmdLC = 'l';\n    cmd = (cmd === 'm') ? 'l' : 'L';\n  }\n\n  if (cmdLC === 'r') {\n    state.result.push([ cmd ].concat(params));\n  } else {\n\n    while (params.length >= paramCounts[cmdLC]) {\n      state.result.push([ cmd ].concat(params.splice(0, paramCounts[cmdLC])));\n      if (!paramCounts[cmdLC]) {\n        break;\n      }\n    }\n  }\n}\n\n\nfunction scanSegment(state) {\n  var max = state.max,\n      cmdCode, is_arc, comma_found, need_params, i;\n\n  state.segmentStart = state.index;\n  cmdCode = state.path.charCodeAt(state.index);\n  is_arc = isArc(cmdCode);\n\n  if (!isCommand(cmdCode)) {\n    state.err = 'SvgPath: bad command ' + state.path[state.index] + ' (at pos ' + state.index + ')';\n    return;\n  }\n\n  need_params = paramCounts[state.path[state.index].toLowerCase()];\n\n  state.index++;\n  skipSpaces(state);\n\n  state.data = [];\n\n  if (!need_params) {\n    // Z\n    finalizeSegment(state);\n    return;\n  }\n\n  comma_found = false;\n\n  for (;;) {\n    for (i = need_params; i > 0; i--) {\n      if (is_arc && (i === 3 || i === 4)) scanFlag(state);\n      else scanParam(state);\n\n      if (state.err.length) {\n        finalizeSegment(state);\n        return;\n      }\n      state.data.push(state.param);\n\n      skipSpaces(state);\n      comma_found = false;\n\n      if (state.index < max && state.path.charCodeAt(state.index) === 0x2C/* , */) {\n        state.index++;\n        skipSpaces(state);\n        comma_found = true;\n      }\n    }\n\n    // after ',' param is mandatory\n    if (comma_found) {\n      continue;\n    }\n\n    if (state.index >= state.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(state.path.charCodeAt(state.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(state);\n}\n\n\n/* Returns array of segments:\n *\n * [\n *   [ command, coord1, coord2, ... ]\n * ]\n */\nmodule.exports = function pathParse(svgPath) {\n  var state = new State(svgPath);\n  var max = state.max;\n\n  skipSpaces(state);\n\n  while (state.index < max && !state.err.length) {\n    scanSegment(state);\n  }\n\n  if (state.result.length) {\n    if ('mM'.indexOf(state.result[0][0]) < 0) {\n      state.err = 'SvgPath: string should start with `M` or `m`';\n      state.result = [];\n    } else {\n      state.result[0][0] = 'M';\n    }\n  }\n\n  return {\n    err: state.err,\n    segments: state.result\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvcGF0aF9wYXJzZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7O0FBR2Isb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1QsMEJBQTBCLE9BQU87QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N2Z3BhdGgvbGliL3BhdGhfcGFyc2UuanM/MzMyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIHBhcmFtQ291bnRzID0geyBhOiA3LCBjOiA2LCBoOiAxLCBsOiAyLCBtOiAyLCByOiA0LCBxOiA0LCBzOiA0LCB0OiAyLCB2OiAxLCB6OiAwIH07XG5cbnZhciBTUEVDSUFMX1NQQUNFUyA9IFtcbiAgMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNixcbiAgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZcbl07XG5cbmZ1bmN0aW9uIGlzU3BhY2UoY2gpIHtcbiAgcmV0dXJuIChjaCA9PT0gMHgwQSkgfHwgKGNoID09PSAweDBEKSB8fCAoY2ggPT09IDB4MjAyOCkgfHwgKGNoID09PSAweDIwMjkpIHx8IC8vIExpbmUgdGVybWluYXRvcnNcbiAgICAvLyBXaGl0ZSBzcGFjZXNcbiAgICAoY2ggPT09IDB4MjApIHx8IChjaCA9PT0gMHgwOSkgfHwgKGNoID09PSAweDBCKSB8fCAoY2ggPT09IDB4MEMpIHx8IChjaCA9PT0gMHhBMCkgfHxcbiAgICAoY2ggPj0gMHgxNjgwICYmIFNQRUNJQUxfU1BBQ0VTLmluZGV4T2YoY2gpID49IDApO1xufVxuXG5mdW5jdGlvbiBpc0NvbW1hbmQoY29kZSkge1xuICAvKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuICBzd2l0Y2ggKGNvZGUgfCAweDIwKSB7XG4gICAgY2FzZSAweDZELyogbSAqLzpcbiAgICBjYXNlIDB4N0EvKiB6ICovOlxuICAgIGNhc2UgMHg2Qy8qIGwgKi86XG4gICAgY2FzZSAweDY4LyogaCAqLzpcbiAgICBjYXNlIDB4NzYvKiB2ICovOlxuICAgIGNhc2UgMHg2My8qIGMgKi86XG4gICAgY2FzZSAweDczLyogcyAqLzpcbiAgICBjYXNlIDB4NzEvKiBxICovOlxuICAgIGNhc2UgMHg3NC8qIHQgKi86XG4gICAgY2FzZSAweDYxLyogYSAqLzpcbiAgICBjYXNlIDB4NzIvKiByICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0FyYyhjb2RlKSB7XG4gIHJldHVybiAoY29kZSB8IDB4MjApID09PSAweDYxO1xufVxuXG5mdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgcmV0dXJuIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpOyAgIC8vIDAuLjlcbn1cblxuZnVuY3Rpb24gaXNEaWdpdFN0YXJ0KGNvZGUpIHtcbiAgcmV0dXJuIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8IC8qIDAuLjkgKi9cbiAgICAgICAgICBjb2RlID09PSAweDJCIHx8IC8qICsgKi9cbiAgICAgICAgICBjb2RlID09PSAweDJEIHx8IC8qIC0gKi9cbiAgICAgICAgICBjb2RlID09PSAweDJFOyAgIC8qIC4gKi9cbn1cblxuXG5mdW5jdGlvbiBTdGF0ZShwYXRoKSB7XG4gIHRoaXMuaW5kZXggID0gMDtcbiAgdGhpcy5wYXRoICAgPSBwYXRoO1xuICB0aGlzLm1heCAgICA9IHBhdGgubGVuZ3RoO1xuICB0aGlzLnJlc3VsdCA9IFtdO1xuICB0aGlzLnBhcmFtICA9IDAuMDtcbiAgdGhpcy5lcnIgICAgPSAnJztcbiAgdGhpcy5zZWdtZW50U3RhcnQgPSAwO1xuICB0aGlzLmRhdGEgICA9IFtdO1xufVxuXG5mdW5jdGlvbiBza2lwU3BhY2VzKHN0YXRlKSB7XG4gIHdoaWxlIChzdGF0ZS5pbmRleCA8IHN0YXRlLm1heCAmJiBpc1NwYWNlKHN0YXRlLnBhdGguY2hhckNvZGVBdChzdGF0ZS5pbmRleCkpKSB7XG4gICAgc3RhdGUuaW5kZXgrKztcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNjYW5GbGFnKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLnBhdGguY2hhckNvZGVBdChzdGF0ZS5pbmRleCk7XG5cbiAgaWYgKGNoID09PSAweDMwLyogMCAqLykge1xuICAgIHN0YXRlLnBhcmFtID0gMDtcbiAgICBzdGF0ZS5pbmRleCsrO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzMS8qIDEgKi8pIHtcbiAgICBzdGF0ZS5wYXJhbSA9IDE7XG4gICAgc3RhdGUuaW5kZXgrKztcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lcnIgPSAnU3ZnUGF0aDogYXJjIGZsYWcgY2FuIGJlIDAgb3IgMSBvbmx5IChhdCBwb3MgJyArIHN0YXRlLmluZGV4ICsgJyknO1xufVxuXG5cbmZ1bmN0aW9uIHNjYW5QYXJhbShzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5pbmRleCxcbiAgICAgIGluZGV4ID0gc3RhcnQsXG4gICAgICBtYXggPSBzdGF0ZS5tYXgsXG4gICAgICB6ZXJvRmlyc3QgPSBmYWxzZSxcbiAgICAgIGhhc0NlaWxpbmcgPSBmYWxzZSxcbiAgICAgIGhhc0RlY2ltYWwgPSBmYWxzZSxcbiAgICAgIGhhc0RvdCA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKGluZGV4ID49IG1heCkge1xuICAgIHN0YXRlLmVyciA9ICdTdmdQYXRoOiBtaXNzZWQgcGFyYW0gKGF0IHBvcyAnICsgaW5kZXggKyAnKSc7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNoID0gc3RhdGUucGF0aC5jaGFyQ29kZUF0KGluZGV4KTtcblxuICBpZiAoY2ggPT09IDB4MkIvKiArICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgIGluZGV4Kys7XG4gICAgY2ggPSAoaW5kZXggPCBtYXgpID8gc3RhdGUucGF0aC5jaGFyQ29kZUF0KGluZGV4KSA6IDA7XG4gIH1cblxuICAvLyBUaGlzIGxvZ2ljIGlzIHNoYW1lbGVzc2x5IGJvcnJvd2VkIGZyb20gRXNwcmltYVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvZXNwcmltYXNcbiAgLy9cbiAgaWYgKCFpc0RpZ2l0KGNoKSAmJiBjaCAhPT0gMHgyRS8qIC4gKi8pIHtcbiAgICBzdGF0ZS5lcnIgPSAnU3ZnUGF0aDogcGFyYW0gc2hvdWxkIHN0YXJ0IHdpdGggMC4uOSBvciBgLmAgKGF0IHBvcyAnICsgaW5kZXggKyAnKSc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoICE9PSAweDJFLyogLiAqLykge1xuICAgIHplcm9GaXJzdCA9IChjaCA9PT0gMHgzMC8qIDAgKi8pO1xuICAgIGluZGV4Kys7XG5cbiAgICBjaCA9IChpbmRleCA8IG1heCkgPyBzdGF0ZS5wYXRoLmNoYXJDb2RlQXQoaW5kZXgpIDogMDtcblxuICAgIGlmICh6ZXJvRmlyc3QgJiYgaW5kZXggPCBtYXgpIHtcbiAgICAgIC8vIGRlY2ltYWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJyBzdWNoIGFzICcwOScgaXMgaWxsZWdhbC5cbiAgICAgIGlmIChjaCAmJiBpc0RpZ2l0KGNoKSkge1xuICAgICAgICBzdGF0ZS5lcnIgPSAnU3ZnUGF0aDogbnVtYmVycyBzdGFydGVkIHdpdGggYDBgIHN1Y2ggYXMgYDA5YCBhcmUgaWxsZWdhbCAoYXQgcG9zICcgKyBzdGFydCArICcpJztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpbmRleCA8IG1heCAmJiBpc0RpZ2l0KHN0YXRlLnBhdGguY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgaGFzQ2VpbGluZyA9IHRydWU7XG4gICAgfVxuICAgIGNoID0gKGluZGV4IDwgbWF4KSA/IHN0YXRlLnBhdGguY2hhckNvZGVBdChpbmRleCkgOiAwO1xuICB9XG5cbiAgaWYgKGNoID09PSAweDJFLyogLiAqLykge1xuICAgIGhhc0RvdCA9IHRydWU7XG4gICAgaW5kZXgrKztcbiAgICB3aGlsZSAoaXNEaWdpdChzdGF0ZS5wYXRoLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGhhc0RlY2ltYWwgPSB0cnVlO1xuICAgIH1cbiAgICBjaCA9IChpbmRleCA8IG1heCkgPyBzdGF0ZS5wYXRoLmNoYXJDb2RlQXQoaW5kZXgpIDogMDtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHg2NS8qIGUgKi8gfHwgY2ggPT09IDB4NDUvKiBFICovKSB7XG4gICAgaWYgKGhhc0RvdCAmJiAhaGFzQ2VpbGluZyAmJiAhaGFzRGVjaW1hbCkge1xuICAgICAgc3RhdGUuZXJyID0gJ1N2Z1BhdGg6IGludmFsaWQgZmxvYXQgZXhwb25lbnQgKGF0IHBvcyAnICsgaW5kZXggKyAnKSc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5kZXgrKztcblxuICAgIGNoID0gKGluZGV4IDwgbWF4KSA/IHN0YXRlLnBhdGguY2hhckNvZGVBdChpbmRleCkgOiAwO1xuICAgIGlmIChjaCA9PT0gMHgyQi8qICsgKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCBtYXggJiYgaXNEaWdpdChzdGF0ZS5wYXRoLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgd2hpbGUgKGluZGV4IDwgbWF4ICYmIGlzRGlnaXQoc3RhdGUucGF0aC5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuZXJyID0gJ1N2Z1BhdGg6IGludmFsaWQgZmxvYXQgZXhwb25lbnQgKGF0IHBvcyAnICsgaW5kZXggKyAnKSc7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuaW5kZXggPSBpbmRleDtcbiAgc3RhdGUucGFyYW0gPSBwYXJzZUZsb2F0KHN0YXRlLnBhdGguc2xpY2Uoc3RhcnQsIGluZGV4KSkgKyAwLjA7XG59XG5cblxuZnVuY3Rpb24gZmluYWxpemVTZWdtZW50KHN0YXRlKSB7XG4gIHZhciBjbWQsIGNtZExDO1xuXG4gIC8vIFByb2Nlc3MgZHVwbGljYXRlZCBjb21tYW5kcyAod2l0aG91dCBjb21hbmQgbmFtZSlcblxuICAvLyBUaGlzIGxvZ2ljIGlzIHNoYW1lbGVzc2x5IGJvcnJvd2VkIGZyb20gUmFwaGFlbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vRG1pdHJ5QmFyYW5vdnNraXkvcmFwaGFlbC9cbiAgLy9cbiAgY21kICAgPSBzdGF0ZS5wYXRoW3N0YXRlLnNlZ21lbnRTdGFydF07XG4gIGNtZExDID0gY21kLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHBhcmFtcyA9IHN0YXRlLmRhdGE7XG5cbiAgaWYgKGNtZExDID09PSAnbScgJiYgcGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICBzdGF0ZS5yZXN1bHQucHVzaChbIGNtZCwgcGFyYW1zWzBdLCBwYXJhbXNbMV0gXSk7XG4gICAgcGFyYW1zID0gcGFyYW1zLnNsaWNlKDIpO1xuICAgIGNtZExDID0gJ2wnO1xuICAgIGNtZCA9IChjbWQgPT09ICdtJykgPyAnbCcgOiAnTCc7XG4gIH1cblxuICBpZiAoY21kTEMgPT09ICdyJykge1xuICAgIHN0YXRlLnJlc3VsdC5wdXNoKFsgY21kIF0uY29uY2F0KHBhcmFtcykpO1xuICB9IGVsc2Uge1xuXG4gICAgd2hpbGUgKHBhcmFtcy5sZW5ndGggPj0gcGFyYW1Db3VudHNbY21kTENdKSB7XG4gICAgICBzdGF0ZS5yZXN1bHQucHVzaChbIGNtZCBdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIHBhcmFtQ291bnRzW2NtZExDXSkpKTtcbiAgICAgIGlmICghcGFyYW1Db3VudHNbY21kTENdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNjYW5TZWdtZW50KHN0YXRlKSB7XG4gIHZhciBtYXggPSBzdGF0ZS5tYXgsXG4gICAgICBjbWRDb2RlLCBpc19hcmMsIGNvbW1hX2ZvdW5kLCBuZWVkX3BhcmFtcywgaTtcblxuICBzdGF0ZS5zZWdtZW50U3RhcnQgPSBzdGF0ZS5pbmRleDtcbiAgY21kQ29kZSA9IHN0YXRlLnBhdGguY2hhckNvZGVBdChzdGF0ZS5pbmRleCk7XG4gIGlzX2FyYyA9IGlzQXJjKGNtZENvZGUpO1xuXG4gIGlmICghaXNDb21tYW5kKGNtZENvZGUpKSB7XG4gICAgc3RhdGUuZXJyID0gJ1N2Z1BhdGg6IGJhZCBjb21tYW5kICcgKyBzdGF0ZS5wYXRoW3N0YXRlLmluZGV4XSArICcgKGF0IHBvcyAnICsgc3RhdGUuaW5kZXggKyAnKSc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbmVlZF9wYXJhbXMgPSBwYXJhbUNvdW50c1tzdGF0ZS5wYXRoW3N0YXRlLmluZGV4XS50b0xvd2VyQ2FzZSgpXTtcblxuICBzdGF0ZS5pbmRleCsrO1xuICBza2lwU3BhY2VzKHN0YXRlKTtcblxuICBzdGF0ZS5kYXRhID0gW107XG5cbiAgaWYgKCFuZWVkX3BhcmFtcykge1xuICAgIC8vIFpcbiAgICBmaW5hbGl6ZVNlZ21lbnQoc3RhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbW1hX2ZvdW5kID0gZmFsc2U7XG5cbiAgZm9yICg7Oykge1xuICAgIGZvciAoaSA9IG5lZWRfcGFyYW1zOyBpID4gMDsgaS0tKSB7XG4gICAgICBpZiAoaXNfYXJjICYmIChpID09PSAzIHx8IGkgPT09IDQpKSBzY2FuRmxhZyhzdGF0ZSk7XG4gICAgICBlbHNlIHNjYW5QYXJhbShzdGF0ZSk7XG5cbiAgICAgIGlmIChzdGF0ZS5lcnIubGVuZ3RoKSB7XG4gICAgICAgIGZpbmFsaXplU2VnbWVudChzdGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmRhdGEucHVzaChzdGF0ZS5wYXJhbSk7XG5cbiAgICAgIHNraXBTcGFjZXMoc3RhdGUpO1xuICAgICAgY29tbWFfZm91bmQgPSBmYWxzZTtcblxuICAgICAgaWYgKHN0YXRlLmluZGV4IDwgbWF4ICYmIHN0YXRlLnBhdGguY2hhckNvZGVBdChzdGF0ZS5pbmRleCkgPT09IDB4MkMvKiAsICovKSB7XG4gICAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgICAgIHNraXBTcGFjZXMoc3RhdGUpO1xuICAgICAgICBjb21tYV9mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWZ0ZXIgJywnIHBhcmFtIGlzIG1hbmRhdG9yeVxuICAgIGlmIChjb21tYV9mb3VuZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmluZGV4ID49IHN0YXRlLm1heCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gU3RvcCBvbiBuZXh0IHNlZ21lbnRcbiAgICBpZiAoIWlzRGlnaXRTdGFydChzdGF0ZS5wYXRoLmNoYXJDb2RlQXQoc3RhdGUuaW5kZXgpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZmluYWxpemVTZWdtZW50KHN0YXRlKTtcbn1cblxuXG4vKiBSZXR1cm5zIGFycmF5IG9mIHNlZ21lbnRzOlxuICpcbiAqIFtcbiAqICAgWyBjb21tYW5kLCBjb29yZDEsIGNvb3JkMiwgLi4uIF1cbiAqIF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXRoUGFyc2Uoc3ZnUGF0aCkge1xuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoc3ZnUGF0aCk7XG4gIHZhciBtYXggPSBzdGF0ZS5tYXg7XG5cbiAgc2tpcFNwYWNlcyhzdGF0ZSk7XG5cbiAgd2hpbGUgKHN0YXRlLmluZGV4IDwgbWF4ICYmICFzdGF0ZS5lcnIubGVuZ3RoKSB7XG4gICAgc2NhblNlZ21lbnQoc3RhdGUpO1xuICB9XG5cbiAgaWYgKHN0YXRlLnJlc3VsdC5sZW5ndGgpIHtcbiAgICBpZiAoJ21NJy5pbmRleE9mKHN0YXRlLnJlc3VsdFswXVswXSkgPCAwKSB7XG4gICAgICBzdGF0ZS5lcnIgPSAnU3ZnUGF0aDogc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIGBNYCBvciBgbWAnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnJlc3VsdFswXVswXSA9ICdNJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVycjogc3RhdGUuZXJyLFxuICAgIHNlZ21lbnRzOiBzdGF0ZS5yZXN1bHRcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/svgpath/lib/path_parse.js\n");

/***/ }),

/***/ "./node_modules/svgpath/lib/svgpath.js":
/*!*********************************************!*\
  !*** ./node_modules/svgpath/lib/svgpath.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// SVG Path transformations library\n//\n// Usage:\n//\n//    SvgPath('...')\n//      .translate(-150, -100)\n//      .scale(0.5)\n//      .translate(-150, -100)\n//      .toFixed(1)\n//      .toString()\n//\n\n\n\n\nvar pathParse      = __webpack_require__(/*! ./path_parse */ \"./node_modules/svgpath/lib/path_parse.js\");\nvar transformParse = __webpack_require__(/*! ./transform_parse */ \"./node_modules/svgpath/lib/transform_parse.js\");\nvar matrix         = __webpack_require__(/*! ./matrix */ \"./node_modules/svgpath/lib/matrix.js\");\nvar a2c            = __webpack_require__(/*! ./a2c */ \"./node_modules/svgpath/lib/a2c.js\");\nvar ellipse        = __webpack_require__(/*! ./ellipse */ \"./node_modules/svgpath/lib/ellipse.js\");\n\n\n// Class constructor\n//\nfunction SvgPath(path) {\n  if (!(this instanceof SvgPath)) { return new SvgPath(path); }\n\n  var pstate = pathParse(path);\n\n  // Array of path segments.\n  // Each segment is array [command, param1, param2, ...]\n  this.segments = pstate.segments;\n\n  // Error message on parse error.\n  this.err      = pstate.err;\n\n  // Transforms stack for lazy evaluation\n  this.__stack    = [];\n}\n\nSvgPath.from = function (src) {\n  if (typeof src === 'string') return new SvgPath(src);\n\n  if (src instanceof SvgPath) {\n    // Create empty object\n    var s = new SvgPath('');\n\n    // Clone properies\n    s.err = src.err;\n    s.segments = src.segments.map(function (sgm) { return sgm.slice(); });\n    s.__stack = src.__stack.map(function (m) {\n      return matrix().matrix(m.toArray());\n    });\n\n    return s;\n  }\n\n  throw new Error('SvgPath.from: invalid param type ' + src);\n};\n\n\nSvgPath.prototype.__matrix = function (m) {\n  var self = this, i;\n\n  // Quick leave for empty matrix\n  if (!m.queue.length) { return; }\n\n  this.iterate(function (s, index, x, y) {\n    var p, result, name, isRelative;\n\n    switch (s[0]) {\n\n      // Process 'assymetric' commands separately\n      case 'v':\n        p      = m.calc(0, s[1], true);\n        result = (p[0] === 0) ? [ 'v', p[1] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'V':\n        p      = m.calc(x, s[1], false);\n        result = (p[0] === m.calc(x, y, false)[0]) ? [ 'V', p[1] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'h':\n        p      = m.calc(s[1], 0, true);\n        result = (p[1] === 0) ? [ 'h', p[0] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'H':\n        p      = m.calc(s[1], y, false);\n        result = (p[1] === m.calc(x, y, false)[1]) ? [ 'H', p[0] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'a':\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n\n        // Drop segment if arc is empty (end point === start point)\n        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          return [];\n        }*/\n\n        // Transform rx, ry and the x-axis-rotation\n        var ma = m.toArray();\n        var e = ellipse(s[1], s[2], s[3]).transform(ma);\n\n        // flip sweep-flag if matrix is not orientation-preserving\n        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {\n          s[5] = s[5] ? '0' : '1';\n        }\n\n        // Transform end point as usual (without translation for relative notation)\n        p = m.calc(s[6], s[7], s[0] === 'a');\n\n        // Empty arcs can be ignored by renderer, but should not be dropped\n        // to avoid collisions with `S A S` and so on. Replace with empty line.\n        if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n          break;\n        }\n\n        // if the resulting ellipse is (almost) a segment ...\n        if (e.isDegenerate()) {\n          // replace the arc by a line\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n        } else {\n          // if it is a real ellipse\n          // s[0], s[4] and s[5] are not modified\n          result = [ s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1] ];\n        }\n\n        break;\n\n      case 'm':\n        // Edge case. The very first `m` should be processed as absolute, if happens.\n        // Make sense for coord shift transforms.\n        isRelative = index > 0;\n\n        p = m.calc(s[1], s[2], isRelative);\n        result = [ 'm', p[0], p[1] ];\n        break;\n\n      default:\n        name       = s[0];\n        result     = [ name ];\n        isRelative = (name.toLowerCase() === name);\n\n        // Apply transformations to the segment\n        for (i = 1; i < s.length; i += 2) {\n          p = m.calc(s[i], s[i + 1], isRelative);\n          result.push(p[0], p[1]);\n        }\n    }\n\n    self.segments[index] = result;\n  }, true);\n};\n\n\n// Apply stacked commands\n//\nSvgPath.prototype.__evaluateStack = function () {\n  var m, i;\n\n  if (!this.__stack.length) { return; }\n\n  if (this.__stack.length === 1) {\n    this.__matrix(this.__stack[0]);\n    this.__stack = [];\n    return;\n  }\n\n  m = matrix();\n  i = this.__stack.length;\n\n  while (--i >= 0) {\n    m.matrix(this.__stack[i].toArray());\n  }\n\n  this.__matrix(m);\n  this.__stack = [];\n};\n\n\n// Convert processed SVG Path back to string\n//\nSvgPath.prototype.toString = function () {\n  var result = '', prevCmd = '', cmdSkipped = false;\n\n  this.__evaluateStack();\n\n  for (var i = 0, len = this.segments.length; i < len; i++) {\n    var segment = this.segments[i];\n    var cmd = segment[0];\n\n    // Command not repeating => store\n    if (cmd !== prevCmd || cmd === 'm' || cmd === 'M') {\n      // workaround for FontForge SVG importing bug, keep space between \"z m\".\n      if (cmd === 'm' && prevCmd === 'z') result += ' ';\n      result += cmd;\n\n      cmdSkipped = false;\n    } else {\n      cmdSkipped = true;\n    }\n\n    // Store segment params\n    for (var pos = 1; pos < segment.length; pos++) {\n      var val = segment[pos];\n      // Space can be skipped\n      // 1. After command (always)\n      // 2. For negative value (with '-' at start)\n      if (pos === 1) {\n        if (cmdSkipped && val >= 0) result += ' ';\n      } else if (val >= 0) result += ' ';\n\n      result += val;\n    }\n\n    prevCmd = cmd;\n  }\n\n  return result;\n};\n\n\n// Translate path to (x [, y])\n//\nSvgPath.prototype.translate = function (x, y) {\n  this.__stack.push(matrix().translate(x, y || 0));\n  return this;\n};\n\n\n// Scale path to (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.scale = function (sx, sy) {\n  this.__stack.push(matrix().scale(sx, (!sy && (sy !== 0)) ? sx : sy));\n  return this;\n};\n\n\n// Rotate path around point (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.rotate = function (angle, rx, ry) {\n  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));\n  return this;\n};\n\n\n// Skew path along the X axis by `degrees` angle\n//\nSvgPath.prototype.skewX = function (degrees) {\n  this.__stack.push(matrix().skewX(degrees));\n  return this;\n};\n\n\n// Skew path along the Y axis by `degrees` angle\n//\nSvgPath.prototype.skewY = function (degrees) {\n  this.__stack.push(matrix().skewY(degrees));\n  return this;\n};\n\n\n// Apply matrix transform (array of 6 elements)\n//\nSvgPath.prototype.matrix = function (m) {\n  this.__stack.push(matrix().matrix(m));\n  return this;\n};\n\n\n// Transform path according to \"transform\" attr of SVG spec\n//\nSvgPath.prototype.transform = function (transformString) {\n  if (!transformString.trim()) {\n    return this;\n  }\n  this.__stack.push(transformParse(transformString));\n  return this;\n};\n\n\n// Round coords with given decimal precition.\n// 0 by default (to integers)\n//\nSvgPath.prototype.round = function (d) {\n  var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l;\n\n  d = d || 0;\n\n  this.__evaluateStack();\n\n  this.segments.forEach(function (s) {\n    var isRelative = (s[0].toLowerCase() === s[0]);\n\n    switch (s[0]) {\n      case 'H':\n      case 'h':\n        if (isRelative) { s[1] += deltaX; }\n        deltaX = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'V':\n      case 'v':\n        if (isRelative) { s[1] += deltaY; }\n        deltaY = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'Z':\n      case 'z':\n        deltaX = contourStartDeltaX;\n        deltaY = contourStartDeltaY;\n        return;\n\n      case 'M':\n      case 'm':\n        if (isRelative) {\n          s[1] += deltaX;\n          s[2] += deltaY;\n        }\n\n        deltaX = s[1] - s[1].toFixed(d);\n        deltaY = s[2] - s[2].toFixed(d);\n\n        contourStartDeltaX = deltaX;\n        contourStartDeltaY = deltaY;\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        return;\n\n      case 'A':\n      case 'a':\n        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        if (isRelative) {\n          s[6] += deltaX;\n          s[7] += deltaY;\n        }\n\n        deltaX = s[6] - s[6].toFixed(d);\n        deltaY = s[7] - s[7].toFixed(d);\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        s[3] = +s[3].toFixed(d + 2); // better precision for rotation\n        s[6] = +s[6].toFixed(d);\n        s[7] = +s[7].toFixed(d);\n        return;\n\n      default:\n        // a c l q s t\n        l = s.length;\n\n        if (isRelative) {\n          s[l - 2] += deltaX;\n          s[l - 1] += deltaY;\n        }\n\n        deltaX = s[l - 2] - s[l - 2].toFixed(d);\n        deltaY = s[l - 1] - s[l - 1].toFixed(d);\n\n        s.forEach(function (val, i) {\n          if (!i) { return; }\n          s[i] = +s[i].toFixed(d);\n        });\n        return;\n    }\n  });\n\n  return this;\n};\n\n\n// Apply iterator function to all segments. If function returns result,\n// current segment will be replaced to array of returned segments.\n// If empty array is returned, current regment will be deleted.\n//\nSvgPath.prototype.iterate = function (iterator, keepLazyStack) {\n  var segments = this.segments,\n      replacements = {},\n      needReplace = false,\n      lastX = 0,\n      lastY = 0,\n      countourStartX = 0,\n      countourStartY = 0;\n  var i, j, newSegments;\n\n  if (!keepLazyStack) {\n    this.__evaluateStack();\n  }\n\n  segments.forEach(function (s, index) {\n\n    var res = iterator(s, index, lastX, lastY);\n\n    if (Array.isArray(res)) {\n      replacements[index] = res;\n      needReplace = true;\n    }\n\n    var isRelative = (s[0] === s[0].toLowerCase());\n\n    // calculate absolute X and Y\n    switch (s[0]) {\n      case 'm':\n      case 'M':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        lastY = s[2] + (isRelative ? lastY : 0);\n        countourStartX = lastX;\n        countourStartY = lastY;\n        return;\n\n      case 'h':\n      case 'H':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        return;\n\n      case 'v':\n      case 'V':\n        lastY = s[1] + (isRelative ? lastY : 0);\n        return;\n\n      case 'z':\n      case 'Z':\n        // That make sence for multiple contours\n        lastX = countourStartX;\n        lastY = countourStartY;\n        return;\n\n      default:\n        lastX = s[s.length - 2] + (isRelative ? lastX : 0);\n        lastY = s[s.length - 1] + (isRelative ? lastY : 0);\n    }\n  });\n\n  // Replace segments if iterator return results\n\n  if (!needReplace) { return this; }\n\n  newSegments = [];\n\n  for (i = 0; i < segments.length; i++) {\n    if (typeof replacements[i] !== 'undefined') {\n      for (j = 0; j < replacements[i].length; j++) {\n        newSegments.push(replacements[i][j]);\n      }\n    } else {\n      newSegments.push(segments[i]);\n    }\n  }\n\n  this.segments = newSegments;\n\n  return this;\n};\n\n\n// Converts segments from relative to absolute\n//\nSvgPath.prototype.abs = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameUC = name.toUpperCase(),\n        i;\n\n    // Skip absolute commands\n    if (name === nameUC) { return; }\n\n    s[0] = nameUC;\n\n    switch (name) {\n      case 'v':\n        // v has shifted coords parity\n        s[1] += y;\n        return;\n\n      case 'a':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] += x;\n        s[7] += y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] += i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts segments from absolute to relative\n//\nSvgPath.prototype.rel = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameLC = name.toLowerCase(),\n        i;\n\n    // Skip relative commands\n    if (name === nameLC) { return; }\n\n    // Don't touch the first M to avoid potential confusions.\n    if (index === 0 && name === 'M') { return; }\n\n    s[0] = nameLC;\n\n    switch (name) {\n      case 'V':\n        // V has shifted coords parity\n        s[1] -= y;\n        return;\n\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] -= x;\n        s[7] -= y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] -= i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts arcs to cubic bézier curves\n//\nSvgPath.prototype.unarc = function () {\n  this.iterate(function (s, index, x, y) {\n    var new_segments, nextX, nextY, result = [], name = s[0];\n\n    // Skip anything except arcs\n    if (name !== 'A' && name !== 'a') { return null; }\n\n    if (name === 'a') {\n      // convert relative arc coordinates to absolute\n      nextX = x + s[6];\n      nextY = y + s[7];\n    } else {\n      nextX = s[6];\n      nextY = s[7];\n    }\n\n    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);\n\n    // Degenerated arcs can be ignored by renderer, but should not be dropped\n    // to avoid collisions with `S A S` and so on. Replace with empty line.\n    if (new_segments.length === 0) {\n      return [ [ s[0] === 'a' ? 'l' : 'L', s[6], s[7] ] ];\n    }\n\n    new_segments.forEach(function (s) {\n      result.push([ 'C', s[2], s[3], s[4], s[5], s[6], s[7] ]);\n    });\n\n    return result;\n  });\n\n  return this;\n};\n\n\n// Converts smooth curves (with missed control point) to generic curves\n//\nSvgPath.prototype.unshort = function () {\n  var segments = this.segments;\n  var prevControlX, prevControlY, prevSegment;\n  var curControlX, curControlY;\n\n  // TODO: add lazy evaluation flag when relative commands supported\n\n  this.iterate(function (s, idx, x, y) {\n    var name = s[0], nameUC = name.toUpperCase(), isRelative;\n\n    // First command MUST be M|m, it's safe to skip.\n    // Protect from access to [-1] for sure.\n    if (!idx) { return; }\n\n    if (nameUC === 'T') { // quadratic curve\n      isRelative = (name === 't');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'Q') {\n        prevControlX = prevSegment[1] - x;\n        prevControlY = prevSegment[2] - y;\n      } else if (prevSegment[0] === 'q') {\n        prevControlX = prevSegment[1] - prevSegment[3];\n        prevControlY = prevSegment[2] - prevSegment[4];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'q' : 'Q',\n        curControlX, curControlY,\n        s[1], s[2]\n      ];\n\n    } else if (nameUC === 'S') { // cubic curve\n      isRelative = (name === 's');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'C') {\n        prevControlX = prevSegment[3] - x;\n        prevControlY = prevSegment[4] - y;\n      } else if (prevSegment[0] === 'c') {\n        prevControlX = prevSegment[3] - prevSegment[5];\n        prevControlY = prevSegment[4] - prevSegment[6];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'c' : 'C',\n        curControlX, curControlY,\n        s[1], s[2], s[3], s[4]\n      ];\n    }\n  });\n\n  return this;\n};\n\n\nmodule.exports = SvgPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvc3ZncGF0aC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7QUFHYixxQkFBcUIsbUJBQU8sQ0FBQyw4REFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyx3RUFBbUI7QUFDaEQscUJBQXFCLG1CQUFPLENBQUMsc0RBQVU7QUFDdkMscUJBQXFCLG1CQUFPLENBQUMsZ0RBQU87QUFDcEMscUJBQXFCLG1CQUFPLENBQUMsd0RBQVc7OztBQUd4QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELHFCQUFxQjtBQUN4RTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBLHNCQUFzQjs7QUFFdEI7O0FBRUEsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLHVDQUF1Qzs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLDBCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sMkJBQTJCO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N2Z3BhdGgvbGliL3N2Z3BhdGguanM/MDllZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTVkcgUGF0aCB0cmFuc2Zvcm1hdGlvbnMgbGlicmFyeVxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vICAgIFN2Z1BhdGgoJy4uLicpXG4vLyAgICAgIC50cmFuc2xhdGUoLTE1MCwgLTEwMClcbi8vICAgICAgLnNjYWxlKDAuNSlcbi8vICAgICAgLnRyYW5zbGF0ZSgtMTUwLCAtMTAwKVxuLy8gICAgICAudG9GaXhlZCgxKVxuLy8gICAgICAudG9TdHJpbmcoKVxuLy9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBwYXRoUGFyc2UgICAgICA9IHJlcXVpcmUoJy4vcGF0aF9wYXJzZScpO1xudmFyIHRyYW5zZm9ybVBhcnNlID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1fcGFyc2UnKTtcbnZhciBtYXRyaXggICAgICAgICA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG52YXIgYTJjICAgICAgICAgICAgPSByZXF1aXJlKCcuL2EyYycpO1xudmFyIGVsbGlwc2UgICAgICAgID0gcmVxdWlyZSgnLi9lbGxpcHNlJyk7XG5cblxuLy8gQ2xhc3MgY29uc3RydWN0b3Jcbi8vXG5mdW5jdGlvbiBTdmdQYXRoKHBhdGgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN2Z1BhdGgpKSB7IHJldHVybiBuZXcgU3ZnUGF0aChwYXRoKTsgfVxuXG4gIHZhciBwc3RhdGUgPSBwYXRoUGFyc2UocGF0aCk7XG5cbiAgLy8gQXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgLy8gRWFjaCBzZWdtZW50IGlzIGFycmF5IFtjb21tYW5kLCBwYXJhbTEsIHBhcmFtMiwgLi4uXVxuICB0aGlzLnNlZ21lbnRzID0gcHN0YXRlLnNlZ21lbnRzO1xuXG4gIC8vIEVycm9yIG1lc3NhZ2Ugb24gcGFyc2UgZXJyb3IuXG4gIHRoaXMuZXJyICAgICAgPSBwc3RhdGUuZXJyO1xuXG4gIC8vIFRyYW5zZm9ybXMgc3RhY2sgZm9yIGxhenkgZXZhbHVhdGlvblxuICB0aGlzLl9fc3RhY2sgICAgPSBbXTtcbn1cblxuU3ZnUGF0aC5mcm9tID0gZnVuY3Rpb24gKHNyYykge1xuICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHJldHVybiBuZXcgU3ZnUGF0aChzcmMpO1xuXG4gIGlmIChzcmMgaW5zdGFuY2VvZiBTdmdQYXRoKSB7XG4gICAgLy8gQ3JlYXRlIGVtcHR5IG9iamVjdFxuICAgIHZhciBzID0gbmV3IFN2Z1BhdGgoJycpO1xuXG4gICAgLy8gQ2xvbmUgcHJvcGVyaWVzXG4gICAgcy5lcnIgPSBzcmMuZXJyO1xuICAgIHMuc2VnbWVudHMgPSBzcmMuc2VnbWVudHMubWFwKGZ1bmN0aW9uIChzZ20pIHsgcmV0dXJuIHNnbS5zbGljZSgpOyB9KTtcbiAgICBzLl9fc3RhY2sgPSBzcmMuX19zdGFjay5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtYXRyaXgoKS5tYXRyaXgobS50b0FycmF5KCkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1N2Z1BhdGguZnJvbTogaW52YWxpZCBwYXJhbSB0eXBlICcgKyBzcmMpO1xufTtcblxuXG5TdmdQYXRoLnByb3RvdHlwZS5fX21hdHJpeCA9IGZ1bmN0aW9uIChtKSB7XG4gIHZhciBzZWxmID0gdGhpcywgaTtcblxuICAvLyBRdWljayBsZWF2ZSBmb3IgZW1wdHkgbWF0cml4XG4gIGlmICghbS5xdWV1ZS5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cbiAgdGhpcy5pdGVyYXRlKGZ1bmN0aW9uIChzLCBpbmRleCwgeCwgeSkge1xuICAgIHZhciBwLCByZXN1bHQsIG5hbWUsIGlzUmVsYXRpdmU7XG5cbiAgICBzd2l0Y2ggKHNbMF0pIHtcblxuICAgICAgLy8gUHJvY2VzcyAnYXNzeW1ldHJpYycgY29tbWFuZHMgc2VwYXJhdGVseVxuICAgICAgY2FzZSAndic6XG4gICAgICAgIHAgICAgICA9IG0uY2FsYygwLCBzWzFdLCB0cnVlKTtcbiAgICAgICAgcmVzdWx0ID0gKHBbMF0gPT09IDApID8gWyAndicsIHBbMV0gXSA6IFsgJ2wnLCBwWzBdLCBwWzFdIF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzpcbiAgICAgICAgcCAgICAgID0gbS5jYWxjKHgsIHNbMV0sIGZhbHNlKTtcbiAgICAgICAgcmVzdWx0ID0gKHBbMF0gPT09IG0uY2FsYyh4LCB5LCBmYWxzZSlbMF0pID8gWyAnVicsIHBbMV0gXSA6IFsgJ0wnLCBwWzBdLCBwWzFdIF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoJzpcbiAgICAgICAgcCAgICAgID0gbS5jYWxjKHNbMV0sIDAsIHRydWUpO1xuICAgICAgICByZXN1bHQgPSAocFsxXSA9PT0gMCkgPyBbICdoJywgcFswXSBdIDogWyAnbCcsIHBbMF0sIHBbMV0gXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICBwICAgICAgPSBtLmNhbGMoc1sxXSwgeSwgZmFsc2UpO1xuICAgICAgICByZXN1bHQgPSAocFsxXSA9PT0gbS5jYWxjKHgsIHksIGZhbHNlKVsxXSkgPyBbICdIJywgcFswXSBdIDogWyAnTCcsIHBbMF0sIHBbMV0gXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIC8vIEFSQyBpczogWydBJywgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxuXG4gICAgICAgIC8vIERyb3Agc2VnbWVudCBpZiBhcmMgaXMgZW1wdHkgKGVuZCBwb2ludCA9PT0gc3RhcnQgcG9pbnQpXG4gICAgICAgIC8qaWYgKChzWzBdID09PSAnQScgJiYgc1s2XSA9PT0geCAmJiBzWzddID09PSB5KSB8fFxuICAgICAgICAgICAgKHNbMF0gPT09ICdhJyAmJiBzWzZdID09PSAwICYmIHNbN10gPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9Ki9cblxuICAgICAgICAvLyBUcmFuc2Zvcm0gcngsIHJ5IGFuZCB0aGUgeC1heGlzLXJvdGF0aW9uXG4gICAgICAgIHZhciBtYSA9IG0udG9BcnJheSgpO1xuICAgICAgICB2YXIgZSA9IGVsbGlwc2Uoc1sxXSwgc1syXSwgc1szXSkudHJhbnNmb3JtKG1hKTtcblxuICAgICAgICAvLyBmbGlwIHN3ZWVwLWZsYWcgaWYgbWF0cml4IGlzIG5vdCBvcmllbnRhdGlvbi1wcmVzZXJ2aW5nXG4gICAgICAgIGlmIChtYVswXSAqIG1hWzNdIC0gbWFbMV0gKiBtYVsyXSA8IDApIHtcbiAgICAgICAgICBzWzVdID0gc1s1XSA/ICcwJyA6ICcxJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYW5zZm9ybSBlbmQgcG9pbnQgYXMgdXN1YWwgKHdpdGhvdXQgdHJhbnNsYXRpb24gZm9yIHJlbGF0aXZlIG5vdGF0aW9uKVxuICAgICAgICBwID0gbS5jYWxjKHNbNl0sIHNbN10sIHNbMF0gPT09ICdhJyk7XG5cbiAgICAgICAgLy8gRW1wdHkgYXJjcyBjYW4gYmUgaWdub3JlZCBieSByZW5kZXJlciwgYnV0IHNob3VsZCBub3QgYmUgZHJvcHBlZFxuICAgICAgICAvLyB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggYFMgQSBTYCBhbmQgc28gb24uIFJlcGxhY2Ugd2l0aCBlbXB0eSBsaW5lLlxuICAgICAgICBpZiAoKHNbMF0gPT09ICdBJyAmJiBzWzZdID09PSB4ICYmIHNbN10gPT09IHkpIHx8XG4gICAgICAgICAgICAoc1swXSA9PT0gJ2EnICYmIHNbNl0gPT09IDAgJiYgc1s3XSA9PT0gMCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBbIHNbMF0gPT09ICdhJyA/ICdsJyA6ICdMJywgcFswXSwgcFsxXSBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHJlc3VsdGluZyBlbGxpcHNlIGlzIChhbG1vc3QpIGEgc2VnbWVudCAuLi5cbiAgICAgICAgaWYgKGUuaXNEZWdlbmVyYXRlKCkpIHtcbiAgICAgICAgICAvLyByZXBsYWNlIHRoZSBhcmMgYnkgYSBsaW5lXG4gICAgICAgICAgcmVzdWx0ID0gWyBzWzBdID09PSAnYScgPyAnbCcgOiAnTCcsIHBbMF0sIHBbMV0gXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBpdCBpcyBhIHJlYWwgZWxsaXBzZVxuICAgICAgICAgIC8vIHNbMF0sIHNbNF0gYW5kIHNbNV0gYXJlIG5vdCBtb2RpZmllZFxuICAgICAgICAgIHJlc3VsdCA9IFsgc1swXSwgZS5yeCwgZS5yeSwgZS5heCwgc1s0XSwgc1s1XSwgcFswXSwgcFsxXSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICAvLyBFZGdlIGNhc2UuIFRoZSB2ZXJ5IGZpcnN0IGBtYCBzaG91bGQgYmUgcHJvY2Vzc2VkIGFzIGFic29sdXRlLCBpZiBoYXBwZW5zLlxuICAgICAgICAvLyBNYWtlIHNlbnNlIGZvciBjb29yZCBzaGlmdCB0cmFuc2Zvcm1zLlxuICAgICAgICBpc1JlbGF0aXZlID0gaW5kZXggPiAwO1xuXG4gICAgICAgIHAgPSBtLmNhbGMoc1sxXSwgc1syXSwgaXNSZWxhdGl2ZSk7XG4gICAgICAgIHJlc3VsdCA9IFsgJ20nLCBwWzBdLCBwWzFdIF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuYW1lICAgICAgID0gc1swXTtcbiAgICAgICAgcmVzdWx0ICAgICA9IFsgbmFtZSBdO1xuICAgICAgICBpc1JlbGF0aXZlID0gKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSk7XG5cbiAgICAgICAgLy8gQXBwbHkgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBzZWdtZW50XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgcCA9IG0uY2FsYyhzW2ldLCBzW2kgKyAxXSwgaXNSZWxhdGl2ZSk7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocFswXSwgcFsxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLnNlZ21lbnRzW2luZGV4XSA9IHJlc3VsdDtcbiAgfSwgdHJ1ZSk7XG59O1xuXG5cbi8vIEFwcGx5IHN0YWNrZWQgY29tbWFuZHNcbi8vXG5TdmdQYXRoLnByb3RvdHlwZS5fX2V2YWx1YXRlU3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtLCBpO1xuXG4gIGlmICghdGhpcy5fX3N0YWNrLmxlbmd0aCkgeyByZXR1cm47IH1cblxuICBpZiAodGhpcy5fX3N0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuX19tYXRyaXgodGhpcy5fX3N0YWNrWzBdKTtcbiAgICB0aGlzLl9fc3RhY2sgPSBbXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBtID0gbWF0cml4KCk7XG4gIGkgPSB0aGlzLl9fc3RhY2subGVuZ3RoO1xuXG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIG0ubWF0cml4KHRoaXMuX19zdGFja1tpXS50b0FycmF5KCkpO1xuICB9XG5cbiAgdGhpcy5fX21hdHJpeChtKTtcbiAgdGhpcy5fX3N0YWNrID0gW107XG59O1xuXG5cbi8vIENvbnZlcnQgcHJvY2Vzc2VkIFNWRyBQYXRoIGJhY2sgdG8gc3RyaW5nXG4vL1xuU3ZnUGF0aC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXN1bHQgPSAnJywgcHJldkNtZCA9ICcnLCBjbWRTa2lwcGVkID0gZmFsc2U7XG5cbiAgdGhpcy5fX2V2YWx1YXRlU3RhY2soKTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5zZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXTtcbiAgICB2YXIgY21kID0gc2VnbWVudFswXTtcblxuICAgIC8vIENvbW1hbmQgbm90IHJlcGVhdGluZyA9PiBzdG9yZVxuICAgIGlmIChjbWQgIT09IHByZXZDbWQgfHwgY21kID09PSAnbScgfHwgY21kID09PSAnTScpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIEZvbnRGb3JnZSBTVkcgaW1wb3J0aW5nIGJ1Zywga2VlcCBzcGFjZSBiZXR3ZWVuIFwieiBtXCIuXG4gICAgICBpZiAoY21kID09PSAnbScgJiYgcHJldkNtZCA9PT0gJ3onKSByZXN1bHQgKz0gJyAnO1xuICAgICAgcmVzdWx0ICs9IGNtZDtcblxuICAgICAgY21kU2tpcHBlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbWRTa2lwcGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBzZWdtZW50IHBhcmFtc1xuICAgIGZvciAodmFyIHBvcyA9IDE7IHBvcyA8IHNlZ21lbnQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgdmFyIHZhbCA9IHNlZ21lbnRbcG9zXTtcbiAgICAgIC8vIFNwYWNlIGNhbiBiZSBza2lwcGVkXG4gICAgICAvLyAxLiBBZnRlciBjb21tYW5kIChhbHdheXMpXG4gICAgICAvLyAyLiBGb3IgbmVnYXRpdmUgdmFsdWUgKHdpdGggJy0nIGF0IHN0YXJ0KVxuICAgICAgaWYgKHBvcyA9PT0gMSkge1xuICAgICAgICBpZiAoY21kU2tpcHBlZCAmJiB2YWwgPj0gMCkgcmVzdWx0ICs9ICcgJztcbiAgICAgIH0gZWxzZSBpZiAodmFsID49IDApIHJlc3VsdCArPSAnICc7XG5cbiAgICAgIHJlc3VsdCArPSB2YWw7XG4gICAgfVxuXG4gICAgcHJldkNtZCA9IGNtZDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIFRyYW5zbGF0ZSBwYXRoIHRvICh4IFssIHldKVxuLy9cblN2Z1BhdGgucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHRoaXMuX19zdGFjay5wdXNoKG1hdHJpeCgpLnRyYW5zbGF0ZSh4LCB5IHx8IDApKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIFNjYWxlIHBhdGggdG8gKHN4IFssIHN5XSlcbi8vIHN5ID0gc3ggaWYgbm90IGRlZmluZWRcbi8vXG5TdmdQYXRoLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgdGhpcy5fX3N0YWNrLnB1c2gobWF0cml4KCkuc2NhbGUoc3gsICghc3kgJiYgKHN5ICE9PSAwKSkgPyBzeCA6IHN5KSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBSb3RhdGUgcGF0aCBhcm91bmQgcG9pbnQgKHN4IFssIHN5XSlcbi8vIHN5ID0gc3ggaWYgbm90IGRlZmluZWRcbi8vXG5TdmdQYXRoLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUsIHJ4LCByeSkge1xuICB0aGlzLl9fc3RhY2sucHVzaChtYXRyaXgoKS5yb3RhdGUoYW5nbGUsIHJ4IHx8IDAsIHJ5IHx8IDApKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIFNrZXcgcGF0aCBhbG9uZyB0aGUgWCBheGlzIGJ5IGBkZWdyZWVzYCBhbmdsZVxuLy9cblN2Z1BhdGgucHJvdG90eXBlLnNrZXdYID0gZnVuY3Rpb24gKGRlZ3JlZXMpIHtcbiAgdGhpcy5fX3N0YWNrLnB1c2gobWF0cml4KCkuc2tld1goZGVncmVlcykpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gU2tldyBwYXRoIGFsb25nIHRoZSBZIGF4aXMgYnkgYGRlZ3JlZXNgIGFuZ2xlXG4vL1xuU3ZnUGF0aC5wcm90b3R5cGUuc2tld1kgPSBmdW5jdGlvbiAoZGVncmVlcykge1xuICB0aGlzLl9fc3RhY2sucHVzaChtYXRyaXgoKS5za2V3WShkZWdyZWVzKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBBcHBseSBtYXRyaXggdHJhbnNmb3JtIChhcnJheSBvZiA2IGVsZW1lbnRzKVxuLy9cblN2Z1BhdGgucHJvdG90eXBlLm1hdHJpeCA9IGZ1bmN0aW9uIChtKSB7XG4gIHRoaXMuX19zdGFjay5wdXNoKG1hdHJpeCgpLm1hdHJpeChtKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBUcmFuc2Zvcm0gcGF0aCBhY2NvcmRpbmcgdG8gXCJ0cmFuc2Zvcm1cIiBhdHRyIG9mIFNWRyBzcGVjXG4vL1xuU3ZnUGF0aC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHRyYW5zZm9ybVN0cmluZykge1xuICBpZiAoIXRyYW5zZm9ybVN0cmluZy50cmltKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9fc3RhY2sucHVzaCh0cmFuc2Zvcm1QYXJzZSh0cmFuc2Zvcm1TdHJpbmcpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIFJvdW5kIGNvb3JkcyB3aXRoIGdpdmVuIGRlY2ltYWwgcHJlY2l0aW9uLlxuLy8gMCBieSBkZWZhdWx0ICh0byBpbnRlZ2Vycylcbi8vXG5TdmdQYXRoLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uIChkKSB7XG4gIHZhciBjb250b3VyU3RhcnREZWx0YVggPSAwLCBjb250b3VyU3RhcnREZWx0YVkgPSAwLCBkZWx0YVggPSAwLCBkZWx0YVkgPSAwLCBsO1xuXG4gIGQgPSBkIHx8IDA7XG5cbiAgdGhpcy5fX2V2YWx1YXRlU3RhY2soKTtcblxuICB0aGlzLnNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgaXNSZWxhdGl2ZSA9IChzWzBdLnRvTG93ZXJDYXNlKCkgPT09IHNbMF0pO1xuXG4gICAgc3dpdGNoIChzWzBdKSB7XG4gICAgICBjYXNlICdIJzpcbiAgICAgIGNhc2UgJ2gnOlxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSkgeyBzWzFdICs9IGRlbHRhWDsgfVxuICAgICAgICBkZWx0YVggPSBzWzFdIC0gc1sxXS50b0ZpeGVkKGQpO1xuICAgICAgICBzWzFdID0gK3NbMV0udG9GaXhlZChkKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdWJzpcbiAgICAgIGNhc2UgJ3YnOlxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSkgeyBzWzFdICs9IGRlbHRhWTsgfVxuICAgICAgICBkZWx0YVkgPSBzWzFdIC0gc1sxXS50b0ZpeGVkKGQpO1xuICAgICAgICBzWzFdID0gK3NbMV0udG9GaXhlZChkKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdaJzpcbiAgICAgIGNhc2UgJ3onOlxuICAgICAgICBkZWx0YVggPSBjb250b3VyU3RhcnREZWx0YVg7XG4gICAgICAgIGRlbHRhWSA9IGNvbnRvdXJTdGFydERlbHRhWTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdNJzpcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSkge1xuICAgICAgICAgIHNbMV0gKz0gZGVsdGFYO1xuICAgICAgICAgIHNbMl0gKz0gZGVsdGFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsdGFYID0gc1sxXSAtIHNbMV0udG9GaXhlZChkKTtcbiAgICAgICAgZGVsdGFZID0gc1syXSAtIHNbMl0udG9GaXhlZChkKTtcblxuICAgICAgICBjb250b3VyU3RhcnREZWx0YVggPSBkZWx0YVg7XG4gICAgICAgIGNvbnRvdXJTdGFydERlbHRhWSA9IGRlbHRhWTtcblxuICAgICAgICBzWzFdID0gK3NbMV0udG9GaXhlZChkKTtcbiAgICAgICAgc1syXSA9ICtzWzJdLnRvRml4ZWQoZCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAnQSc6XG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gW2NtZCwgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSkge1xuICAgICAgICAgIHNbNl0gKz0gZGVsdGFYO1xuICAgICAgICAgIHNbN10gKz0gZGVsdGFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsdGFYID0gc1s2XSAtIHNbNl0udG9GaXhlZChkKTtcbiAgICAgICAgZGVsdGFZID0gc1s3XSAtIHNbN10udG9GaXhlZChkKTtcblxuICAgICAgICBzWzFdID0gK3NbMV0udG9GaXhlZChkKTtcbiAgICAgICAgc1syXSA9ICtzWzJdLnRvRml4ZWQoZCk7XG4gICAgICAgIHNbM10gPSArc1szXS50b0ZpeGVkKGQgKyAyKTsgLy8gYmV0dGVyIHByZWNpc2lvbiBmb3Igcm90YXRpb25cbiAgICAgICAgc1s2XSA9ICtzWzZdLnRvRml4ZWQoZCk7XG4gICAgICAgIHNbN10gPSArc1s3XS50b0ZpeGVkKGQpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGEgYyBsIHEgcyB0XG4gICAgICAgIGwgPSBzLmxlbmd0aDtcblxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSkge1xuICAgICAgICAgIHNbbCAtIDJdICs9IGRlbHRhWDtcbiAgICAgICAgICBzW2wgLSAxXSArPSBkZWx0YVk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWx0YVggPSBzW2wgLSAyXSAtIHNbbCAtIDJdLnRvRml4ZWQoZCk7XG4gICAgICAgIGRlbHRhWSA9IHNbbCAtIDFdIC0gc1tsIC0gMV0udG9GaXhlZChkKTtcblxuICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHZhbCwgaSkge1xuICAgICAgICAgIGlmICghaSkgeyByZXR1cm47IH1cbiAgICAgICAgICBzW2ldID0gK3NbaV0udG9GaXhlZChkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBBcHBseSBpdGVyYXRvciBmdW5jdGlvbiB0byBhbGwgc2VnbWVudHMuIElmIGZ1bmN0aW9uIHJldHVybnMgcmVzdWx0LFxuLy8gY3VycmVudCBzZWdtZW50IHdpbGwgYmUgcmVwbGFjZWQgdG8gYXJyYXkgb2YgcmV0dXJuZWQgc2VnbWVudHMuXG4vLyBJZiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCwgY3VycmVudCByZWdtZW50IHdpbGwgYmUgZGVsZXRlZC5cbi8vXG5TdmdQYXRoLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBrZWVwTGF6eVN0YWNrKSB7XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHMsXG4gICAgICByZXBsYWNlbWVudHMgPSB7fSxcbiAgICAgIG5lZWRSZXBsYWNlID0gZmFsc2UsXG4gICAgICBsYXN0WCA9IDAsXG4gICAgICBsYXN0WSA9IDAsXG4gICAgICBjb3VudG91clN0YXJ0WCA9IDAsXG4gICAgICBjb3VudG91clN0YXJ0WSA9IDA7XG4gIHZhciBpLCBqLCBuZXdTZWdtZW50cztcblxuICBpZiAoIWtlZXBMYXp5U3RhY2spIHtcbiAgICB0aGlzLl9fZXZhbHVhdGVTdGFjaygpO1xuICB9XG5cbiAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAocywgaW5kZXgpIHtcblxuICAgIHZhciByZXMgPSBpdGVyYXRvcihzLCBpbmRleCwgbGFzdFgsIGxhc3RZKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICAgIHJlcGxhY2VtZW50c1tpbmRleF0gPSByZXM7XG4gICAgICBuZWVkUmVwbGFjZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVsYXRpdmUgPSAoc1swXSA9PT0gc1swXS50b0xvd2VyQ2FzZSgpKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBhYnNvbHV0ZSBYIGFuZCBZXG4gICAgc3dpdGNoIChzWzBdKSB7XG4gICAgICBjYXNlICdtJzpcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICBsYXN0WCA9IHNbMV0gKyAoaXNSZWxhdGl2ZSA/IGxhc3RYIDogMCk7XG4gICAgICAgIGxhc3RZID0gc1syXSArIChpc1JlbGF0aXZlID8gbGFzdFkgOiAwKTtcbiAgICAgICAgY291bnRvdXJTdGFydFggPSBsYXN0WDtcbiAgICAgICAgY291bnRvdXJTdGFydFkgPSBsYXN0WTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdoJzpcbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICBsYXN0WCA9IHNbMV0gKyAoaXNSZWxhdGl2ZSA/IGxhc3RYIDogMCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAndic6XG4gICAgICBjYXNlICdWJzpcbiAgICAgICAgbGFzdFkgPSBzWzFdICsgKGlzUmVsYXRpdmUgPyBsYXN0WSA6IDApO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ3onOlxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIC8vIFRoYXQgbWFrZSBzZW5jZSBmb3IgbXVsdGlwbGUgY29udG91cnNcbiAgICAgICAgbGFzdFggPSBjb3VudG91clN0YXJ0WDtcbiAgICAgICAgbGFzdFkgPSBjb3VudG91clN0YXJ0WTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsYXN0WCA9IHNbcy5sZW5ndGggLSAyXSArIChpc1JlbGF0aXZlID8gbGFzdFggOiAwKTtcbiAgICAgICAgbGFzdFkgPSBzW3MubGVuZ3RoIC0gMV0gKyAoaXNSZWxhdGl2ZSA/IGxhc3RZIDogMCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBSZXBsYWNlIHNlZ21lbnRzIGlmIGl0ZXJhdG9yIHJldHVybiByZXN1bHRzXG5cbiAgaWYgKCFuZWVkUmVwbGFjZSkgeyByZXR1cm4gdGhpczsgfVxuXG4gIG5ld1NlZ21lbnRzID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudHNbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgcmVwbGFjZW1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG5ld1NlZ21lbnRzLnB1c2gocmVwbGFjZW1lbnRzW2ldW2pdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U2VnbWVudHMucHVzaChzZWdtZW50c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zZWdtZW50cyA9IG5ld1NlZ21lbnRzO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBDb252ZXJ0cyBzZWdtZW50cyBmcm9tIHJlbGF0aXZlIHRvIGFic29sdXRlXG4vL1xuU3ZnUGF0aC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuaXRlcmF0ZShmdW5jdGlvbiAocywgaW5kZXgsIHgsIHkpIHtcbiAgICB2YXIgbmFtZSA9IHNbMF0sXG4gICAgICAgIG5hbWVVQyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgaTtcblxuICAgIC8vIFNraXAgYWJzb2x1dGUgY29tbWFuZHNcbiAgICBpZiAobmFtZSA9PT0gbmFtZVVDKSB7IHJldHVybjsgfVxuXG4gICAgc1swXSA9IG5hbWVVQztcblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAndic6XG4gICAgICAgIC8vIHYgaGFzIHNoaWZ0ZWQgY29vcmRzIHBhcml0eVxuICAgICAgICBzWzFdICs9IHk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIEFSQyBpczogWydBJywgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxuICAgICAgICAvLyB0b3VjaCB4LCB5IG9ubHlcbiAgICAgICAgc1s2XSArPSB4O1xuICAgICAgICBzWzddICs9IHk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzW2ldICs9IGkgJSAyID8geCA6IHk7IC8vIG9kZCB2YWx1ZXMgYXJlIFgsIGV2ZW4gLSBZXG4gICAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBDb252ZXJ0cyBzZWdtZW50cyBmcm9tIGFic29sdXRlIHRvIHJlbGF0aXZlXG4vL1xuU3ZnUGF0aC5wcm90b3R5cGUucmVsID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuaXRlcmF0ZShmdW5jdGlvbiAocywgaW5kZXgsIHgsIHkpIHtcbiAgICB2YXIgbmFtZSA9IHNbMF0sXG4gICAgICAgIG5hbWVMQyA9IG5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgaTtcblxuICAgIC8vIFNraXAgcmVsYXRpdmUgY29tbWFuZHNcbiAgICBpZiAobmFtZSA9PT0gbmFtZUxDKSB7IHJldHVybjsgfVxuXG4gICAgLy8gRG9uJ3QgdG91Y2ggdGhlIGZpcnN0IE0gdG8gYXZvaWQgcG90ZW50aWFsIGNvbmZ1c2lvbnMuXG4gICAgaWYgKGluZGV4ID09PSAwICYmIG5hbWUgPT09ICdNJykgeyByZXR1cm47IH1cblxuICAgIHNbMF0gPSBuYW1lTEM7XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAvLyBWIGhhcyBzaGlmdGVkIGNvb3JkcyBwYXJpdHlcbiAgICAgICAgc1sxXSAtPSB5O1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAvLyBBUkMgaXM6IFsnQScsIHJ4LCByeSwgeC1heGlzLXJvdGF0aW9uLCBsYXJnZS1hcmMtZmxhZywgc3dlZXAtZmxhZywgeCwgeV1cbiAgICAgICAgLy8gdG91Y2ggeCwgeSBvbmx5XG4gICAgICAgIHNbNl0gLT0geDtcbiAgICAgICAgc1s3XSAtPSB5O1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc1tpXSAtPSBpICUgMiA/IHggOiB5OyAvLyBvZGQgdmFsdWVzIGFyZSBYLCBldmVuIC0gWVxuICAgICAgICB9XG4gICAgfVxuICB9LCB0cnVlKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gQ29udmVydHMgYXJjcyB0byBjdWJpYyBiw6l6aWVyIGN1cnZlc1xuLy9cblN2Z1BhdGgucHJvdG90eXBlLnVuYXJjID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLml0ZXJhdGUoZnVuY3Rpb24gKHMsIGluZGV4LCB4LCB5KSB7XG4gICAgdmFyIG5ld19zZWdtZW50cywgbmV4dFgsIG5leHRZLCByZXN1bHQgPSBbXSwgbmFtZSA9IHNbMF07XG5cbiAgICAvLyBTa2lwIGFueXRoaW5nIGV4Y2VwdCBhcmNzXG4gICAgaWYgKG5hbWUgIT09ICdBJyAmJiBuYW1lICE9PSAnYScpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIGlmIChuYW1lID09PSAnYScpIHtcbiAgICAgIC8vIGNvbnZlcnQgcmVsYXRpdmUgYXJjIGNvb3JkaW5hdGVzIHRvIGFic29sdXRlXG4gICAgICBuZXh0WCA9IHggKyBzWzZdO1xuICAgICAgbmV4dFkgPSB5ICsgc1s3XTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFggPSBzWzZdO1xuICAgICAgbmV4dFkgPSBzWzddO1xuICAgIH1cblxuICAgIG5ld19zZWdtZW50cyA9IGEyYyh4LCB5LCBuZXh0WCwgbmV4dFksIHNbNF0sIHNbNV0sIHNbMV0sIHNbMl0sIHNbM10pO1xuXG4gICAgLy8gRGVnZW5lcmF0ZWQgYXJjcyBjYW4gYmUgaWdub3JlZCBieSByZW5kZXJlciwgYnV0IHNob3VsZCBub3QgYmUgZHJvcHBlZFxuICAgIC8vIHRvIGF2b2lkIGNvbGxpc2lvbnMgd2l0aCBgUyBBIFNgIGFuZCBzbyBvbi4gUmVwbGFjZSB3aXRoIGVtcHR5IGxpbmUuXG4gICAgaWYgKG5ld19zZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbIFsgc1swXSA9PT0gJ2EnID8gJ2wnIDogJ0wnLCBzWzZdLCBzWzddIF0gXTtcbiAgICB9XG5cbiAgICBuZXdfc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgcmVzdWx0LnB1c2goWyAnQycsIHNbMl0sIHNbM10sIHNbNF0sIHNbNV0sIHNbNl0sIHNbN10gXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gQ29udmVydHMgc21vb3RoIGN1cnZlcyAod2l0aCBtaXNzZWQgY29udHJvbCBwb2ludCkgdG8gZ2VuZXJpYyBjdXJ2ZXNcbi8vXG5TdmdQYXRoLnByb3RvdHlwZS51bnNob3J0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICB2YXIgcHJldkNvbnRyb2xYLCBwcmV2Q29udHJvbFksIHByZXZTZWdtZW50O1xuICB2YXIgY3VyQ29udHJvbFgsIGN1ckNvbnRyb2xZO1xuXG4gIC8vIFRPRE86IGFkZCBsYXp5IGV2YWx1YXRpb24gZmxhZyB3aGVuIHJlbGF0aXZlIGNvbW1hbmRzIHN1cHBvcnRlZFxuXG4gIHRoaXMuaXRlcmF0ZShmdW5jdGlvbiAocywgaWR4LCB4LCB5KSB7XG4gICAgdmFyIG5hbWUgPSBzWzBdLCBuYW1lVUMgPSBuYW1lLnRvVXBwZXJDYXNlKCksIGlzUmVsYXRpdmU7XG5cbiAgICAvLyBGaXJzdCBjb21tYW5kIE1VU1QgYmUgTXxtLCBpdCdzIHNhZmUgdG8gc2tpcC5cbiAgICAvLyBQcm90ZWN0IGZyb20gYWNjZXNzIHRvIFstMV0gZm9yIHN1cmUuXG4gICAgaWYgKCFpZHgpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAobmFtZVVDID09PSAnVCcpIHsgLy8gcXVhZHJhdGljIGN1cnZlXG4gICAgICBpc1JlbGF0aXZlID0gKG5hbWUgPT09ICd0Jyk7XG5cbiAgICAgIHByZXZTZWdtZW50ID0gc2VnbWVudHNbaWR4IC0gMV07XG5cbiAgICAgIGlmIChwcmV2U2VnbWVudFswXSA9PT0gJ1EnKSB7XG4gICAgICAgIHByZXZDb250cm9sWCA9IHByZXZTZWdtZW50WzFdIC0geDtcbiAgICAgICAgcHJldkNvbnRyb2xZID0gcHJldlNlZ21lbnRbMl0gLSB5O1xuICAgICAgfSBlbHNlIGlmIChwcmV2U2VnbWVudFswXSA9PT0gJ3EnKSB7XG4gICAgICAgIHByZXZDb250cm9sWCA9IHByZXZTZWdtZW50WzFdIC0gcHJldlNlZ21lbnRbM107XG4gICAgICAgIHByZXZDb250cm9sWSA9IHByZXZTZWdtZW50WzJdIC0gcHJldlNlZ21lbnRbNF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2Q29udHJvbFggPSAwO1xuICAgICAgICBwcmV2Q29udHJvbFkgPSAwO1xuICAgICAgfVxuXG4gICAgICBjdXJDb250cm9sWCA9IC1wcmV2Q29udHJvbFg7XG4gICAgICBjdXJDb250cm9sWSA9IC1wcmV2Q29udHJvbFk7XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICBjdXJDb250cm9sWCArPSB4O1xuICAgICAgICBjdXJDb250cm9sWSArPSB5O1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50c1tpZHhdID0gW1xuICAgICAgICBpc1JlbGF0aXZlID8gJ3EnIDogJ1EnLFxuICAgICAgICBjdXJDb250cm9sWCwgY3VyQ29udHJvbFksXG4gICAgICAgIHNbMV0sIHNbMl1cbiAgICAgIF07XG5cbiAgICB9IGVsc2UgaWYgKG5hbWVVQyA9PT0gJ1MnKSB7IC8vIGN1YmljIGN1cnZlXG4gICAgICBpc1JlbGF0aXZlID0gKG5hbWUgPT09ICdzJyk7XG5cbiAgICAgIHByZXZTZWdtZW50ID0gc2VnbWVudHNbaWR4IC0gMV07XG5cbiAgICAgIGlmIChwcmV2U2VnbWVudFswXSA9PT0gJ0MnKSB7XG4gICAgICAgIHByZXZDb250cm9sWCA9IHByZXZTZWdtZW50WzNdIC0geDtcbiAgICAgICAgcHJldkNvbnRyb2xZID0gcHJldlNlZ21lbnRbNF0gLSB5O1xuICAgICAgfSBlbHNlIGlmIChwcmV2U2VnbWVudFswXSA9PT0gJ2MnKSB7XG4gICAgICAgIHByZXZDb250cm9sWCA9IHByZXZTZWdtZW50WzNdIC0gcHJldlNlZ21lbnRbNV07XG4gICAgICAgIHByZXZDb250cm9sWSA9IHByZXZTZWdtZW50WzRdIC0gcHJldlNlZ21lbnRbNl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2Q29udHJvbFggPSAwO1xuICAgICAgICBwcmV2Q29udHJvbFkgPSAwO1xuICAgICAgfVxuXG4gICAgICBjdXJDb250cm9sWCA9IC1wcmV2Q29udHJvbFg7XG4gICAgICBjdXJDb250cm9sWSA9IC1wcmV2Q29udHJvbFk7XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICBjdXJDb250cm9sWCArPSB4O1xuICAgICAgICBjdXJDb250cm9sWSArPSB5O1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50c1tpZHhdID0gW1xuICAgICAgICBpc1JlbGF0aXZlID8gJ2MnIDogJ0MnLFxuICAgICAgICBjdXJDb250cm9sWCwgY3VyQ29udHJvbFksXG4gICAgICAgIHNbMV0sIHNbMl0sIHNbM10sIHNbNF1cbiAgICAgIF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdmdQYXRoO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/svgpath/lib/svgpath.js\n");

/***/ }),

/***/ "./node_modules/svgpath/lib/transform_parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/svgpath/lib/transform_parse.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\n\nvar Matrix = __webpack_require__(/*! ./matrix */ \"./node_modules/svgpath/lib/matrix.js\");\n\nvar operations = {\n  matrix: true,\n  scale: true,\n  rotate: true,\n  translate: true,\n  skewX: true,\n  skewY: true\n};\n\nvar CMD_SPLIT_RE    = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\nvar PARAMS_SPLIT_RE = /[\\s,]+/;\n\n\nmodule.exports = function transformParse(transformString) {\n  var matrix = new Matrix();\n  var cmd, params;\n\n  // Split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate',  '-45', '']\n  transformString.split(CMD_SPLIT_RE).forEach(function (item) {\n\n    // Skip empty elements\n    if (!item.length) { return; }\n\n    // remember operation\n    if (typeof operations[item] !== 'undefined') {\n      cmd = item;\n      return;\n    }\n\n    // extract params & att operation to matrix\n    params = item.split(PARAMS_SPLIT_RE).map(function (i) {\n      return +i || 0;\n    });\n\n    // If params count is not correct - ignore command\n    switch (cmd) {\n      case 'matrix':\n        if (params.length === 6) {\n          matrix.matrix(params);\n        }\n        return;\n\n      case 'scale':\n        if (params.length === 1) {\n          matrix.scale(params[0], params[0]);\n        } else if (params.length === 2) {\n          matrix.scale(params[0], params[1]);\n        }\n        return;\n\n      case 'rotate':\n        if (params.length === 1) {\n          matrix.rotate(params[0], 0, 0);\n        } else if (params.length === 3) {\n          matrix.rotate(params[0], params[1], params[2]);\n        }\n        return;\n\n      case 'translate':\n        if (params.length === 1) {\n          matrix.translate(params[0], 0);\n        } else if (params.length === 2) {\n          matrix.translate(params[0], params[1]);\n        }\n        return;\n\n      case 'skewX':\n        if (params.length === 1) {\n          matrix.skewX(params[0]);\n        }\n        return;\n\n      case 'skewY':\n        if (params.length === 1) {\n          matrix.skewY(params[0]);\n        }\n        return;\n    }\n  });\n\n  return matrix;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvdHJhbnNmb3JtX3BhcnNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7QUFHYixhQUFhLG1CQUFPLENBQUMsc0RBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvdHJhbnNmb3JtX3BhcnNlLmpzP2QyODgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBNYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG52YXIgb3BlcmF0aW9ucyA9IHtcbiAgbWF0cml4OiB0cnVlLFxuICBzY2FsZTogdHJ1ZSxcbiAgcm90YXRlOiB0cnVlLFxuICB0cmFuc2xhdGU6IHRydWUsXG4gIHNrZXdYOiB0cnVlLFxuICBza2V3WTogdHJ1ZVxufTtcblxudmFyIENNRF9TUExJVF9SRSAgICA9IC9cXHMqKG1hdHJpeHx0cmFuc2xhdGV8c2NhbGV8cm90YXRlfHNrZXdYfHNrZXdZKVxccypcXChcXHMqKC4rPylcXHMqXFwpW1xccyxdKi87XG52YXIgUEFSQU1TX1NQTElUX1JFID0gL1tcXHMsXSsvO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtUGFyc2UodHJhbnNmb3JtU3RyaW5nKSB7XG4gIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gIHZhciBjbWQsIHBhcmFtcztcblxuICAvLyBTcGxpdCB2YWx1ZSBpbnRvIFsnJywgJ3RyYW5zbGF0ZScsICcxMCA1MCcsICcnLCAnc2NhbGUnLCAnMicsICcnLCAncm90YXRlJywgICctNDUnLCAnJ11cbiAgdHJhbnNmb3JtU3RyaW5nLnNwbGl0KENNRF9TUExJVF9SRSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXG4gICAgLy8gU2tpcCBlbXB0eSBlbGVtZW50c1xuICAgIGlmICghaXRlbS5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyByZW1lbWJlciBvcGVyYXRpb25cbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbnNbaXRlbV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjbWQgPSBpdGVtO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgcGFyYW1zICYgYXR0IG9wZXJhdGlvbiB0byBtYXRyaXhcbiAgICBwYXJhbXMgPSBpdGVtLnNwbGl0KFBBUkFNU19TUExJVF9SRSkubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gK2kgfHwgMDtcbiAgICB9KTtcblxuICAgIC8vIElmIHBhcmFtcyBjb3VudCBpcyBub3QgY29ycmVjdCAtIGlnbm9yZSBjb21tYW5kXG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSA2KSB7XG4gICAgICAgICAgbWF0cml4Lm1hdHJpeChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG1hdHJpeC5zY2FsZShwYXJhbXNbMF0sIHBhcmFtc1swXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIG1hdHJpeC5zY2FsZShwYXJhbXNbMF0sIHBhcmFtc1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG1hdHJpeC5yb3RhdGUocGFyYW1zWzBdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgbWF0cml4LnJvdGF0ZShwYXJhbXNbMF0sIHBhcmFtc1sxXSwgcGFyYW1zWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShwYXJhbXNbMF0sIDApO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBhcmFtc1swXSwgcGFyYW1zWzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ3NrZXdYJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBtYXRyaXguc2tld1gocGFyYW1zWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBtYXRyaXguc2tld1kocGFyYW1zWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbWF0cml4O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/svgpath/lib/transform_parse.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _assertThisInitialized; }\n/* harmony export */ });\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/ZjY0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _classCallCheck; }\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzPzA1MzQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _createClass; }\n/* harmony export */ });\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcz83MTIzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _getPrototypeOf; }\n/* harmony export */ });\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanM/NThhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _inherits; }\n/* harmony export */ });\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/next/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(subClass, superClass);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUQ7QUFDbEM7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQiw4REFBYztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanM/MjU4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc2V0UHJvdG90eXBlT2YgZnJvbSBcIi4vc2V0UHJvdG90eXBlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _possibleConstructorReturn; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/next/node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(self);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0Q7QUFDVztBQUNoRDtBQUNmLGVBQWUseUVBQU87QUFDdEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxTQUFTLHFFQUFxQjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz80ZGZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiO1xuaW1wb3J0IGFzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _setPrototypeOf; }\n/* harmony export */ });\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanM/MjIxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _typeof; }\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcz9mMDVkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/esm/typeof.js\n");

/***/ })

});